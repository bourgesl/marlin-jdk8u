<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2007, 2015, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the "Classpath" exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.java2d.marlin;
  27 
  28 import java.util.Arrays;
  29 import sun.awt.geom.PathConsumer2D;
  30 import static sun.java2d.marlin.OffHeapArray.SIZE_INT;
  31 import jdk.internal.misc.Unsafe;
  32 
  33 final class Renderer implements PathConsumer2D, MarlinConst {
  34 
  35     static final boolean DISABLE_RENDER = false;
  36 
  37     static final boolean ENABLE_BLOCK_FLAGS = MarlinProperties.isUseTileFlags();
  38     static final boolean ENABLE_BLOCK_FLAGS_HEURISTICS = MarlinProperties.isUseTileFlagsWithHeuristics();
  39 
  40     private static final int ALL_BUT_LSB = 0xfffffffe;
  41     private static final int ERR_STEP_MAX = 0x7fffffff; // = 2^31 - 1
  42 
  43     private static final double POWER_2_TO_32 = FloatMath.powerOfTwoD(32);
  44 
  45     // use float to make tosubpix methods faster (no int to float conversion)
  46     public static final float f_SUBPIXEL_POSITIONS_X
  47         = (float) SUBPIXEL_POSITIONS_X;
  48     public static final float f_SUBPIXEL_POSITIONS_Y
  49         = (float) SUBPIXEL_POSITIONS_Y;
  50     public static final int SUBPIXEL_MASK_X = SUBPIXEL_POSITIONS_X - 1;
  51     public static final int SUBPIXEL_MASK_Y = SUBPIXEL_POSITIONS_Y - 1;
  52 
  53     // number of subpixels corresponding to a tile line
  54     private static final int SUBPIXEL_TILE
  55         = TILE_SIZE &lt;&lt; SUBPIXEL_LG_POSITIONS_Y;
  56 
  57     // 2048 (pixelSize) pixels (height) x 8 subpixels = 64K
  58     static final int INITIAL_BUCKET_ARRAY
  59         = INITIAL_PIXEL_DIM * SUBPIXEL_POSITIONS_Y;
  60 
  61     public static final int WIND_EVEN_ODD = 0;
  62     public static final int WIND_NON_ZERO = 1;
  63 
  64     // common to all types of input path segments.
  65     // OFFSET as bytes
  66     // only integer values:
  67     public static final long OFF_CURX_OR  = 0;
  68     public static final long OFF_ERROR    = OFF_CURX_OR  + SIZE_INT;
  69     public static final long OFF_BUMP_X   = OFF_ERROR    + SIZE_INT;
  70     public static final long OFF_BUMP_ERR = OFF_BUMP_X   + SIZE_INT;
  71     public static final long OFF_NEXT     = OFF_BUMP_ERR + SIZE_INT;
  72     public static final long OFF_YMAX     = OFF_NEXT     + SIZE_INT;
  73 
  74     // size of one edge in bytes
  75     public static final int SIZEOF_EDGE_BYTES = (int)(OFF_YMAX + SIZE_INT);
  76 
  77     // curve break into lines
  78     // cubic error in subpixels to decrement step
  79     private static final float CUB_DEC_ERR_SUBPIX
  80         = 2.5f * (NORM_SUBPIXELS / 8f); // 2.5 subpixel for typical 8x8 subpixels
  81     // cubic error in subpixels to increment step
  82     private static final float CUB_INC_ERR_SUBPIX
  83         = 1f * (NORM_SUBPIXELS / 8f); // 1 subpixel for typical 8x8 subpixels
  84 
  85     // cubic bind length to decrement step = 8 * error in subpixels
  86     // pisces: 20 / 8
  87     // openjfx pisces: 8 / 3.2
  88     // multiply by 8 = error scale factor:
  89     public static final float CUB_DEC_BND
  90         = 8f * CUB_DEC_ERR_SUBPIX; // 20f means 2.5 subpixel error
  91     // cubic bind length to increment step = 8 * error in subpixels
  92     public static final float CUB_INC_BND
  93         = 8f * CUB_INC_ERR_SUBPIX; // 8f means 1 subpixel error
  94 
  95     // cubic countlg
  96     public static final int CUB_COUNT_LG = 2;
  97     // cubic count = 2^countlg
  98     private static final int CUB_COUNT = 1 &lt;&lt; CUB_COUNT_LG;
  99     // cubic count^2 = 4^countlg
 100     private static final int CUB_COUNT_2 = 1 &lt;&lt; (2 * CUB_COUNT_LG);
 101     // cubic count^3 = 8^countlg
 102     private static final int CUB_COUNT_3 = 1 &lt;&lt; (3 * CUB_COUNT_LG);
 103     // cubic dt = 1 / count
 104     private static final float CUB_INV_COUNT = 1f / CUB_COUNT;
 105     // cubic dt^2 = 1 / count^2 = 1 / 4^countlg
 106     private static final float CUB_INV_COUNT_2 = 1f / CUB_COUNT_2;
 107     // cubic dt^3 = 1 / count^3 = 1 / 8^countlg
 108     private static final float CUB_INV_COUNT_3 = 1f / CUB_COUNT_3;
 109 
 110     // quad break into lines
 111     // quadratic error in subpixels
 112     private static final float QUAD_DEC_ERR_SUBPIX
 113         = 1f * (NORM_SUBPIXELS / 8f); // 1 subpixel for typical 8x8 subpixels
 114 
 115     // quadratic bind length to decrement step = 8 * error in subpixels
 116     // pisces and openjfx pisces: 32
 117     public static final float QUAD_DEC_BND
 118         = 8f * QUAD_DEC_ERR_SUBPIX; // 8f means 1 subpixel error
 119 
 120 //////////////////////////////////////////////////////////////////////////////
 121 //  SCAN LINE
 122 //////////////////////////////////////////////////////////////////////////////
 123     // crossings ie subpixel edge x coordinates
 124     private int[] crossings;
 125     // auxiliary storage for crossings (merge sort)
 126     private int[] aux_crossings;
 127 
 128     // indices into the segment pointer lists. They indicate the "active"
 129     // sublist in the segment lists (the portion of the list that contains
 130     // all the segments that cross the next scan line).
 131     private int edgeCount;
 132     private int[] edgePtrs;
 133     // auxiliary storage for edge pointers (merge sort)
 134     private int[] aux_edgePtrs;
 135 
 136     // max used for both edgePtrs and crossings (stats only)
 137     private int activeEdgeMaxUsed;
 138 
 139     // per-thread initial arrays (large enough to satisfy most usages) (1024)
 140     private final int[] crossings_initial = new int[INITIAL_SMALL_ARRAY]; // 4K
 141     // +1 to avoid recycling in Helpers.widenArray()
 142     private final int[] edgePtrs_initial  = new int[INITIAL_SMALL_ARRAY + 1]; // 4K
 143     // merge sort initial arrays (large enough to satisfy most usages) (1024)
 144     private final int[] aux_crossings_initial = new int[INITIAL_SMALL_ARRAY]; // 4K
 145     // +1 to avoid recycling in Helpers.widenArray()
 146     private final int[] aux_edgePtrs_initial  = new int[INITIAL_SMALL_ARRAY + 1]; // 4K
 147 
 148 //////////////////////////////////////////////////////////////////////////////
 149 //  EDGE LIST
 150 //////////////////////////////////////////////////////////////////////////////
 151     private float edgeMinY = Float.POSITIVE_INFINITY;
 152     private float edgeMaxY = Float.NEGATIVE_INFINITY;
 153     private float edgeMinX = Float.POSITIVE_INFINITY;
 154     private float edgeMaxX = Float.NEGATIVE_INFINITY;
 155 
 156     // edges [floats|ints] stored in off-heap memory
 157     private final OffHeapArray edges;
 158 
 159     private int[] edgeBuckets;
 160     private int[] edgeBucketCounts; // 2*newedges + (1 if pruning needed)
 161     // used range for edgeBuckets / edgeBucketCounts
 162     private int buckets_minY;
 163     private int buckets_maxY;
 164     // sum of each edge delta Y (subpixels)
 165     private int edgeSumDeltaY;
 166 
 167     // +1 to avoid recycling in Helpers.widenArray()
 168     private final int[] edgeBuckets_initial
 169         = new int[INITIAL_BUCKET_ARRAY + 1]; // 64K
 170     private final int[] edgeBucketCounts_initial
 171         = new int[INITIAL_BUCKET_ARRAY + 1]; // 64K
 172 
 173     // Flattens using adaptive forward differencing. This only carries out
 174     // one iteration of the AFD loop. All it does is update AFD variables (i.e.
 175     // X0, Y0, D*[X|Y], COUNT; not variables used for computing scanline crossings).
 176     private void quadBreakIntoLinesAndAdd(float x0, float y0,
 177                                           final Curve c,
 178                                           final float x2, final float y2)
 179     {
 180         int count = 1; // dt = 1 / count
 181 
 182         // maximum(ddX|Y) = norm(dbx, dby) * dt^2 (= 1)
 183         float maxDD = FloatMath.max(Math.abs(c.dbx), Math.abs(c.dby));
 184 
 185         final float _DEC_BND = QUAD_DEC_BND;
 186 
 187         while (maxDD &gt;= _DEC_BND) {
 188             // divide step by half:
 189             maxDD /= 4f; // error divided by 2^2 = 4
 190 
 191             count &lt;&lt;= 1;
 192             if (doStats) {
 193                 RendererContext.stats.stat_rdr_quadBreak_dec.add(count);
 194             }
 195         }
 196 
 197         int nL = 0; // line count
 198         if (count &gt; 1) {
 199             final float icount = 1f / count; // dt
 200             final float icount2 = icount * icount; // dt^2
 201 
 202             final float ddx = c.dbx * icount2;
 203             final float ddy = c.dby * icount2;
 204             float dx = c.bx * icount2 + c.cx * icount;
 205             float dy = c.by * icount2 + c.cy * icount;
 206 
 207             float x1, y1;
 208 
 209             while (--count &gt; 0) {
 210                 x1 = x0 + dx;
 211                 dx += ddx;
 212                 y1 = y0 + dy;
 213                 dy += ddy;
 214 
 215                 addLine(x0, y0, x1, y1);
 216 
 217                 if (doStats) { nL++; }
 218                 x0 = x1;
 219                 y0 = y1;
 220             }
 221         }
 222         addLine(x0, y0, x2, y2);
 223 
 224         if (doStats) {
 225             RendererContext.stats.stat_rdr_quadBreak.add(nL + 1);
 226         }
 227     }
 228 
 229     // x0, y0 and x3,y3 are the endpoints of the curve. We could compute these
 230     // using c.xat(0),c.yat(0) and c.xat(1),c.yat(1), but this might introduce
 231     // numerical errors, and our callers already have the exact values.
 232     // Another alternative would be to pass all the control points, and call
 233     // c.set here, but then too many numbers are passed around.
 234     private void curveBreakIntoLinesAndAdd(float x0, float y0,
 235                                            final Curve c,
 236                                            final float x3, final float y3)
 237     {
 238         int count           = CUB_COUNT;
 239         final float icount  = CUB_INV_COUNT;   // dt
 240         final float icount2 = CUB_INV_COUNT_2; // dt^2
 241         final float icount3 = CUB_INV_COUNT_3; // dt^3
 242 
 243         // the dx and dy refer to forward differencing variables, not the last
 244         // coefficients of the "points" polynomial
 245         float dddx, dddy, ddx, ddy, dx, dy;
 246         dddx = 2f * c.dax * icount3;
 247         dddy = 2f * c.day * icount3;
 248         ddx = dddx + c.dbx * icount2;
 249         ddy = dddy + c.dby * icount2;
 250         dx = c.ax * icount3 + c.bx * icount2 + c.cx * icount;
 251         dy = c.ay * icount3 + c.by * icount2 + c.cy * icount;
 252 
 253         // we use x0, y0 to walk the line
 254         float x1 = x0, y1 = y0;
 255         int nL = 0; // line count
 256 
 257         final float _DEC_BND = CUB_DEC_BND;
 258         final float _INC_BND = CUB_INC_BND;
 259 
 260         while (count &gt; 0) {
 261             // divide step by half:
 262             while (Math.abs(ddx) &gt;= _DEC_BND || Math.abs(ddy) &gt;= _DEC_BND) {
 263                 dddx /= 8f;
 264                 dddy /= 8f;
 265                 ddx = ddx/4f - dddx;
 266                 ddy = ddy/4f - dddy;
 267                 dx = (dx - ddx) / 2f;
 268                 dy = (dy - ddy) / 2f;
 269 
 270                 count &lt;&lt;= 1;
 271                 if (doStats) {
 272                     RendererContext.stats.stat_rdr_curveBreak_dec.add(count);
 273                 }
 274             }
 275 
 276             // double step:
 277             // TODO: why use first derivative dX|Y instead of second ddX|Y ?
 278             // both scale changes should use speed or acceleration to have the same metric.
 279 
 280             // can only do this on even "count" values, because we must divide count by 2
 281             while (count % 2 == 0
 282                    &amp;&amp; Math.abs(dx) &lt;= _INC_BND &amp;&amp; Math.abs(dy) &lt;= _INC_BND)
 283             {
 284                 dx = 2f * dx + ddx;
 285                 dy = 2f * dy + ddy;
 286                 ddx = 4f * (ddx + dddx);
 287                 ddy = 4f * (ddy + dddy);
 288                 dddx *= 8f;
 289                 dddy *= 8f;
 290 
 291                 count &gt;&gt;= 1;
 292                 if (doStats) {
 293                     RendererContext.stats.stat_rdr_curveBreak_inc.add(count);
 294                 }
 295             }
 296             if (--count &gt; 0) {
 297                 x1 += dx;
 298                 dx += ddx;
 299                 ddx += dddx;
 300                 y1 += dy;
 301                 dy += ddy;
 302                 ddy += dddy;
 303             } else {
 304                 x1 = x3;
 305                 y1 = y3;
 306             }
 307 
 308             addLine(x0, y0, x1, y1);
 309 
 310             if (doStats) { nL++; }
 311             x0 = x1;
 312             y0 = y1;
 313         }
 314         if (doStats) {
 315             RendererContext.stats.stat_rdr_curveBreak.add(nL);
 316         }
 317     }
 318 
 319     private void addLine(float x1, float y1, float x2, float y2) {
 320         if (doMonitors) {
 321             RendererContext.stats.mon_rdr_addLine.start();
 322         }
 323         if (doStats) {
 324             RendererContext.stats.stat_rdr_addLine.add(1);
 325         }
 326         int or = 1; // orientation of the line. 1 if y increases, 0 otherwise.
 327         if (y2 &lt; y1) {
 328             or = 0;
 329             float tmp = y2;
 330             y2 = y1;
 331             y1 = tmp;
 332             tmp = x2;
 333             x2 = x1;
 334             x1 = tmp;
 335         }
 336 
 337         // convert subpixel coordinates (float) into pixel positions (int)
 338 
 339         // The index of the pixel that holds the next HPC is at ceil(trueY - 0.5)
 340         // Since y1 and y2 are biased by -0.5 in tosubpixy(), this is simply
 341         // ceil(y1) or ceil(y2)
 342         // upper integer (inclusive)
 343         final int firstCrossing = FloatMath.max(FloatMath.ceil_int(y1), boundsMinY);
 344 
 345         // note: use boundsMaxY (last Y exclusive) to compute correct coverage
 346         // upper integer (exclusive)
 347         final int lastCrossing  = FloatMath.min(FloatMath.ceil_int(y2), boundsMaxY);
 348 
 349         /* skip horizontal lines in pixel space and clip edges
 350            out of y range [boundsMinY; boundsMaxY] */
 351         if (firstCrossing &gt;= lastCrossing) {
 352             if (doMonitors) {
 353                 RendererContext.stats.mon_rdr_addLine.stop();
 354             }
 355             if (doStats) {
 356                 RendererContext.stats.stat_rdr_addLine_skip.add(1);
 357             }
 358             return;
 359         }
 360         // edge min/max X/Y are in subpixel space (inclusive)
 361         if (y1 &lt; edgeMinY) {
 362             edgeMinY = y1;
 363         }
 364         if (y2 &gt; edgeMaxY) {
 365             edgeMaxY = y2;
 366         }
 367 
 368         // Use double-precision for improved accuracy:
 369         final double x1d   = x1;
 370         final double y1d   = y1;
 371         final double slope = (x2 - x1d) / (y2 - y1d);
 372 
 373         if (slope &gt;= 0.0) { // &lt;==&gt; x1 &lt; x2
 374             if (x1 &lt; edgeMinX) {
 375                 edgeMinX = x1;
 376             }
 377             if (x2 &gt; edgeMaxX) {
 378                 edgeMaxX = x2;
 379             }
 380         } else {
 381             if (x2 &lt; edgeMinX) {
 382                 edgeMinX = x2;
 383             }
 384             if (x1 &gt; edgeMaxX) {
 385                 edgeMaxX = x1;
 386             }
 387         }
 388 
 389         // local variables for performance:
 390         final int _SIZEOF_EDGE_BYTES = SIZEOF_EDGE_BYTES;
 391 
 392         final OffHeapArray _edges = edges;
 393 
 394         // get free pointer (ie length in bytes)
 395         final int edgePtr = _edges.used;
 396 
 397         // use substraction to avoid integer overflow:
 398         if (_edges.length - edgePtr &lt; _SIZEOF_EDGE_BYTES) {
 399             // suppose _edges.length &gt; _SIZEOF_EDGE_BYTES
 400             // so doubling size is enough to add needed bytes
 401             // note: throw IOOB if neededSize &gt; 2Gb:
 402             final long edgeNewSize = ArrayCache.getNewLargeSize(_edges.length,
 403                                         edgePtr + _SIZEOF_EDGE_BYTES);
 404 
 405             if (doStats) {
 406                 RendererContext.stats.stat_rdr_edges_resizes.add(edgeNewSize);
 407             }
 408             _edges.resize(edgeNewSize);
 409         }
 410 
 411 
 412         final Unsafe _unsafe = OffHeapArray.unsafe;
 413         final long SIZE_INT = 4L;
 414         long addr   = _edges.address + edgePtr;
 415 
 416         // The x value must be bumped up to its position at the next HPC we will evaluate.
 417         // "firstcrossing" is the (sub)pixel number where the next crossing occurs
 418         // thus, the actual coordinate of the next HPC is "firstcrossing + 0.5"
 419         // so the Y distance we cover is "firstcrossing + 0.5 - trueY".
 420         // Note that since y1 (and y2) are already biased by -0.5 in tosubpixy(), we have
 421         // y1 = trueY - 0.5
 422         // trueY = y1 + 0.5
 423         // firstcrossing + 0.5 - trueY = firstcrossing + 0.5 - (y1 + 0.5)
 424         //                             = firstcrossing - y1
 425         // The x coordinate at that HPC is then:
 426         // x1_intercept = x1 + (firstcrossing - y1) * slope
 427         // The next VPC is then given by:
 428         // VPC index = ceil(x1_intercept - 0.5), or alternately
 429         // VPC index = floor(x1_intercept - 0.5 + 1 - epsilon)
 430         // epsilon is hard to pin down in floating point, but easy in fixed point, so if
 431         // we convert to fixed point then these operations get easier:
 432         // long x1_fixed = x1_intercept * 2^32;  (fixed point 32.32 format)
 433         // curx = next VPC = fixed_floor(x1_fixed - 2^31 + 2^32 - 1)
 434         //                 = fixed_floor(x1_fixed + 2^31 - 1)
 435         //                 = fixed_floor(x1_fixed + 0x7fffffff)
 436         // and error       = fixed_fract(x1_fixed + 0x7fffffff)
 437         final double x1_intercept = x1d + (firstCrossing - y1d) * slope;
 438 
 439         // inlined scalb(x1_intercept, 32):
 440         final long x1_fixed_biased = ((long) (POWER_2_TO_32 * x1_intercept))
 441                                      + 0x7fffffffL;
 442         // curx:
 443         // last bit corresponds to the orientation
 444         _unsafe.putInt(addr, (((int) (x1_fixed_biased &gt;&gt; 31L)) &amp; ALL_BUT_LSB) | or);
 445         addr += SIZE_INT;
 446         _unsafe.putInt(addr,  ((int)  x1_fixed_biased) &gt;&gt;&gt; 1);
 447         addr += SIZE_INT;
 448 
 449         // inlined scalb(slope, 32):
 450         final long slope_fixed = (long) (POWER_2_TO_32 * slope);
 451 
 452         // last bit set to 0 to keep orientation:
 453         _unsafe.putInt(addr, (((int) (slope_fixed &gt;&gt; 31L)) &amp; ALL_BUT_LSB));
 454         addr += SIZE_INT;
 455         _unsafe.putInt(addr,  ((int)  slope_fixed) &gt;&gt;&gt; 1);
 456         addr += SIZE_INT;
 457 
 458         final int[] _edgeBuckets      = edgeBuckets;
 459         final int[] _edgeBucketCounts = edgeBucketCounts;
 460 
 461         final int _boundsMinY = boundsMinY;
 462 
 463         // each bucket is a linked list. this method adds ptr to the
 464         // start of the "bucket"th linked list.
 465         final int bucketIdx = firstCrossing - _boundsMinY;
 466 
 467         // pointer from bucket
 468         _unsafe.putInt(addr, _edgeBuckets[bucketIdx]);
 469         addr += SIZE_INT;
 470         // y max (inclusive)
 471         _unsafe.putInt(addr,  lastCrossing);
 472 
 473         // Update buckets:
 474         // directly the edge struct "pointer"
 475         _edgeBuckets[bucketIdx]       = edgePtr;
 476         _edgeBucketCounts[bucketIdx] += 2; // 1 &lt;&lt; 1
 477         // last bit means edge end
 478         _edgeBucketCounts[lastCrossing - _boundsMinY] |= 0x1;
 479 
 480         // update sum of delta Y (subpixels):
 481         edgeSumDeltaY += (lastCrossing - firstCrossing);
 482 
 483         // update free pointer (ie length in bytes)
 484         _edges.used += _SIZEOF_EDGE_BYTES;
 485 
 486         if (doMonitors) {
 487             RendererContext.stats.mon_rdr_addLine.stop();
 488         }
 489     }
 490 
 491 // END EDGE LIST
 492 //////////////////////////////////////////////////////////////////////////////
 493 
 494     // Cache to store RLE-encoded coverage mask of the current primitive
 495     final MarlinCache cache;
 496 
 497     // Bounds of the drawing region, at subpixel precision.
 498     private int boundsMinX, boundsMinY, boundsMaxX, boundsMaxY;
 499 
 500     // Current winding rule
 501     private int windingRule;
 502 
 503     // Current drawing position, i.e., final point of last segment
 504     private float x0, y0;
 505 
 506     // Position of most recent 'moveTo' command
 507     private float pix_sx0, pix_sy0;
 508 
 509     // per-thread renderer context
 510     final RendererContext rdrCtx;
 511     // dirty curve
 512     private final Curve curve;
 513 
 514     Renderer(final RendererContext rdrCtx) {
 515         this.rdrCtx = rdrCtx;
 516 
 517         this.edges = new OffHeapArray(rdrCtx, INITIAL_EDGES_CAPACITY); // 96K
 518 
 519         this.curve = rdrCtx.curve;
 520 
 521         edgeBuckets = edgeBuckets_initial;
 522         edgeBucketCounts = edgeBucketCounts_initial;
 523 
 524         alphaLine  = alphaLine_initial;
 525 
 526         this.cache = rdrCtx.cache;
 527 
 528         // ScanLine:
 529         crossings     = crossings_initial;
 530         aux_crossings = aux_crossings_initial;
 531         edgePtrs      = edgePtrs_initial;
 532         aux_edgePtrs  = aux_edgePtrs_initial;
 533 
 534         edgeCount = 0;
 535         activeEdgeMaxUsed = 0;
 536     }
 537 
 538     Renderer init(final int pix_boundsX, final int pix_boundsY,
 539                   final int pix_boundsWidth, final int pix_boundsHeight,
 540                   final int windingRule) {
 541 
 542         this.windingRule = windingRule;
 543 
 544         // bounds as half-open intervals: minX &lt;= x &lt; maxX and minY &lt;= y &lt; maxY
 545         this.boundsMinX =  pix_boundsX &lt;&lt; SUBPIXEL_LG_POSITIONS_X;
 546         this.boundsMaxX =
 547             (pix_boundsX + pix_boundsWidth) &lt;&lt; SUBPIXEL_LG_POSITIONS_X;
 548         this.boundsMinY =  pix_boundsY &lt;&lt; SUBPIXEL_LG_POSITIONS_Y;
 549         this.boundsMaxY =
 550             (pix_boundsY + pix_boundsHeight) &lt;&lt; SUBPIXEL_LG_POSITIONS_Y;
 551 
 552         if (doLogBounds) {
 553             MarlinUtils.logInfo("boundsXY = [" + boundsMinX + " ... "
 554                                 + boundsMaxX + "[ [" + boundsMinY + " ... "
 555                                 + boundsMaxY + "[");
 556         }
 557 
 558         // see addLine: ceil(boundsMaxY) =&gt; boundsMaxY + 1
 559         // +1 for edgeBucketCounts
 560         final int edgeBucketsLength = (boundsMaxY - boundsMinY) + 1;
 561 
 562         if (edgeBucketsLength &gt; INITIAL_BUCKET_ARRAY) {
 563             if (doStats) {
 564                 RendererContext.stats.stat_array_renderer_edgeBuckets
 565                     .add(edgeBucketsLength);
 566                 RendererContext.stats.stat_array_renderer_edgeBucketCounts
 567                     .add(edgeBucketsLength);
 568             }
 569             edgeBuckets = rdrCtx.getIntArray(edgeBucketsLength);
 570             edgeBucketCounts = rdrCtx.getIntArray(edgeBucketsLength);
 571         }
 572 
 573         edgeMinY = Float.POSITIVE_INFINITY;
 574         edgeMaxY = Float.NEGATIVE_INFINITY;
 575         edgeMinX = Float.POSITIVE_INFINITY;
 576         edgeMaxX = Float.NEGATIVE_INFINITY;
 577 
 578         // reset used mark:
 579         edgeCount = 0;
 580         activeEdgeMaxUsed = 0;
 581         edges.used = 0;
 582 
 583         edgeSumDeltaY = 0;
 584 
 585         return this; // fluent API
 586     }
 587 
 588     /**
 589      * Disposes this renderer and recycle it clean up before reusing this instance
 590      */
 591     void dispose() {
 592         if (doStats) {
 593             RendererContext.stats.stat_rdr_activeEdges.add(activeEdgeMaxUsed);
 594             RendererContext.stats.stat_rdr_edges.add(edges.used);
 595             RendererContext.stats.stat_rdr_edges_count
 596                 .add(edges.used / SIZEOF_EDGE_BYTES);
 597         }
 598         if (doCleanDirty) {
 599             // Force zero-fill dirty arrays:
 600             Arrays.fill(crossings,     0);
 601             Arrays.fill(aux_crossings, 0);
 602             Arrays.fill(edgePtrs,      0);
 603             Arrays.fill(aux_edgePtrs,  0);
 604         }
 605         // Return arrays:
 606         if (crossings != crossings_initial) {
 607             rdrCtx.putDirtyIntArray(crossings);
 608             crossings = crossings_initial;
 609             if (aux_crossings != aux_crossings_initial) {
 610                 rdrCtx.putDirtyIntArray(aux_crossings);
 611                 aux_crossings = aux_crossings_initial;
 612             }
 613         }
 614         if (edgePtrs != edgePtrs_initial) {
 615             rdrCtx.putDirtyIntArray(edgePtrs);
 616             edgePtrs = edgePtrs_initial;
 617             if (aux_edgePtrs != aux_edgePtrs_initial) {
 618                 rdrCtx.putDirtyIntArray(aux_edgePtrs);
 619                 aux_edgePtrs = aux_edgePtrs_initial;
 620             }
 621         }
 622         if (alphaLine != alphaLine_initial) {
 623             rdrCtx.putIntArray(alphaLine, 0, 0); // already zero filled
 624             alphaLine = alphaLine_initial;
 625         }
 626         if (blkFlags != blkFlags_initial) {
 627             rdrCtx.putIntArray(blkFlags, 0, 0); // already zero filled
 628             blkFlags = blkFlags_initial;
 629         }
 630 
 631         if (edgeMinY != Float.POSITIVE_INFINITY) {
<a name="1" id="anc1"></a><span class="new"> 632             // if context is maked as DIRTY:</span>
<span class="new"> 633             if (rdrCtx.dirty) {</span>
<span class="new"> 634                 // may happen if an exception if thrown in the pipeline processing:</span>
<span class="new"> 635                 // clear completely buckets arrays:</span>
<span class="new"> 636                 buckets_minY = 0;</span>
<span class="new"> 637                 buckets_maxY = boundsMaxY - boundsMinY;</span>
<span class="new"> 638             }</span>
 639             // clear used part
 640             if (edgeBuckets == edgeBuckets_initial) {
 641                 // fill only used part
 642                 IntArrayCache.fill(edgeBuckets,      buckets_minY,
 643                                                      buckets_maxY,     0);
 644                 IntArrayCache.fill(edgeBucketCounts, buckets_minY,
 645                                                      buckets_maxY + 1, 0);
 646             } else {
 647                  // clear only used part
 648                 rdrCtx.putIntArray(edgeBuckets,      buckets_minY,
 649                                                      buckets_maxY);
 650                 edgeBuckets = edgeBuckets_initial;
 651 
 652                 rdrCtx.putIntArray(edgeBucketCounts, buckets_minY,
 653                                                      buckets_maxY + 1);
 654                 edgeBucketCounts = edgeBucketCounts_initial;
 655             }
 656         } else if (edgeBuckets != edgeBuckets_initial) {
 657             // unused arrays
 658             rdrCtx.putIntArray(edgeBuckets, 0, 0);
 659             edgeBuckets = edgeBuckets_initial;
 660 
 661             rdrCtx.putIntArray(edgeBucketCounts, 0, 0);
 662             edgeBucketCounts = edgeBucketCounts_initial;
 663         }
 664 
 665         // At last: resize back off-heap edges to initial size
 666         if (edges.length != INITIAL_EDGES_CAPACITY) {
 667             // note: may throw OOME:
 668             edges.resize(INITIAL_EDGES_CAPACITY);
 669         }
 670         if (doCleanDirty) {
 671             // Force zero-fill dirty arrays:
 672             edges.fill(BYTE_0);
 673         }
 674         if (doMonitors) {
 675             RendererContext.stats.mon_rdr_endRendering.stop();
 676         }
 677     }
 678 
 679     private static float tosubpixx(final float pix_x) {
 680         return f_SUBPIXEL_POSITIONS_X * pix_x;
 681     }
 682 
 683     private static float tosubpixy(final float pix_y) {
 684         // shift y by -0.5 for fast ceil(y - 0.5):
 685         return f_SUBPIXEL_POSITIONS_Y * pix_y - 0.5f;
 686     }
 687 
 688     @Override
 689     public void moveTo(float pix_x0, float pix_y0) {
 690         closePath();
 691         this.pix_sx0 = pix_x0;
 692         this.pix_sy0 = pix_y0;
 693         this.y0 = tosubpixy(pix_y0);
 694         this.x0 = tosubpixx(pix_x0);
 695     }
 696 
 697     @Override
 698     public void lineTo(float pix_x1, float pix_y1) {
 699         float x1 = tosubpixx(pix_x1);
 700         float y1 = tosubpixy(pix_y1);
 701         addLine(x0, y0, x1, y1);
 702         x0 = x1;
 703         y0 = y1;
 704     }
 705 
 706     @Override
 707     public void curveTo(float x1, float y1,
 708             float x2, float y2,
 709             float x3, float y3)
 710     {
 711         final float xe = tosubpixx(x3);
 712         final float ye = tosubpixy(y3);
 713         curve.set(x0, y0, tosubpixx(x1), tosubpixy(y1),
 714                           tosubpixx(x2), tosubpixy(y2), xe, ye);
 715         curveBreakIntoLinesAndAdd(x0, y0, curve, xe, ye);
 716         x0 = xe;
 717         y0 = ye;
 718     }
 719 
 720     @Override
 721     public void quadTo(float x1, float y1, float x2, float y2) {
 722         final float xe = tosubpixx(x2);
 723         final float ye = tosubpixy(y2);
 724         curve.set(x0, y0, tosubpixx(x1), tosubpixy(y1), xe, ye);
 725         quadBreakIntoLinesAndAdd(x0, y0, curve, xe, ye);
 726         x0 = xe;
 727         y0 = ye;
 728     }
 729 
 730     @Override
 731     public void closePath() {
 732         // lineTo expects its input in pixel coordinates.
 733         lineTo(pix_sx0, pix_sy0);
 734     }
 735 
 736     @Override
 737     public void pathDone() {
 738         closePath();
 739     }
 740 
 741     @Override
 742     public long getNativeConsumer() {
 743         throw new InternalError("Renderer does not use a native consumer.");
 744     }
 745 
 746     // clean alpha array (zero filled)
 747     private int[] alphaLine;
 748     // 2048 (pixelsize) pixel large
 749     private final int[] alphaLine_initial = new int[INITIAL_AA_ARRAY]; // 8K
 750 
 751     private void _endRendering(final int ymin, final int ymax) {
 752         if (DISABLE_RENDER) {
 753             return;
 754         }
 755 
 756         // Get X bounds as true pixel boundaries to compute correct pixel coverage:
 757         final int bboxx0 = bbox_spminX;
 758         final int bboxx1 = bbox_spmaxX;
 759 
 760         final boolean windingRuleEvenOdd = (windingRule == WIND_EVEN_ODD);
 761 
 762         // Useful when processing tile line by tile line
 763         final int[] _alpha = alphaLine;
 764 
 765         // local vars (performance):
 766         final MarlinCache _cache = cache;
 767         final OffHeapArray _edges = edges;
 768         final int[] _edgeBuckets = edgeBuckets;
 769         final int[] _edgeBucketCounts = edgeBucketCounts;
 770 
 771         int[] _crossings = this.crossings;
 772         int[] _edgePtrs  = this.edgePtrs;
 773 
 774         // merge sort auxiliary storage:
 775         int[] _aux_crossings = this.aux_crossings;
 776         int[] _aux_edgePtrs  = this.aux_edgePtrs;
 777 
 778         // copy constants:
 779         final long _OFF_ERROR    = OFF_ERROR;
 780         final long _OFF_BUMP_X   = OFF_BUMP_X;
 781         final long _OFF_BUMP_ERR = OFF_BUMP_ERR;
 782 
 783         final long _OFF_NEXT     = OFF_NEXT;
 784         final long _OFF_YMAX     = OFF_YMAX;
 785 
 786         final int _ALL_BUT_LSB   = ALL_BUT_LSB;
 787         final int _ERR_STEP_MAX  = ERR_STEP_MAX;
 788 
 789         // unsafe I/O:
 790         final Unsafe _unsafe = OffHeapArray.unsafe;
 791         final long    addr0  = _edges.address;
 792         long addr;
 793         final int _SUBPIXEL_LG_POSITIONS_X = SUBPIXEL_LG_POSITIONS_X;
 794         final int _SUBPIXEL_LG_POSITIONS_Y = SUBPIXEL_LG_POSITIONS_Y;
 795         final int _SUBPIXEL_MASK_X = SUBPIXEL_MASK_X;
 796         final int _SUBPIXEL_MASK_Y = SUBPIXEL_MASK_Y;
 797         final int _SUBPIXEL_POSITIONS_X = SUBPIXEL_POSITIONS_X;
 798 
 799         final int _MIN_VALUE = Integer.MIN_VALUE;
 800         final int _MAX_VALUE = Integer.MAX_VALUE;
 801 
 802         // Now we iterate through the scanlines. We must tell emitRow the coord
 803         // of the first non-transparent pixel, so we must keep accumulators for
 804         // the first and last pixels of the section of the current pixel row
 805         // that we will emit.
 806         // We also need to accumulate pix_bbox, but the iterator does it
 807         // for us. We will just get the values from it once this loop is done
 808         int minX = _MAX_VALUE;
 809         int maxX = _MIN_VALUE;
 810 
 811         int y = ymin;
 812         int bucket = y - boundsMinY;
 813 
 814         int numCrossings = this.edgeCount;
 815         int edgePtrsLen = _edgePtrs.length;
 816         int crossingsLen = _crossings.length;
 817         int _arrayMaxUsed = activeEdgeMaxUsed;
 818         int ptrLen = 0, newCount, ptrEnd;
 819 
 820         int bucketcount, i, j, ecur;
 821         int cross, lastCross;
 822         int x0, x1, tmp, sum, prev, curx, curxo, crorientation, err;
 823         int pix_x, pix_xmaxm1, pix_xmax;
 824 
 825         int low, high, mid, prevNumCrossings;
 826         boolean useBinarySearch;
 827 
 828         final int[] _blkFlags = blkFlags;
 829         final int _BLK_SIZE_LG = BLOCK_SIZE_LG;
 830         final int _BLK_SIZE = BLOCK_SIZE;
 831 
 832         final boolean _enableBlkFlagsHeuristics = ENABLE_BLOCK_FLAGS_HEURISTICS &amp;&amp; this.enableBlkFlags;
 833 
 834         // Use block flags if large pixel span and few crossings:
 835         // ie mean(distance between crossings) is high
 836         boolean useBlkFlags = this.prevUseBlkFlags;
 837 
 838         final int stroking = rdrCtx.stroking;
 839 
 840         int lastY = -1; // last emited row
 841 
 842 
 843         // Iteration on scanlines
 844         for (; y &lt; ymax; y++, bucket++) {
 845             // --- from former ScanLineIterator.next()
 846             bucketcount = _edgeBucketCounts[bucket];
 847 
 848             // marker on previously sorted edges:
 849             prevNumCrossings = numCrossings;
 850 
 851             // bucketCount indicates new edge / edge end:
 852             if (bucketcount != 0) {
 853                 if (doStats) {
 854                     RendererContext.stats.stat_rdr_activeEdges_updates
 855                         .add(numCrossings);
 856                 }
 857 
 858                 // last bit set to 1 means that edges ends
 859                 if ((bucketcount &amp; 0x1) != 0) {
 860                     // eviction in active edge list
 861                     // cache edges[] address + offset
 862                     addr = addr0 + _OFF_YMAX;
 863 
 864                     for (i = 0, newCount = 0; i &lt; numCrossings; i++) {
 865                         // get the pointer to the edge
 866                         ecur = _edgePtrs[i];
 867                         // random access so use unsafe:
 868                         if (_unsafe.getInt(addr + ecur) &gt; y) {
 869                             _edgePtrs[newCount++] = ecur;
 870                         }
 871                     }
 872                     // update marker on sorted edges minus removed edges:
 873                     prevNumCrossings = numCrossings = newCount;
 874                 }
 875 
 876                 ptrLen = bucketcount &gt;&gt; 1; // number of new edge
 877 
 878                 if (ptrLen != 0) {
 879                     if (doStats) {
 880                         RendererContext.stats.stat_rdr_activeEdges_adds
 881                             .add(ptrLen);
 882                         if (ptrLen &gt; 10) {
 883                             RendererContext.stats.stat_rdr_activeEdges_adds_high
 884                                 .add(ptrLen);
 885                         }
 886                     }
 887                     ptrEnd = numCrossings + ptrLen;
 888 
 889                     if (edgePtrsLen &lt; ptrEnd) {
 890                         if (doStats) {
 891                             RendererContext.stats.stat_array_renderer_edgePtrs
 892                                 .add(ptrEnd);
 893                         }
 894                         this.edgePtrs = _edgePtrs
 895                             = rdrCtx.widenDirtyIntArray(_edgePtrs, numCrossings,
 896                                                         ptrEnd);
 897 
 898                         edgePtrsLen = _edgePtrs.length;
 899                         // Get larger auxiliary storage:
 900                         if (_aux_edgePtrs != aux_edgePtrs_initial) {
 901                             rdrCtx.putDirtyIntArray(_aux_edgePtrs);
 902                         }
 903                         // use ArrayCache.getNewSize() to use the same growing
 904                         // factor than widenDirtyIntArray():
 905                         if (doStats) {
 906                             RendererContext.stats.stat_array_renderer_aux_edgePtrs
 907                                 .add(ptrEnd);
 908                         }
 909                         this.aux_edgePtrs = _aux_edgePtrs
 910                             = rdrCtx.getDirtyIntArray(
 911                                 ArrayCache.getNewSize(numCrossings, ptrEnd)
 912                             );
 913                     }
 914 
 915                     // cache edges[] address + offset
 916                     addr = addr0 + _OFF_NEXT;
 917 
 918                     // add new edges to active edge list:
 919                     for (ecur = _edgeBuckets[bucket];
 920                          numCrossings &lt; ptrEnd; numCrossings++)
 921                     {
 922                         // store the pointer to the edge
 923                         _edgePtrs[numCrossings] = ecur;
 924                         // random access so use unsafe:
 925                         ecur = _unsafe.getInt(addr + ecur);
 926                     }
 927 
 928                     if (crossingsLen &lt; numCrossings) {
 929                         // Get larger array:
 930                         if (_crossings != crossings_initial) {
 931                             rdrCtx.putDirtyIntArray(_crossings);
 932                         }
 933                         if (doStats) {
 934                             RendererContext.stats.stat_array_renderer_crossings
 935                                 .add(numCrossings);
 936                         }
 937                         this.crossings = _crossings
 938                             = rdrCtx.getDirtyIntArray(numCrossings);
 939 
 940                         // Get larger auxiliary storage:
 941                         if (_aux_crossings != aux_crossings_initial) {
 942                             rdrCtx.putDirtyIntArray(_aux_crossings);
 943                         }
 944                         if (doStats) {
 945                             RendererContext.stats.stat_array_renderer_aux_crossings
 946                                 .add(numCrossings);
 947                         }
 948                         this.aux_crossings = _aux_crossings
 949                             = rdrCtx.getDirtyIntArray(numCrossings);
 950 
 951                         crossingsLen = _crossings.length;
 952                     }
 953                     if (doStats) {
 954                         // update max used mark
 955                         if (numCrossings &gt; _arrayMaxUsed) {
 956                             _arrayMaxUsed = numCrossings;
 957                         }
 958                     }
 959                 } // ptrLen != 0
 960             } // bucketCount != 0
 961 
 962 
 963             if (numCrossings != 0) {
 964                 /*
 965                  * thresholds to switch to optimized merge sort
 966                  * for newly added edges + final merge pass.
 967                  */
 968                 if ((ptrLen &lt; 10) || (numCrossings &lt; 40)) {
 969                     if (doStats) {
 970                         RendererContext.stats.hist_rdr_crossings
 971                             .add(numCrossings);
 972                         RendererContext.stats.hist_rdr_crossings_adds
 973                             .add(ptrLen);
 974                     }
 975 
 976                     /*
 977                      * threshold to use binary insertion sort instead of
 978                      * straight insertion sort (to reduce minimize comparisons).
 979                      */
 980                     useBinarySearch = (numCrossings &gt;= 20);
 981 
 982                     // if small enough:
 983                     lastCross = _MIN_VALUE;
 984 
 985                     for (i = 0; i &lt; numCrossings; i++) {
 986                         // get the pointer to the edge
 987                         ecur = _edgePtrs[i];
 988 
 989                         /* convert subpixel coordinates (float) into pixel
 990                             positions (int) for coming scanline */
 991                         /* note: it is faster to always update edges even
 992                            if it is removed from AEL for coming or last scanline */
 993 
 994                         // random access so use unsafe:
 995                         addr = addr0 + ecur; // ecur + OFF_F_CURX
 996 
 997                         // get current crossing:
 998                         curx = _unsafe.getInt(addr);
 999 
1000                         // update crossing with orientation at last bit:
1001                         cross = curx;
1002 
1003                         // Increment x using DDA (fixed point):
1004                         curx += _unsafe.getInt(addr + _OFF_BUMP_X);
1005 
1006                         // Increment error:
1007                         err  =  _unsafe.getInt(addr + _OFF_ERROR)
1008                               + _unsafe.getInt(addr + _OFF_BUMP_ERR);
1009 
1010                         // Manual carry handling:
1011                         // keep sign and carry bit only and ignore last bit (preserve orientation):
1012                         _unsafe.putInt(addr,               curx - ((err &gt;&gt; 30) &amp; _ALL_BUT_LSB));
1013                         _unsafe.putInt(addr + _OFF_ERROR, (err &amp; _ERR_STEP_MAX));
1014 
1015                         if (doStats) {
1016                             RendererContext.stats.stat_rdr_crossings_updates
1017                                 .add(numCrossings);
1018                         }
1019 
1020                         // insertion sort of crossings:
1021                         if (cross &lt; lastCross) {
1022                             if (doStats) {
1023                                 RendererContext.stats.stat_rdr_crossings_sorts
1024                                     .add(i);
1025                             }
1026 
1027                             /* use binary search for newly added edges
1028                                in crossings if arrays are large enough */
1029                             if (useBinarySearch &amp;&amp; (i &gt;= prevNumCrossings)) {
1030                                 if (doStats) {
1031                                     RendererContext.stats.
1032                                         stat_rdr_crossings_bsearch.add(i);
1033                                 }
1034                                 low = 0;
1035                                 high = i - 1;
1036 
1037                                 do {
1038                                     // note: use signed shift (not &gt;&gt;&gt;) for performance
1039                                     // as indices are small enough to exceed Integer.MAX_VALUE
1040                                     mid = (low + high) &gt;&gt; 1;
1041 
1042                                     if (_crossings[mid] &lt; cross) {
1043                                         low = mid + 1;
1044                                     } else {
1045                                         high = mid - 1;
1046                                     }
1047                                 } while (low &lt;= high);
1048 
1049                                 for (j = i - 1; j &gt;= low; j--) {
1050                                     _crossings[j + 1] = _crossings[j];
1051                                     _edgePtrs [j + 1] = _edgePtrs[j];
1052                                 }
1053                                 _crossings[low] = cross;
1054                                 _edgePtrs [low] = ecur;
1055 
1056                             } else {
1057                                 j = i - 1;
1058                                 _crossings[i] = _crossings[j];
1059                                 _edgePtrs[i] = _edgePtrs[j];
1060 
1061                                 while ((--j &gt;= 0) &amp;&amp; (_crossings[j] &gt; cross)) {
1062                                     _crossings[j + 1] = _crossings[j];
1063                                     _edgePtrs [j + 1] = _edgePtrs[j];
1064                                 }
1065                                 _crossings[j + 1] = cross;
1066                                 _edgePtrs [j + 1] = ecur;
1067                             }
1068 
1069                         } else {
1070                             _crossings[i] = lastCross = cross;
1071                         }
1072                     }
1073                 } else {
1074                     if (doStats) {
1075                         RendererContext.stats.stat_rdr_crossings_msorts
1076                             .add(numCrossings);
1077                         RendererContext.stats.hist_rdr_crossings_ratio
1078                             .add((1000 * ptrLen) / numCrossings);
1079                         RendererContext.stats.hist_rdr_crossings_msorts
1080                             .add(numCrossings);
1081                         RendererContext.stats.hist_rdr_crossings_msorts_adds
1082                             .add(ptrLen);
1083                     }
1084 
1085                     // Copy sorted data in auxiliary arrays
1086                     // and perform insertion sort on almost sorted data
1087                     // (ie i &lt; prevNumCrossings):
1088 
1089                     lastCross = _MIN_VALUE;
1090 
1091                     for (i = 0; i &lt; numCrossings; i++) {
1092                         // get the pointer to the edge
1093                         ecur = _edgePtrs[i];
1094 
1095                         /* convert subpixel coordinates (float) into pixel
1096                             positions (int) for coming scanline */
1097                         /* note: it is faster to always update edges even
1098                            if it is removed from AEL for coming or last scanline */
1099 
1100                         // random access so use unsafe:
1101                         addr = addr0 + ecur; // ecur + OFF_F_CURX
1102 
1103                         // get current crossing:
1104                         curx = _unsafe.getInt(addr);
1105 
1106                         // update crossing with orientation at last bit:
1107                         cross = curx;
1108 
1109                         // Increment x using DDA (fixed point):
1110                         curx += _unsafe.getInt(addr + _OFF_BUMP_X);
1111 
1112                         // Increment error:
1113                         err  =  _unsafe.getInt(addr + _OFF_ERROR)
1114                               + _unsafe.getInt(addr + _OFF_BUMP_ERR);
1115 
1116                         // Manual carry handling:
1117                         // keep sign and carry bit only and ignore last bit (preserve orientation):
1118                         _unsafe.putInt(addr,               curx - ((err &gt;&gt; 30) &amp; _ALL_BUT_LSB));
1119                         _unsafe.putInt(addr + _OFF_ERROR, (err &amp; _ERR_STEP_MAX));
1120 
1121                         if (doStats) {
1122                             RendererContext.stats.stat_rdr_crossings_updates
1123                                 .add(numCrossings);
1124                         }
1125 
1126                         if (i &gt;= prevNumCrossings) {
1127                             // simply store crossing as edgePtrs is in-place:
1128                             // will be copied and sorted efficiently by mergesort later:
1129                             _crossings[i]     = cross;
1130 
1131                         } else if (cross &lt; lastCross) {
1132                             if (doStats) {
1133                                 RendererContext.stats.stat_rdr_crossings_sorts
1134                                     .add(i);
1135                             }
1136 
1137                             // (straight) insertion sort of crossings:
1138                             j = i - 1;
1139                             _aux_crossings[i] = _aux_crossings[j];
1140                             _aux_edgePtrs[i] = _aux_edgePtrs[j];
1141 
1142                             while ((--j &gt;= 0) &amp;&amp; (_aux_crossings[j] &gt; cross)) {
1143                                 _aux_crossings[j + 1] = _aux_crossings[j];
1144                                 _aux_edgePtrs [j + 1] = _aux_edgePtrs[j];
1145                             }
1146                             _aux_crossings[j + 1] = cross;
1147                             _aux_edgePtrs [j + 1] = ecur;
1148 
1149                         } else {
1150                             // auxiliary storage:
1151                             _aux_crossings[i] = lastCross = cross;
1152                             _aux_edgePtrs [i] = ecur;
1153                         }
1154                     }
1155 
1156                     // use Mergesort using auxiliary arrays (sort only right part)
1157                     MergeSort.mergeSortNoCopy(_crossings,     _edgePtrs,
1158                                               _aux_crossings, _aux_edgePtrs,
1159                                               numCrossings,   prevNumCrossings);
1160                 }
1161 
1162                 // reset ptrLen
1163                 ptrLen = 0;
1164                 // --- from former ScanLineIterator.next()
1165 
1166 
1167                 /* note: bboxx0 and bboxx1 must be pixel boundaries
1168                    to have correct coverage computation */
1169 
1170                 // right shift on crossings to get the x-coordinate:
1171                 curxo = _crossings[0];
1172                 x0    = curxo &gt;&gt; 1;
1173                 if (x0 &lt; minX) {
1174                     minX = x0; // subpixel coordinate
1175                 }
1176 
1177                 x1 = _crossings[numCrossings - 1] &gt;&gt; 1;
1178                 if (x1 &gt; maxX) {
1179                     maxX = x1; // subpixel coordinate
1180                 }
1181 
1182 
1183                 // compute pixel coverages
1184                 prev = curx = x0;
1185                 // to turn {0, 1} into {-1, 1}, multiply by 2 and subtract 1.
1186                 // last bit contains orientation (0 or 1)
1187                 crorientation = ((curxo &amp; 0x1) &lt;&lt; 1) - 1;
1188 
1189                 if (windingRuleEvenOdd) {
1190                     sum = crorientation;
1191 
1192                     // Even Odd winding rule: take care of mask ie sum(orientations)
1193                     for (i = 1; i &lt; numCrossings; i++) {
1194                         curxo = _crossings[i];
1195                         curx  =  curxo &gt;&gt; 1;
1196                         // to turn {0, 1} into {-1, 1}, multiply by 2 and subtract 1.
1197                         // last bit contains orientation (0 or 1)
1198                         crorientation = ((curxo &amp; 0x1) &lt;&lt; 1) - 1;
1199 
1200                         if ((sum &amp; 0x1) != 0) {
1201                             // TODO: perform line clipping on left-right sides
1202                             // to avoid such bound checks:
1203                             x0 = (prev &gt; bboxx0) ? prev : bboxx0;
1204                             x1 = (curx &lt; bboxx1) ? curx : bboxx1;
1205 
1206                             if (x0 &lt; x1) {
1207                                 x0 -= bboxx0; // turn x0, x1 from coords to indices
1208                                 x1 -= bboxx0; // in the alpha array.
1209 
1210                                 pix_x      =  x0      &gt;&gt; _SUBPIXEL_LG_POSITIONS_X;
1211                                 pix_xmaxm1 = (x1 - 1) &gt;&gt; _SUBPIXEL_LG_POSITIONS_X;
1212 
1213                                 if (pix_x == pix_xmaxm1) {
1214                                     // Start and end in same pixel
1215                                     tmp = (x1 - x0); // number of subpixels
1216                                     _alpha[pix_x    ] += tmp;
1217                                     _alpha[pix_x + 1] -= tmp;
1218 
1219                                     if (useBlkFlags) {
1220                                         // flag used blocks:
1221                                         _blkFlags[pix_x &gt;&gt; _BLK_SIZE_LG] = 1;
1222                                     }
1223                                 } else {
1224                                     tmp = (x0 &amp; _SUBPIXEL_MASK_X);
1225                                     _alpha[pix_x    ]
1226                                         += (_SUBPIXEL_POSITIONS_X - tmp);
1227                                     _alpha[pix_x + 1]
1228                                         += tmp;
1229 
1230                                     pix_xmax = x1 &gt;&gt; _SUBPIXEL_LG_POSITIONS_X;
1231 
1232                                     tmp = (x1 &amp; _SUBPIXEL_MASK_X);
1233                                     _alpha[pix_xmax    ]
1234                                         -= (_SUBPIXEL_POSITIONS_X - tmp);
1235                                     _alpha[pix_xmax + 1]
1236                                         -= tmp;
1237 
1238                                     if (useBlkFlags) {
1239                                         // flag used blocks:
1240                                         _blkFlags[pix_x    &gt;&gt; _BLK_SIZE_LG] = 1;
1241                                         _blkFlags[pix_xmax &gt;&gt; _BLK_SIZE_LG] = 1;
1242                                     }
1243                                 }
1244                             }
1245                         }
1246 
1247                         sum += crorientation;
1248                         prev = curx;
1249                     }
1250                 } else {
1251                     // Non-zero winding rule: optimize that case (default)
1252                     // and avoid processing intermediate crossings
1253                     for (i = 1, sum = 0;; i++) {
1254                         sum += crorientation;
1255 
1256                         if (sum != 0) {
1257                             // prev = min(curx)
1258                             if (prev &gt; curx) {
1259                                 prev = curx;
1260                             }
1261                         } else {
1262                             // TODO: perform line clipping on left-right sides
1263                             // to avoid such bound checks:
1264                             x0 = (prev &gt; bboxx0) ? prev : bboxx0;
1265                             x1 = (curx &lt; bboxx1) ? curx : bboxx1;
1266 
1267                             if (x0 &lt; x1) {
1268                                 x0 -= bboxx0; // turn x0, x1 from coords to indices
1269                                 x1 -= bboxx0; // in the alpha array.
1270 
1271                                 pix_x      =  x0      &gt;&gt; _SUBPIXEL_LG_POSITIONS_X;
1272                                 pix_xmaxm1 = (x1 - 1) &gt;&gt; _SUBPIXEL_LG_POSITIONS_X;
1273 
1274                                 if (pix_x == pix_xmaxm1) {
1275                                     // Start and end in same pixel
1276                                     tmp = (x1 - x0); // number of subpixels
1277                                     _alpha[pix_x    ] += tmp;
1278                                     _alpha[pix_x + 1] -= tmp;
1279 
1280                                     if (useBlkFlags) {
1281                                         // flag used blocks:
1282                                         _blkFlags[pix_x &gt;&gt; _BLK_SIZE_LG] = 1;
1283                                     }
1284                                 } else {
1285                                     tmp = (x0 &amp; _SUBPIXEL_MASK_X);
1286                                     _alpha[pix_x    ]
1287                                         += (_SUBPIXEL_POSITIONS_X - tmp);
1288                                     _alpha[pix_x + 1]
1289                                         += tmp;
1290 
1291                                     pix_xmax = x1 &gt;&gt; _SUBPIXEL_LG_POSITIONS_X;
1292 
1293                                     tmp = (x1 &amp; _SUBPIXEL_MASK_X);
1294                                     _alpha[pix_xmax    ]
1295                                         -= (_SUBPIXEL_POSITIONS_X - tmp);
1296                                     _alpha[pix_xmax + 1]
1297                                         -= tmp;
1298 
1299                                     if (useBlkFlags) {
1300                                         // flag used blocks:
1301                                         _blkFlags[pix_x    &gt;&gt; _BLK_SIZE_LG] = 1;
1302                                         _blkFlags[pix_xmax &gt;&gt; _BLK_SIZE_LG] = 1;
1303                                     }
1304                                 }
1305                             }
1306                             prev = _MAX_VALUE;
1307                         }
1308 
1309                         if (i == numCrossings) {
1310                             break;
1311                         }
1312 
1313                         curxo = _crossings[i];
1314                         curx  =  curxo &gt;&gt; 1;
1315                         // to turn {0, 1} into {-1, 1}, multiply by 2 and subtract 1.
1316                         // last bit contains orientation (0 or 1)
1317                         crorientation = ((curxo &amp; 0x1) &lt;&lt; 1) - 1;
1318                     }
1319                 }
1320             } // numCrossings &gt; 0
1321 
1322             // even if this last row had no crossings, alpha will be zeroed
1323             // from the last emitRow call. But this doesn't matter because
1324             // maxX &lt; minX, so no row will be emitted to the MarlinCache.
1325             if ((y &amp; _SUBPIXEL_MASK_Y) == _SUBPIXEL_MASK_Y) {
1326                 lastY = y &gt;&gt; _SUBPIXEL_LG_POSITIONS_Y;
1327 
1328                 // convert subpixel to pixel coordinate within boundaries:
1329                 minX = FloatMath.max(minX, bboxx0) &gt;&gt; _SUBPIXEL_LG_POSITIONS_X;
1330                 maxX = FloatMath.min(maxX, bboxx1) &gt;&gt; _SUBPIXEL_LG_POSITIONS_X;
1331 
1332                 if (maxX &gt;= minX) {
1333                     // note: alpha array will be zeroed by copyAARow()
1334                     // +2 because alpha [pix_minX; pix_maxX+1]
1335                     // fix range [x0; x1[
1336                     copyAARow(_alpha, lastY, minX, maxX + 2, useBlkFlags);
1337 
1338                     // speculative for next pixel row (scanline coherence):
1339                     if (_enableBlkFlagsHeuristics) {
1340                         // Use block flags if large pixel span and few crossings:
1341                         // ie mean(distance between crossings) is larger than
1342                         // 1 block size;
1343 
1344                         // fast check width:
1345                         maxX -= minX;
1346 
1347                         // if stroking: numCrossings /= 2
1348                         // =&gt; shift numCrossings by 1
1349                         // condition = (width / (numCrossings - 1)) &gt; blockSize
1350                         useBlkFlags = (maxX &gt; _BLK_SIZE) &amp;&amp; (maxX &gt;
1351                             (((numCrossings &gt;&gt; stroking) - 1) &lt;&lt; _BLK_SIZE_LG));
1352 
1353                         if (doStats) {
1354                             tmp = FloatMath.max(1,
1355                                     ((numCrossings &gt;&gt; stroking) - 1));
1356                             RendererContext.stats.hist_tile_generator_encoding_dist
1357                                 .add(maxX / tmp);
1358                         }
1359                     }
1360                 } else {
1361                     _cache.clearAARow(lastY);
1362                 }
1363                 minX = _MAX_VALUE;
1364                 maxX = _MIN_VALUE;
1365             }
1366         } // scan line iterator
1367 
1368         // Emit final row
1369         y--;
1370         y &gt;&gt;= _SUBPIXEL_LG_POSITIONS_Y;
1371 
1372         // convert subpixel to pixel coordinate within boundaries:
1373         minX = FloatMath.max(minX, bboxx0) &gt;&gt; _SUBPIXEL_LG_POSITIONS_X;
1374         maxX = FloatMath.min(maxX, bboxx1) &gt;&gt; _SUBPIXEL_LG_POSITIONS_X;
1375 
1376         if (maxX &gt;= minX) {
1377             // note: alpha array will be zeroed by copyAARow()
1378             // +2 because alpha [pix_minX; pix_maxX+1]
1379             // fix range [x0; x1[
1380             copyAARow(_alpha, y, minX, maxX + 2, useBlkFlags);
1381         } else if (y != lastY) {
1382             _cache.clearAARow(y);
1383         }
1384 
1385         // update member:
1386         edgeCount = numCrossings;
1387         prevUseBlkFlags = useBlkFlags;
1388 
1389         if (doStats) {
1390             // update max used mark
1391             activeEdgeMaxUsed = _arrayMaxUsed;
1392         }
1393     }
1394 
1395     boolean endRendering() {
1396         if (doMonitors) {
1397             RendererContext.stats.mon_rdr_endRendering.start();
1398         }
1399         if (edgeMinY == Float.POSITIVE_INFINITY) {
1400             return false; // undefined edges bounds
1401         }
1402 
1403         final int _boundsMinY = boundsMinY;
1404         final int _boundsMaxY = boundsMaxY;
1405 
1406         // bounds as inclusive intervals
1407         final int spminX = FloatMath.max(FloatMath.ceil_int(edgeMinX - 0.5f), boundsMinX);
1408         final int spmaxX = FloatMath.min(FloatMath.ceil_int(edgeMaxX - 0.5f), boundsMaxX - 1);
1409 
1410         // y1 (and y2) are already biased by -0.5 in tosubpixy():
1411         final int spminY = FloatMath.max(FloatMath.ceil_int(edgeMinY), _boundsMinY);
1412         int maxY = FloatMath.ceil_int(edgeMaxY);
1413 
1414         final int spmaxY;
1415 
1416         if (maxY &lt;= _boundsMaxY - 1) {
1417             spmaxY = maxY;
1418         } else {
1419             spmaxY = _boundsMaxY - 1;
1420             maxY   = _boundsMaxY;
1421         }
1422         buckets_minY = spminY - _boundsMinY;
1423         buckets_maxY = maxY   - _boundsMinY;
1424 
1425         if (doLogBounds) {
1426             MarlinUtils.logInfo("edgesXY = [" + edgeMinX + " ... " + edgeMaxX
1427                                 + "][" + edgeMinY + " ... " + edgeMaxY + "]");
1428             MarlinUtils.logInfo("spXY    = [" + spminX + " ... " + spmaxX
1429                                 + "][" + spminY + " ... " + spmaxY + "]");
1430         }
1431 
1432         // test clipping for shapes out of bounds
1433         if ((spminX &gt; spmaxX) || (spminY &gt; spmaxY)) {
1434             return false;
1435         }
1436 
1437         // half open intervals
1438         // inclusive:
1439         final int pminX =  spminX                    &gt;&gt; SUBPIXEL_LG_POSITIONS_X;
1440         // exclusive:
1441         final int pmaxX = (spmaxX + SUBPIXEL_MASK_X) &gt;&gt; SUBPIXEL_LG_POSITIONS_X;
1442         // inclusive:
1443         final int pminY =  spminY                    &gt;&gt; SUBPIXEL_LG_POSITIONS_Y;
1444         // exclusive:
1445         final int pmaxY = (spmaxY + SUBPIXEL_MASK_Y) &gt;&gt; SUBPIXEL_LG_POSITIONS_Y;
1446 
1447         // store BBox to answer ptg.getBBox():
1448         this.cache.init(pminX, pminY, pmaxX, pmaxY, edgeSumDeltaY);
1449 
1450         // Heuristics for using block flags:
1451         if (ENABLE_BLOCK_FLAGS) {
1452             enableBlkFlags = this.cache.useRLE;
1453             prevUseBlkFlags = enableBlkFlags &amp;&amp; !ENABLE_BLOCK_FLAGS_HEURISTICS;
1454 
1455             if (enableBlkFlags) {
1456                 // ensure blockFlags array is large enough:
1457                 // note: +2 to ensure enough space left at end
1458                 final int nxTiles = ((pmaxX - pminX) &gt;&gt; TILE_SIZE_LG) + 2;
1459                 if (nxTiles &gt; INITIAL_ARRAY) {
1460                     blkFlags = rdrCtx.getIntArray(nxTiles);
1461                 }
1462             }
1463         }
1464 
1465         // memorize the rendering bounding box:
1466         /* note: bbox_spminX and bbox_spmaxX must be pixel boundaries
1467            to have correct coverage computation */
1468         // inclusive:
1469         bbox_spminX = pminX &lt;&lt; SUBPIXEL_LG_POSITIONS_X;
1470         // exclusive:
1471         bbox_spmaxX = pmaxX &lt;&lt; SUBPIXEL_LG_POSITIONS_X;
1472         // inclusive:
1473         bbox_spminY = spminY;
1474         // exclusive:
1475         bbox_spmaxY = FloatMath.min(spmaxY + 1, pmaxY &lt;&lt; SUBPIXEL_LG_POSITIONS_Y);
1476 
1477         if (doLogBounds) {
1478             MarlinUtils.logInfo("pXY       = [" + pminX + " ... " + pmaxX
1479                                 + "[ [" + pminY + " ... " + pmaxY + "[");
1480             MarlinUtils.logInfo("bbox_spXY = [" + bbox_spminX + " ... "
1481                                 + bbox_spmaxX + "[ [" + bbox_spminY + " ... "
1482                                 + bbox_spmaxY + "[");
1483         }
1484 
1485         // Prepare alpha line:
1486         // add 2 to better deal with the last pixel in a pixel row.
1487         final int width = (pmaxX - pminX) + 2;
1488 
1489         // Useful when processing tile line by tile line
1490         if (width &gt; INITIAL_AA_ARRAY) {
1491             if (doStats) {
1492                 RendererContext.stats.stat_array_renderer_alphaline
1493                     .add(width);
1494             }
1495             alphaLine = rdrCtx.getIntArray(width);
1496         }
1497 
1498         // process first tile line:
1499         endRendering(pminY);
1500 
1501         return true;
1502     }
1503 
1504     private int bbox_spminX, bbox_spmaxX, bbox_spminY, bbox_spmaxY;
1505 
1506     void endRendering(final int pminY) {
1507         if (doMonitors) {
1508             RendererContext.stats.mon_rdr_endRendering_Y.start();
1509         }
1510 
1511         final int spminY       = pminY &lt;&lt; SUBPIXEL_LG_POSITIONS_Y;
1512         final int fixed_spminY = FloatMath.max(bbox_spminY, spminY);
1513 
1514         // avoid rendering for last call to nextTile()
1515         if (fixed_spminY &lt; bbox_spmaxY) {
1516             // process a complete tile line ie scanlines for 32 rows
1517             final int spmaxY = FloatMath.min(bbox_spmaxY, spminY + SUBPIXEL_TILE);
1518 
1519             // process tile line [0 - 32]
1520             cache.resetTileLine(pminY);
1521 
1522             // Process only one tile line:
1523             _endRendering(fixed_spminY, spmaxY);
1524         }
1525         if (doMonitors) {
1526             RendererContext.stats.mon_rdr_endRendering_Y.stop();
1527         }
1528     }
1529 
1530     private boolean enableBlkFlags = false;
1531     private boolean prevUseBlkFlags = false;
1532 
1533     private final int[] blkFlags_initial = new int[INITIAL_ARRAY]; // 1 tile line
1534     /* block flags (0|1) */
1535     private int[] blkFlags = blkFlags_initial;
1536 
1537     void copyAARow(final int[] alphaRow,
1538                    final int pix_y, final int pix_from, final int pix_to,
1539                    final boolean useBlockFlags)
1540     {
1541         if (useBlockFlags) {
1542             if (doStats) {
1543                 RendererContext.stats.hist_tile_generator_encoding.add(1);
1544             }
1545             cache.copyAARowRLE_WithBlockFlags(blkFlags, alphaRow, pix_y, pix_from, pix_to);
1546         } else {
1547             if (doStats) {
1548                 RendererContext.stats.hist_tile_generator_encoding.add(0);
1549             }
1550             cache.copyAARowNoRLE(alphaRow, pix_y, pix_from, pix_to);
1551         }
1552     }
1553 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="2" type="hidden" /></form></body></html>
