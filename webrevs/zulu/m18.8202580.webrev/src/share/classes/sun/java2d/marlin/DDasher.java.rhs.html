<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-13697">13697</a> : <a href="https://bugs.openjdk.java.net/browse/JDK-8202580">8202580</a>: Dashed BasicStroke randomly painted incorrectly, may freeze application
Summary: fixed Dasher.init() to use the correct part [0; dashLen[
Reviewed-by: prr, serb</pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the "Classpath" exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.java2d.marlin;
  27 
  28 import java.util.Arrays;
  29 import sun.java2d.marlin.DTransformingPathConsumer2D.CurveBasicMonotonizer;
  30 import sun.java2d.marlin.DTransformingPathConsumer2D.CurveClipSplitter;
  31 
  32 /**
  33  * The &lt;code&gt;DDasher&lt;/code&gt; class takes a series of linear commands
  34  * (&lt;code&gt;moveTo&lt;/code&gt;, &lt;code&gt;lineTo&lt;/code&gt;, &lt;code&gt;close&lt;/code&gt; and
  35  * &lt;code&gt;end&lt;/code&gt;) and breaks them into smaller segments according to a
  36  * dash pattern array and a starting dash phase.
  37  *
  38  * &lt;p&gt; Issues: in J2Se, a zero length dash segment as drawn as a very
  39  * short dash, whereas Pisces does not draw anything.  The PostScript
  40  * semantics are unclear.
  41  *
  42  */
  43 final class DDasher implements DPathConsumer2D, MarlinConst {
  44 
  45     /* huge circle with radius ~ 2E9 only needs 12 subdivision levels */
  46     static final int REC_LIMIT = 16;
  47     static final double CURVE_LEN_ERR = MarlinProperties.getCurveLengthError(); // 0.01 initial
  48     static final double MIN_T_INC = 1.0d / (1 &lt;&lt; REC_LIMIT);
  49 
  50     // More than 24 bits of mantissa means we can no longer accurately
  51     // measure the number of times cycled through the dash array so we
  52     // punt and override the phase to just be 0 past that point.
  53     static final double MAX_CYCLES = 16000000.0d;
  54 
  55     private DPathConsumer2D out;
  56     private double[] dash;
  57     private int dashLen;
  58     private double startPhase;
  59     private boolean startDashOn;
  60     private int startIdx;
  61 
  62     private boolean starting;
  63     private boolean needsMoveTo;
  64 
  65     private int idx;
  66     private boolean dashOn;
  67     private double phase;
  68 
  69     // The starting point of the path
  70     private double sx0, sy0;
  71     // the current point
  72     private double cx0, cy0;
  73 
  74     // temporary storage for the current curve
  75     private final double[] curCurvepts;
  76 
  77     // per-thread renderer context
  78     final DRendererContext rdrCtx;
  79 
  80     // flag to recycle dash array copy
  81     boolean recycleDashes;
  82 
  83     // We don't emit the first dash right away. If we did, caps would be
  84     // drawn on it, but we need joins to be drawn if there's a closePath()
  85     // So, we store the path elements that make up the first dash in the
  86     // buffer below.
  87     private double[] firstSegmentsBuffer; // dynamic array
  88     private int firstSegidx;
  89 
  90     // dashes ref (dirty)
  91     final DoubleArrayCache.Reference dashes_ref;
  92     // firstSegmentsBuffer ref (dirty)
  93     final DoubleArrayCache.Reference firstSegmentsBuffer_ref;
  94 
  95     // Bounds of the drawing region, at pixel precision.
  96     private double[] clipRect;
  97 
  98     // the outcode of the current point
  99     private int cOutCode = 0;
 100 
 101     private boolean subdivide = DO_CLIP_SUBDIVIDER;
 102 
 103     private final LengthIterator li = new LengthIterator();
 104 
 105     private final CurveClipSplitter curveSplitter;
 106 
 107     private double cycleLen;
 108     private boolean outside;
 109     private double totalSkipLen;
 110 
 111     /**
 112      * Constructs a &lt;code&gt;DDasher&lt;/code&gt;.
 113      * @param rdrCtx per-thread renderer context
 114      */
 115     DDasher(final DRendererContext rdrCtx) {
 116         this.rdrCtx = rdrCtx;
 117 
 118         dashes_ref = rdrCtx.newDirtyDoubleArrayRef(INITIAL_ARRAY); // 1K
 119 
 120         firstSegmentsBuffer_ref = rdrCtx.newDirtyDoubleArrayRef(INITIAL_ARRAY); // 1K
 121         firstSegmentsBuffer     = firstSegmentsBuffer_ref.initial;
 122 
 123         // we need curCurvepts to be able to contain 2 curves because when
 124         // dashing curves, we need to subdivide it
 125         curCurvepts = new double[8 * 2];
 126 
 127         this.curveSplitter = rdrCtx.curveClipSplitter;
 128     }
 129 
 130     /**
 131      * Initialize the &lt;code&gt;DDasher&lt;/code&gt;.
 132      *
 133      * @param out an output &lt;code&gt;DPathConsumer2D&lt;/code&gt;.
 134      * @param dash an array of &lt;code&gt;double&lt;/code&gt;s containing the dash pattern
 135      * @param dashLen length of the given dash array
 136      * @param phase a &lt;code&gt;double&lt;/code&gt; containing the dash phase
 137      * @param recycleDashes true to indicate to recycle the given dash array
 138      * @return this instance
 139      */
<a name="1" id="anc1"></a><span class="changed"> 140     DDasher init(final DPathConsumer2D out, final double[] dash, final int dashLen,</span>
<span class="changed"> 141                 double phase, final boolean recycleDashes)</span>
 142     {
 143         this.out = out;
 144 
 145         // Normalize so 0 &lt;= phase &lt; dash[0]
 146         int sidx = 0;
 147         dashOn = true;
 148 
<a name="2" id="anc2"></a><span class="new"> 149         // note: BasicStroke constructor checks dash elements and sum &gt; 0</span>
 150         double sum = 0.0d;
<a name="3" id="anc3"></a><span class="changed"> 151         for (int i = 0; i &lt; dashLen; i++) {</span>
<span class="changed"> 152             sum += dash[i];</span>
 153         }
 154         this.cycleLen = sum;
 155 
 156         double cycles = phase / sum;
 157         if (phase &lt; 0.0d) {
 158             if (-cycles &gt;= MAX_CYCLES) {
 159                 phase = 0.0d;
 160             } else {
 161                 int fullcycles = FloatMath.floor_int(-cycles);
<a name="4" id="anc4"></a><span class="changed"> 162                 if ((fullcycles &amp; dashLen &amp; 1) != 0) {</span>
 163                     dashOn = !dashOn;
 164                 }
 165                 phase += fullcycles * sum;
 166                 while (phase &lt; 0.0d) {
 167                     if (--sidx &lt; 0) {
<a name="5" id="anc5"></a><span class="changed"> 168                         sidx = dashLen - 1;</span>
 169                     }
 170                     phase += dash[sidx];
 171                     dashOn = !dashOn;
 172                 }
 173             }
 174         } else if (phase &gt; 0.0d) {
 175             if (cycles &gt;= MAX_CYCLES) {
 176                 phase = 0.0d;
 177             } else {
 178                 int fullcycles = FloatMath.floor_int(cycles);
<a name="6" id="anc6"></a><span class="changed"> 179                 if ((fullcycles &amp; dashLen &amp; 1) != 0) {</span>
 180                     dashOn = !dashOn;
 181                 }
 182                 phase -= fullcycles * sum;
 183                 double d;
 184                 while (phase &gt;= (d = dash[sidx])) {
 185                     phase -= d;
<a name="7" id="anc7"></a><span class="changed"> 186                     sidx = (sidx + 1) % dashLen;</span>
 187                     dashOn = !dashOn;
 188                 }
 189             }
 190         }
 191 
 192         this.dash = dash;
 193         this.dashLen = dashLen;
 194         this.phase = phase;
 195         this.startPhase = phase;
 196         this.startDashOn = dashOn;
 197         this.startIdx = sidx;
 198         this.starting = true;
 199         this.needsMoveTo = false;
 200         this.firstSegidx = 0;
 201 
 202         this.recycleDashes = recycleDashes;
 203 
 204         if (rdrCtx.doClip) {
 205             this.clipRect = rdrCtx.clipRect;
 206         } else {
 207             this.clipRect = null;
 208             this.cOutCode = 0;
 209         }
 210         return this; // fluent API
 211     }
 212 
 213     /**
 214      * Disposes this dasher:
 215      * clean up before reusing this instance
 216      */
 217     void dispose() {
 218         if (DO_CLEAN_DIRTY) {
 219             // Force zero-fill dirty arrays:
 220             Arrays.fill(curCurvepts, 0.0d);
 221         }
 222         // Return arrays:
 223         if (recycleDashes) {
 224             dash = dashes_ref.putArray(dash);
 225         }
 226         firstSegmentsBuffer = firstSegmentsBuffer_ref.putArray(firstSegmentsBuffer);
 227     }
 228 
 229     double[] copyDashArray(final float[] dashes) {
 230         final int len = dashes.length;
 231         final double[] newDashes;
 232         if (len &lt;= MarlinConst.INITIAL_ARRAY) {
 233             newDashes = dashes_ref.initial;
 234         } else {
 235             if (DO_STATS) {
 236                 rdrCtx.stats.stat_array_dasher_dasher.add(len);
 237             }
 238             newDashes = dashes_ref.getArray(len);
 239         }
 240         for (int i = 0; i &lt; len; i++) { newDashes[i] = dashes[i]; }
 241         return newDashes;
 242     }
 243 
 244     @Override
 245     public void moveTo(final double x0, final double y0) {
 246         if (firstSegidx != 0) {
 247             out.moveTo(sx0, sy0);
 248             emitFirstSegments();
 249         }
 250         this.needsMoveTo = true;
 251         this.idx = startIdx;
 252         this.dashOn = this.startDashOn;
 253         this.phase = this.startPhase;
 254         this.cx0 = x0;
 255         this.cy0 = y0;
 256 
 257         // update starting point:
 258         this.sx0 = x0;
 259         this.sy0 = y0;
 260         this.starting = true;
 261 
 262         if (clipRect != null) {
 263             final int outcode = DHelpers.outcode(x0, y0, clipRect);
 264             this.cOutCode = outcode;
 265             this.outside = false;
 266             this.totalSkipLen = 0.0d;
 267         }
 268     }
 269 
 270     private void emitSeg(double[] buf, int off, int type) {
 271         switch (type) {
 272         case 8:
 273             out.curveTo(buf[off    ], buf[off + 1],
 274                         buf[off + 2], buf[off + 3],
 275                         buf[off + 4], buf[off + 5]);
 276             return;
 277         case 6:
 278             out.quadTo(buf[off    ], buf[off + 1],
 279                        buf[off + 2], buf[off + 3]);
 280             return;
 281         case 4:
 282             out.lineTo(buf[off], buf[off + 1]);
 283             return;
 284         default:
 285         }
 286     }
 287 
 288     private void emitFirstSegments() {
 289         final double[] fSegBuf = firstSegmentsBuffer;
 290 
 291         for (int i = 0, len = firstSegidx; i &lt; len; ) {
 292             int type = (int)fSegBuf[i];
 293             emitSeg(fSegBuf, i + 1, type);
 294             i += (type - 1);
 295         }
 296         firstSegidx = 0;
 297     }
 298 
 299     // precondition: pts must be in relative coordinates (relative to x0,y0)
 300     private void goTo(final double[] pts, final int off, final int type,
 301                       final boolean on)
 302     {
 303         final int index = off + type;
 304         final double x = pts[index - 4];
 305         final double y = pts[index - 3];
 306 
 307         if (on) {
 308             if (starting) {
 309                 goTo_starting(pts, off, type);
 310             } else {
 311                 if (needsMoveTo) {
 312                     needsMoveTo = false;
 313                     out.moveTo(cx0, cy0);
 314                 }
 315                 emitSeg(pts, off, type);
 316             }
 317         } else {
 318             if (starting) {
 319                 // low probability test (hotspot)
 320                 starting = false;
 321             }
 322             needsMoveTo = true;
 323         }
 324         this.cx0 = x;
 325         this.cy0 = y;
 326     }
 327 
 328     private void goTo_starting(final double[] pts, final int off, final int type) {
 329         int len = type - 1; // - 2 + 1
 330         int segIdx = firstSegidx;
 331         double[] buf = firstSegmentsBuffer;
 332 
 333         if (segIdx + len  &gt; buf.length) {
 334             if (DO_STATS) {
 335                 rdrCtx.stats.stat_array_dasher_firstSegmentsBuffer
 336                     .add(segIdx + len);
 337             }
 338             firstSegmentsBuffer = buf
 339                 = firstSegmentsBuffer_ref.widenArray(buf, segIdx,
 340                                                      segIdx + len);
 341         }
 342         buf[segIdx++] = type;
 343         len--;
 344         // small arraycopy (2, 4 or 6) but with offset:
 345         System.arraycopy(pts, off, buf, segIdx, len);
 346         firstSegidx = segIdx + len;
 347     }
 348 
 349     @Override
 350     public void lineTo(final double x1, final double y1) {
 351         final int outcode0 = this.cOutCode;
 352 
 353         if (clipRect != null) {
 354             final int outcode1 = DHelpers.outcode(x1, y1, clipRect);
 355 
 356             // Should clip
 357             final int orCode = (outcode0 | outcode1);
 358 
 359             if (orCode != 0) {
 360                 final int sideCode = outcode0 &amp; outcode1;
 361 
 362                 // basic rejection criteria:
 363                 if (sideCode == 0) {
 364                     // ovelap clip:
 365                     if (subdivide) {
 366                         // avoid reentrance
 367                         subdivide = false;
 368                         // subdivide curve =&gt; callback with subdivided parts:
 369                         boolean ret = curveSplitter.splitLine(cx0, cy0, x1, y1,
 370                                                               orCode, this);
 371                         // reentrance is done:
 372                         subdivide = true;
 373                         if (ret) {
 374                             return;
 375                         }
 376                     }
 377                     // already subdivided so render it
 378                 } else {
 379                     this.cOutCode = outcode1;
 380                     skipLineTo(x1, y1);
 381                     return;
 382                 }
 383             }
 384 
 385             this.cOutCode = outcode1;
 386 
 387             if (this.outside) {
 388                 this.outside = false;
 389                 // Adjust current index, phase &amp; dash:
 390                 skipLen();
 391             }
 392         }
 393         _lineTo(x1, y1);
 394     }
 395 
 396     private void _lineTo(final double x1, final double y1) {
 397         final double dx = x1 - cx0;
 398         final double dy = y1 - cy0;
 399 
 400         double len = dx * dx + dy * dy;
 401         if (len == 0.0d) {
 402             return;
 403         }
 404         len = Math.sqrt(len);
 405 
 406         // The scaling factors needed to get the dx and dy of the
 407         // transformed dash segments.
 408         final double cx = dx / len;
 409         final double cy = dy / len;
 410 
 411         final double[] _curCurvepts = curCurvepts;
 412         final double[] _dash = dash;
 413         final int _dashLen = this.dashLen;
 414 
 415         int _idx = idx;
 416         boolean _dashOn = dashOn;
 417         double _phase = phase;
 418 
 419         double leftInThisDashSegment, d;
 420 
 421         while (true) {
 422             d = _dash[_idx];
 423             leftInThisDashSegment = d - _phase;
 424 
 425             if (len &lt;= leftInThisDashSegment) {
 426                 _curCurvepts[0] = x1;
 427                 _curCurvepts[1] = y1;
 428 
 429                 goTo(_curCurvepts, 0, 4, _dashOn);
 430 
 431                 // Advance phase within current dash segment
 432                 _phase += len;
 433 
 434                 // TODO: compare double values using epsilon:
 435                 if (len == leftInThisDashSegment) {
 436                     _phase = 0.0d;
 437                     _idx = (_idx + 1) % _dashLen;
 438                     _dashOn = !_dashOn;
 439                 }
 440                 break;
 441             }
 442 
 443             if (_phase == 0.0d) {
 444                 _curCurvepts[0] = cx0 + d * cx;
 445                 _curCurvepts[1] = cy0 + d * cy;
 446             } else {
 447                 _curCurvepts[0] = cx0 + leftInThisDashSegment * cx;
 448                 _curCurvepts[1] = cy0 + leftInThisDashSegment * cy;
 449             }
 450 
 451             goTo(_curCurvepts, 0, 4, _dashOn);
 452 
 453             len -= leftInThisDashSegment;
 454             // Advance to next dash segment
 455             _idx = (_idx + 1) % _dashLen;
 456             _dashOn = !_dashOn;
 457             _phase = 0.0d;
 458         }
 459         // Save local state:
 460         idx = _idx;
 461         dashOn = _dashOn;
 462         phase = _phase;
 463     }
 464 
 465     private void skipLineTo(final double x1, final double y1) {
 466         final double dx = x1 - cx0;
 467         final double dy = y1 - cy0;
 468 
 469         double len = dx * dx + dy * dy;
 470         if (len != 0.0d) {
 471             len = Math.sqrt(len);
 472         }
 473 
 474         // Accumulate skipped length:
 475         this.outside = true;
 476         this.totalSkipLen += len;
 477 
 478         // Fix initial move:
 479         this.needsMoveTo = true;
 480         this.starting = false;
 481 
 482         this.cx0 = x1;
 483         this.cy0 = y1;
 484     }
 485 
 486     public void skipLen() {
 487         double len = this.totalSkipLen;
 488         this.totalSkipLen = 0.0d;
 489 
 490         final double[] _dash = dash;
 491         final int _dashLen = this.dashLen;
 492 
 493         int _idx = idx;
 494         boolean _dashOn = dashOn;
 495         double _phase = phase;
 496 
 497         // -2 to ensure having 2 iterations of the post-loop
 498         // to compensate the remaining phase
 499         final long fullcycles = (long)Math.floor(len / cycleLen) - 2L;
 500 
 501         if (fullcycles &gt; 0L) {
 502             len -= cycleLen * fullcycles;
 503 
 504             final long iterations = fullcycles * _dashLen;
 505             _idx = (int) (iterations + _idx) % _dashLen;
 506             _dashOn = (iterations + (_dashOn ? 1L : 0L) &amp; 1L) == 1L;
 507         }
 508 
 509         double leftInThisDashSegment, d;
 510 
 511         while (true) {
 512             d = _dash[_idx];
 513             leftInThisDashSegment = d - _phase;
 514 
 515             if (len &lt;= leftInThisDashSegment) {
 516                 // Advance phase within current dash segment
 517                 _phase += len;
 518 
 519                 // TODO: compare double values using epsilon:
 520                 if (len == leftInThisDashSegment) {
 521                     _phase = 0.0d;
 522                     _idx = (_idx + 1) % _dashLen;
 523                     _dashOn = !_dashOn;
 524                 }
 525                 break;
 526             }
 527 
 528             len -= leftInThisDashSegment;
 529             // Advance to next dash segment
 530             _idx = (_idx + 1) % _dashLen;
 531             _dashOn = !_dashOn;
 532             _phase = 0.0d;
 533         }
 534         // Save local state:
 535         idx = _idx;
 536         dashOn = _dashOn;
 537         phase = _phase;
 538     }
 539 
 540     // preconditions: curCurvepts must be an array of length at least 2 * type,
 541     // that contains the curve we want to dash in the first type elements
 542     private void somethingTo(final int type) {
 543         final double[] _curCurvepts = curCurvepts;
 544         if (pointCurve(_curCurvepts, type)) {
 545             return;
 546         }
 547         final LengthIterator _li = li;
 548         final double[] _dash = dash;
 549         final int _dashLen = this.dashLen;
 550 
 551         _li.initializeIterationOnCurve(_curCurvepts, type);
 552 
 553         int _idx = idx;
 554         boolean _dashOn = dashOn;
 555         double _phase = phase;
 556 
 557         // initially the current curve is at curCurvepts[0...type]
 558         int curCurveoff = 0;
 559         double prevT = 0.0d;
 560         double t;
 561         double leftInThisDashSegment = _dash[_idx] - _phase;
 562 
 563         while ((t = _li.next(leftInThisDashSegment)) &lt; 1.0d) {
 564             if (t != 0.0d) {
 565                 DHelpers.subdivideAt((t - prevT) / (1.0d - prevT),
 566                                     _curCurvepts, curCurveoff,
 567                                     _curCurvepts, 0, type);
 568                 prevT = t;
 569                 goTo(_curCurvepts, 2, type, _dashOn);
 570                 curCurveoff = type;
 571             }
 572             // Advance to next dash segment
 573             _idx = (_idx + 1) % _dashLen;
 574             _dashOn = !_dashOn;
 575             _phase = 0.0d;
 576             leftInThisDashSegment = _dash[_idx];
 577         }
 578 
 579         goTo(_curCurvepts, curCurveoff + 2, type, _dashOn);
 580 
 581         _phase += _li.lastSegLen();
 582         if (_phase &gt;= _dash[_idx]) {
 583             _phase = 0.0d;
 584             _idx = (_idx + 1) % _dashLen;
 585             _dashOn = !_dashOn;
 586         }
 587         // Save local state:
 588         idx = _idx;
 589         dashOn = _dashOn;
 590         phase = _phase;
 591 
 592         // reset LengthIterator:
 593         _li.reset();
 594     }
 595 
 596     private void skipSomethingTo(final int type) {
 597         final double[] _curCurvepts = curCurvepts;
 598         if (pointCurve(_curCurvepts, type)) {
 599             return;
 600         }
 601         final LengthIterator _li = li;
 602 
 603         _li.initializeIterationOnCurve(_curCurvepts, type);
 604 
 605         // In contrary to somethingTo(),
 606         // just estimate properly the curve length:
 607         final double len = _li.totalLength();
 608 
 609         // Accumulate skipped length:
 610         this.outside = true;
 611         this.totalSkipLen += len;
 612 
 613         // Fix initial move:
 614         this.needsMoveTo = true;
 615         this.starting = false;
 616     }
 617 
 618     private static boolean pointCurve(final double[] curve, final int type) {
 619         for (int i = 2; i &lt; type; i++) {
 620             if (curve[i] != curve[i-2]) {
 621                 return false;
 622             }
 623         }
 624         return true;
 625     }
 626 
 627     // Objects of this class are used to iterate through curves. They return
 628     // t values where the left side of the curve has a specified length.
 629     // It does this by subdividing the input curve until a certain error
 630     // condition has been met. A recursive subdivision procedure would
 631     // return as many as 1&lt;&lt;limit curves, but this is an iterator and we
 632     // don't need all the curves all at once, so what we carry out a
 633     // lazy inorder traversal of the recursion tree (meaning we only move
 634     // through the tree when we need the next subdivided curve). This saves
 635     // us a lot of memory because at any one time we only need to store
 636     // limit+1 curves - one for each level of the tree + 1.
 637     // NOTE: the way we do things here is not enough to traverse a general
 638     // tree; however, the trees we are interested in have the property that
 639     // every non leaf node has exactly 2 children
 640     static final class LengthIterator {
 641         // Holds the curves at various levels of the recursion. The root
 642         // (i.e. the original curve) is at recCurveStack[0] (but then it
 643         // gets subdivided, the left half is put at 1, so most of the time
 644         // only the right half of the original curve is at 0)
 645         private final double[][] recCurveStack; // dirty
 646         // sidesRight[i] indicates whether the node at level i+1 in the path from
 647         // the root to the current leaf is a left or right child of its parent.
 648         private final boolean[] sidesRight; // dirty
 649         private int curveType;
 650         // lastT and nextT delimit the current leaf.
 651         private double nextT;
 652         private double lenAtNextT;
 653         private double lastT;
 654         private double lenAtLastT;
 655         private double lenAtLastSplit;
 656         private double lastSegLen;
 657         // the current level in the recursion tree. 0 is the root. limit
 658         // is the deepest possible leaf.
 659         private int recLevel;
 660         private boolean done;
 661 
 662         // the lengths of the lines of the control polygon. Only its first
 663         // curveType/2 - 1 elements are valid. This is an optimization. See
 664         // next() for more detail.
 665         private final double[] curLeafCtrlPolyLengths = new double[3];
 666 
 667         LengthIterator() {
 668             this.recCurveStack = new double[REC_LIMIT + 1][8];
 669             this.sidesRight = new boolean[REC_LIMIT];
 670             // if any methods are called without first initializing this object
 671             // on a curve, we want it to fail ASAP.
 672             this.nextT = Double.MAX_VALUE;
 673             this.lenAtNextT = Double.MAX_VALUE;
 674             this.lenAtLastSplit = Double.MIN_VALUE;
 675             this.recLevel = Integer.MIN_VALUE;
 676             this.lastSegLen = Double.MAX_VALUE;
 677             this.done = true;
 678         }
 679 
 680         /**
 681          * Reset this LengthIterator.
 682          */
 683         void reset() {
 684             // keep data dirty
 685             // as it appears not useful to reset data:
 686             if (DO_CLEAN_DIRTY) {
 687                 final int recLimit = recCurveStack.length - 1;
 688                 for (int i = recLimit; i &gt;= 0; i--) {
 689                     Arrays.fill(recCurveStack[i], 0.0d);
 690                 }
 691                 Arrays.fill(sidesRight, false);
 692                 Arrays.fill(curLeafCtrlPolyLengths, 0.0d);
 693                 Arrays.fill(nextRoots, 0.0d);
 694                 Arrays.fill(flatLeafCoefCache, 0.0d);
 695                 flatLeafCoefCache[2] = -1.0d;
 696             }
 697         }
 698 
 699         void initializeIterationOnCurve(final double[] pts, final int type) {
 700             // optimize arraycopy (8 values faster than 6 = type):
 701             System.arraycopy(pts, 0, recCurveStack[0], 0, 8);
 702             this.curveType = type;
 703             this.recLevel = 0;
 704             this.lastT = 0.0d;
 705             this.lenAtLastT = 0.0d;
 706             this.nextT = 0.0d;
 707             this.lenAtNextT = 0.0d;
 708             goLeft(); // initializes nextT and lenAtNextT properly
 709             this.lenAtLastSplit = 0.0d;
 710             if (recLevel &gt; 0) {
 711                 this.sidesRight[0] = false;
 712                 this.done = false;
 713             } else {
 714                 // the root of the tree is a leaf so we're done.
 715                 this.sidesRight[0] = true;
 716                 this.done = true;
 717             }
 718             this.lastSegLen = 0.0d;
 719         }
 720 
 721         // 0 == false, 1 == true, -1 == invalid cached value.
 722         private int cachedHaveLowAcceleration = -1;
 723 
 724         private boolean haveLowAcceleration(final double err) {
 725             if (cachedHaveLowAcceleration == -1) {
 726                 final double len1 = curLeafCtrlPolyLengths[0];
 727                 final double len2 = curLeafCtrlPolyLengths[1];
 728                 // the test below is equivalent to !within(len1/len2, 1, err).
 729                 // It is using a multiplication instead of a division, so it
 730                 // should be a bit faster.
 731                 if (!DHelpers.within(len1, len2, err * len2)) {
 732                     cachedHaveLowAcceleration = 0;
 733                     return false;
 734                 }
 735                 if (curveType == 8) {
 736                     final double len3 = curLeafCtrlPolyLengths[2];
 737                     // if len1 is close to 2 and 2 is close to 3, that probably
 738                     // means 1 is close to 3 so the second part of this test might
 739                     // not be needed, but it doesn't hurt to include it.
 740                     final double errLen3 = err * len3;
 741                     if (!(DHelpers.within(len2, len3, errLen3) &amp;&amp;
 742                           DHelpers.within(len1, len3, errLen3))) {
 743                         cachedHaveLowAcceleration = 0;
 744                         return false;
 745                     }
 746                 }
 747                 cachedHaveLowAcceleration = 1;
 748                 return true;
 749             }
 750 
 751             return (cachedHaveLowAcceleration == 1);
 752         }
 753 
 754         // we want to avoid allocations/gc so we keep this array so we
 755         // can put roots in it,
 756         private final double[] nextRoots = new double[4];
 757 
 758         // caches the coefficients of the current leaf in its flattened
 759         // form (see inside next() for what that means). The cache is
 760         // invalid when it's third element is negative, since in any
 761         // valid flattened curve, this would be &gt;= 0.
 762         private final double[] flatLeafCoefCache = new double[]{0.0d, 0.0d, -1.0d, 0.0d};
 763 
 764         // returns the t value where the remaining curve should be split in
 765         // order for the left subdivided curve to have length len. If len
 766         // is &gt;= than the length of the uniterated curve, it returns 1.
 767         double next(final double len) {
 768             final double targetLength = lenAtLastSplit + len;
 769             while (lenAtNextT &lt; targetLength) {
 770                 if (done) {
 771                     lastSegLen = lenAtNextT - lenAtLastSplit;
 772                     return 1.0d;
 773                 }
 774                 goToNextLeaf();
 775             }
 776             lenAtLastSplit = targetLength;
 777             final double leaflen = lenAtNextT - lenAtLastT;
 778             double t = (targetLength - lenAtLastT) / leaflen;
 779 
 780             // cubicRootsInAB is a fairly expensive call, so we just don't do it
 781             // if the acceleration in this section of the curve is small enough.
 782             if (!haveLowAcceleration(0.05d)) {
 783                 // We flatten the current leaf along the x axis, so that we're
 784                 // left with a, b, c which define a 1D Bezier curve. We then
 785                 // solve this to get the parameter of the original leaf that
 786                 // gives us the desired length.
 787                 final double[] _flatLeafCoefCache = flatLeafCoefCache;
 788 
 789                 if (_flatLeafCoefCache[2] &lt; 0.0d) {
 790                     double x =     curLeafCtrlPolyLengths[0],
 791                            y = x + curLeafCtrlPolyLengths[1];
 792                     if (curveType == 8) {
 793                         double z = y + curLeafCtrlPolyLengths[2];
 794                         _flatLeafCoefCache[0] = 3.0d * (x - y) + z;
 795                         _flatLeafCoefCache[1] = 3.0d * (y - 2.0d * x);
 796                         _flatLeafCoefCache[2] = 3.0d * x;
 797                         _flatLeafCoefCache[3] = -z;
 798                     } else if (curveType == 6) {
 799                         _flatLeafCoefCache[0] = 0.0d;
 800                         _flatLeafCoefCache[1] = y - 2.0d * x;
 801                         _flatLeafCoefCache[2] = 2.0d * x;
 802                         _flatLeafCoefCache[3] = -y;
 803                     }
 804                 }
 805                 double a = _flatLeafCoefCache[0];
 806                 double b = _flatLeafCoefCache[1];
 807                 double c = _flatLeafCoefCache[2];
 808                 double d = t * _flatLeafCoefCache[3];
 809 
 810                 // we use cubicRootsInAB here, because we want only roots in 0, 1,
 811                 // and our quadratic root finder doesn't filter, so it's just a
 812                 // matter of convenience.
 813                 final int n = DHelpers.cubicRootsInAB(a, b, c, d, nextRoots, 0, 0.0d, 1.0d);
 814                 if (n == 1 &amp;&amp; !Double.isNaN(nextRoots[0])) {
 815                     t = nextRoots[0];
 816                 }
 817             }
 818             // t is relative to the current leaf, so we must make it a valid parameter
 819             // of the original curve.
 820             t = t * (nextT - lastT) + lastT;
 821             if (t &gt;= 1.0d) {
 822                 t = 1.0d;
 823                 done = true;
 824             }
 825             // even if done = true, if we're here, that means targetLength
 826             // is equal to, or very, very close to the total length of the
 827             // curve, so lastSegLen won't be too high. In cases where len
 828             // overshoots the curve, this method will exit in the while
 829             // loop, and lastSegLen will still be set to the right value.
 830             lastSegLen = len;
 831             return t;
 832         }
 833 
 834         double totalLength() {
 835             while (!done) {
 836                 goToNextLeaf();
 837             }
 838             // reset LengthIterator:
 839             reset();
 840 
 841             return lenAtNextT;
 842         }
 843 
 844         double lastSegLen() {
 845             return lastSegLen;
 846         }
 847 
 848         // go to the next leaf (in an inorder traversal) in the recursion tree
 849         // preconditions: must be on a leaf, and that leaf must not be the root.
 850         private void goToNextLeaf() {
 851             // We must go to the first ancestor node that has an unvisited
 852             // right child.
 853             final boolean[] _sides = sidesRight;
 854             int _recLevel = recLevel;
 855             _recLevel--;
 856 
 857             while(_sides[_recLevel]) {
 858                 if (_recLevel == 0) {
 859                     recLevel = 0;
 860                     done = true;
 861                     return;
 862                 }
 863                 _recLevel--;
 864             }
 865 
 866             _sides[_recLevel] = true;
 867             // optimize arraycopy (8 values faster than 6 = type):
 868             System.arraycopy(recCurveStack[_recLevel++], 0,
 869                              recCurveStack[_recLevel], 0, 8);
 870             recLevel = _recLevel;
 871             goLeft();
 872         }
 873 
 874         // go to the leftmost node from the current node. Return its length.
 875         private void goLeft() {
 876             final double len = onLeaf();
 877             if (len &gt;= 0.0d) {
 878                 lastT = nextT;
 879                 lenAtLastT = lenAtNextT;
 880                 nextT += (1 &lt;&lt; (REC_LIMIT - recLevel)) * MIN_T_INC;
 881                 lenAtNextT += len;
 882                 // invalidate caches
 883                 flatLeafCoefCache[2] = -1.0d;
 884                 cachedHaveLowAcceleration = -1;
 885             } else {
 886                 DHelpers.subdivide(recCurveStack[recLevel],
 887                                    recCurveStack[recLevel + 1],
 888                                    recCurveStack[recLevel], curveType);
 889 
 890                 sidesRight[recLevel] = false;
 891                 recLevel++;
 892                 goLeft();
 893             }
 894         }
 895 
 896         // this is a bit of a hack. It returns -1 if we're not on a leaf, and
 897         // the length of the leaf if we are on a leaf.
 898         private double onLeaf() {
 899             final double[] curve = recCurveStack[recLevel];
 900             final int _curveType = curveType;
 901             double polyLen = 0.0d;
 902 
 903             double x0 = curve[0], y0 = curve[1];
 904             for (int i = 2; i &lt; _curveType; i += 2) {
 905                 final double x1 = curve[i], y1 = curve[i + 1];
 906                 final double len = DHelpers.linelen(x0, y0, x1, y1);
 907                 polyLen += len;
 908                 curLeafCtrlPolyLengths[(i &gt;&gt; 1) - 1] = len;
 909                 x0 = x1;
 910                 y0 = y1;
 911             }
 912 
 913             final double lineLen = DHelpers.linelen(curve[0], curve[1], x0, y0);
 914 
 915             if ((polyLen - lineLen) &lt; CURVE_LEN_ERR || recLevel == REC_LIMIT) {
 916                 return (polyLen + lineLen) / 2.0d;
 917             }
 918             return -1.0d;
 919         }
 920     }
 921 
 922     @Override
 923     public void curveTo(final double x1, final double y1,
 924                         final double x2, final double y2,
 925                         final double x3, final double y3)
 926     {
 927         final int outcode0 = this.cOutCode;
 928 
 929         if (clipRect != null) {
 930             final int outcode1 = DHelpers.outcode(x1, y1, clipRect);
 931             final int outcode2 = DHelpers.outcode(x2, y2, clipRect);
 932             final int outcode3 = DHelpers.outcode(x3, y3, clipRect);
 933 
 934             // Should clip
 935             final int orCode = (outcode0 | outcode1 | outcode2 | outcode3);
 936             if (orCode != 0) {
 937                 final int sideCode = outcode0 &amp; outcode1 &amp; outcode2 &amp; outcode3;
 938 
 939                 // basic rejection criteria:
 940                 if (sideCode == 0) {
 941                     // ovelap clip:
 942                     if (subdivide) {
 943                         // avoid reentrance
 944                         subdivide = false;
 945                         // subdivide curve =&gt; callback with subdivided parts:
 946                         boolean ret = curveSplitter.splitCurve(cx0, cy0, x1, y1, x2, y2, x3, y3,
 947                                                                orCode, this);
 948                         // reentrance is done:
 949                         subdivide = true;
 950                         if (ret) {
 951                             return;
 952                         }
 953                     }
 954                     // already subdivided so render it
 955                 } else {
 956                     this.cOutCode = outcode3;
 957                     skipCurveTo(x1, y1, x2, y2, x3, y3);
 958                     return;
 959                 }
 960             }
 961 
 962             this.cOutCode = outcode3;
 963 
 964             if (this.outside) {
 965                 this.outside = false;
 966                 // Adjust current index, phase &amp; dash:
 967                 skipLen();
 968             }
 969         }
 970         _curveTo(x1, y1, x2, y2, x3, y3);
 971     }
 972 
 973     private void _curveTo(final double x1, final double y1,
 974                           final double x2, final double y2,
 975                           final double x3, final double y3)
 976     {
 977         final double[] _curCurvepts = curCurvepts;
 978 
 979         // monotonize curve:
 980         final CurveBasicMonotonizer monotonizer
 981             = rdrCtx.monotonizer.curve(cx0, cy0, x1, y1, x2, y2, x3, y3);
 982 
 983         final int nSplits = monotonizer.nbSplits;
 984         final double[] mid = monotonizer.middle;
 985 
 986         for (int i = 0, off = 0; i &lt;= nSplits; i++, off += 6) {
 987             // optimize arraycopy (8 values faster than 6 = type):
 988             System.arraycopy(mid, off, _curCurvepts, 0, 8);
 989 
 990             somethingTo(8);
 991         }
 992     }
 993 
 994     private void skipCurveTo(final double x1, final double y1,
 995                              final double x2, final double y2,
 996                              final double x3, final double y3)
 997     {
 998         final double[] _curCurvepts = curCurvepts;
 999         _curCurvepts[0] = cx0; _curCurvepts[1] = cy0;
1000         _curCurvepts[2] = x1;  _curCurvepts[3] = y1;
1001         _curCurvepts[4] = x2;  _curCurvepts[5] = y2;
1002         _curCurvepts[6] = x3;  _curCurvepts[7] = y3;
1003 
1004         skipSomethingTo(8);
1005 
1006         this.cx0 = x3;
1007         this.cy0 = y3;
1008     }
1009 
1010     @Override
1011     public void quadTo(final double x1, final double y1,
1012                        final double x2, final double y2)
1013     {
1014         final int outcode0 = this.cOutCode;
1015 
1016         if (clipRect != null) {
1017             final int outcode1 = DHelpers.outcode(x1, y1, clipRect);
1018             final int outcode2 = DHelpers.outcode(x2, y2, clipRect);
1019 
1020             // Should clip
1021             final int orCode = (outcode0 | outcode1 | outcode2);
1022             if (orCode != 0) {
1023                 final int sideCode = outcode0 &amp; outcode1 &amp; outcode2;
1024 
1025                 // basic rejection criteria:
1026                 if (sideCode == 0) {
1027                     // ovelap clip:
1028                     if (subdivide) {
1029                         // avoid reentrance
1030                         subdivide = false;
1031                         // subdivide curve =&gt; call lineTo() with subdivided curves:
1032                         boolean ret = curveSplitter.splitQuad(cx0, cy0, x1, y1,
1033                                                               x2, y2, orCode, this);
1034                         // reentrance is done:
1035                         subdivide = true;
1036                         if (ret) {
1037                             return;
1038                         }
1039                     }
1040                     // already subdivided so render it
1041                 } else {
1042                     this.cOutCode = outcode2;
1043                     skipQuadTo(x1, y1, x2, y2);
1044                     return;
1045                 }
1046             }
1047 
1048             this.cOutCode = outcode2;
1049 
1050             if (this.outside) {
1051                 this.outside = false;
1052                 // Adjust current index, phase &amp; dash:
1053                 skipLen();
1054             }
1055         }
1056         _quadTo(x1, y1, x2, y2);
1057     }
1058 
1059     private void _quadTo(final double x1, final double y1,
1060                          final double x2, final double y2)
1061     {
1062         final double[] _curCurvepts = curCurvepts;
1063 
1064         // monotonize quad:
1065         final CurveBasicMonotonizer monotonizer
1066             = rdrCtx.monotonizer.quad(cx0, cy0, x1, y1, x2, y2);
1067 
1068         final int nSplits = monotonizer.nbSplits;
1069         final double[] mid = monotonizer.middle;
1070 
1071         for (int i = 0, off = 0; i &lt;= nSplits; i++, off += 4) {
1072             // optimize arraycopy (8 values faster than 6 = type):
1073             System.arraycopy(mid, off, _curCurvepts, 0, 8);
1074 
1075             somethingTo(6);
1076         }
1077     }
1078 
1079     private void skipQuadTo(final double x1, final double y1,
1080                             final double x2, final double y2)
1081     {
1082         final double[] _curCurvepts = curCurvepts;
1083         _curCurvepts[0] = cx0; _curCurvepts[1] = cy0;
1084         _curCurvepts[2] = x1;  _curCurvepts[3] = y1;
1085         _curCurvepts[4] = x2;  _curCurvepts[5] = y2;
1086 
1087         skipSomethingTo(6);
1088 
1089         this.cx0 = x2;
1090         this.cy0 = y2;
1091     }
1092 
1093     @Override
1094     public void closePath() {
1095         if (cx0 != sx0 || cy0 != sy0) {
1096             lineTo(sx0, sy0);
1097         }
1098         if (firstSegidx != 0) {
1099             if (!dashOn || needsMoveTo) {
1100                 out.moveTo(sx0, sy0);
1101             }
1102             emitFirstSegments();
1103         }
1104         moveTo(sx0, sy0);
1105     }
1106 
1107     @Override
1108     public void pathDone() {
1109         if (firstSegidx != 0) {
1110             out.moveTo(sx0, sy0);
1111             emitFirstSegments();
1112         }
1113         out.pathDone();
1114 
1115         // Dispose this instance:
1116         dispose();
1117     }
1118 
1119     @Override
1120     public long getNativeConsumer() {
1121         throw new InternalError("DDasher does not use a native consumer");
1122     }
1123 }
1124 
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="8" type="hidden" /></form></body></html>
