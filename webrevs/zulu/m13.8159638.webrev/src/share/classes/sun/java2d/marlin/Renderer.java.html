<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/share/classes/sun/java2d/marlin/Renderer.java</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2007, 2015, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the "Classpath" exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.java2d.marlin;
  27 
  28 import java.util.Arrays;
  29 import sun.awt.geom.PathConsumer2D;
  30 import static sun.java2d.marlin.OffHeapArray.SIZE_INT;
  31 import sun.misc.Unsafe;
  32 
  33 final class Renderer implements PathConsumer2D, MarlinConst {
  34 
  35     static final boolean DISABLE_RENDER = false;
  36 
  37     static final boolean ENABLE_BLOCK_FLAGS = MarlinProperties.isUseTileFlags();
  38     static final boolean ENABLE_BLOCK_FLAGS_HEURISTICS = MarlinProperties.isUseTileFlagsWithHeuristics();
  39 
  40     private static final int ALL_BUT_LSB = 0xfffffffe;
  41     private static final int ERR_STEP_MAX = 0x7fffffff; // = 2^31 - 1
  42 
  43     private static final double POWER_2_TO_32 = 0x1.0p32;
  44 
  45     // use float to make tosubpix methods faster (no int to float conversion)
  46     public static final float F_SUBPIXEL_POSITIONS_X
  47         = (float) SUBPIXEL_POSITIONS_X;
  48     public static final float F_SUBPIXEL_POSITIONS_Y
  49         = (float) SUBPIXEL_POSITIONS_Y;
  50     public static final int SUBPIXEL_MASK_X = SUBPIXEL_POSITIONS_X - 1;
  51     public static final int SUBPIXEL_MASK_Y = SUBPIXEL_POSITIONS_Y - 1;
  52 
  53     // number of subpixels corresponding to a tile line
  54     private static final int SUBPIXEL_TILE
  55         = TILE_SIZE &lt;&lt; SUBPIXEL_LG_POSITIONS_Y;
  56 
  57     // 2048 (pixelSize) pixels (height) x 8 subpixels = 64K
  58     static final int INITIAL_BUCKET_ARRAY
  59         = INITIAL_PIXEL_DIM * SUBPIXEL_POSITIONS_Y;
  60 
  61     // crossing capacity = edges count / 8 ~ 512
  62     static final int INITIAL_CROSSING_COUNT = INITIAL_EDGES_COUNT &gt;&gt; 3;
  63 
  64     public static final int WIND_EVEN_ODD = 0;
  65     public static final int WIND_NON_ZERO = 1;
  66 
  67     // common to all types of input path segments.
  68     // OFFSET as bytes
  69     // only integer values:
  70     public static final long OFF_CURX_OR  = 0;
  71     public static final long OFF_ERROR    = OFF_CURX_OR  + SIZE_INT;
  72     public static final long OFF_BUMP_X   = OFF_ERROR    + SIZE_INT;
  73     public static final long OFF_BUMP_ERR = OFF_BUMP_X   + SIZE_INT;
  74     public static final long OFF_NEXT     = OFF_BUMP_ERR + SIZE_INT;
  75     public static final long OFF_YMAX     = OFF_NEXT     + SIZE_INT;
  76 
  77     // size of one edge in bytes
  78     public static final int SIZEOF_EDGE_BYTES = (int)(OFF_YMAX + SIZE_INT);
  79 
  80     // curve break into lines
  81     // cubic error in subpixels to decrement step
  82     private static final float CUB_DEC_ERR_SUBPIX
  83         = 2.5f * (NORM_SUBPIXELS / 8f); // 2.5 subpixel for typical 8x8 subpixels
  84     // cubic error in subpixels to increment step
  85     private static final float CUB_INC_ERR_SUBPIX
  86         = 1f * (NORM_SUBPIXELS / 8f); // 1 subpixel for typical 8x8 subpixels
  87 
  88     // cubic bind length to decrement step = 8 * error in subpixels
  89     // pisces: 20 / 8
  90     // openjfx pisces: 8 / 3.2
  91     // multiply by 8 = error scale factor:
  92     public static final float CUB_DEC_BND
  93         = 8f * CUB_DEC_ERR_SUBPIX; // 20f means 2.5 subpixel error
  94     // cubic bind length to increment step = 8 * error in subpixels
  95     public static final float CUB_INC_BND
  96         = 8f * CUB_INC_ERR_SUBPIX; // 8f means 1 subpixel error
  97 
  98     // cubic countlg
  99     public static final int CUB_COUNT_LG = 2;
 100     // cubic count = 2^countlg
 101     private static final int CUB_COUNT = 1 &lt;&lt; CUB_COUNT_LG;
 102     // cubic count^2 = 4^countlg
 103     private static final int CUB_COUNT_2 = 1 &lt;&lt; (2 * CUB_COUNT_LG);
 104     // cubic count^3 = 8^countlg
 105     private static final int CUB_COUNT_3 = 1 &lt;&lt; (3 * CUB_COUNT_LG);
 106     // cubic dt = 1 / count
 107     private static final float CUB_INV_COUNT = 1f / CUB_COUNT;
 108     // cubic dt^2 = 1 / count^2 = 1 / 4^countlg
 109     private static final float CUB_INV_COUNT_2 = 1f / CUB_COUNT_2;
 110     // cubic dt^3 = 1 / count^3 = 1 / 8^countlg
 111     private static final float CUB_INV_COUNT_3 = 1f / CUB_COUNT_3;
 112 
 113     // quad break into lines
 114     // quadratic error in subpixels
 115     private static final float QUAD_DEC_ERR_SUBPIX
 116         = 1f * (NORM_SUBPIXELS / 8f); // 1 subpixel for typical 8x8 subpixels
 117 
 118     // quadratic bind length to decrement step = 8 * error in subpixels
 119     // pisces and openjfx pisces: 32
 120     public static final float QUAD_DEC_BND
 121         = 8f * QUAD_DEC_ERR_SUBPIX; // 8f means 1 subpixel error
 122 
 123 //////////////////////////////////////////////////////////////////////////////
 124 //  SCAN LINE
 125 //////////////////////////////////////////////////////////////////////////////
 126     // crossings ie subpixel edge x coordinates
 127     private int[] crossings;
 128     // auxiliary storage for crossings (merge sort)
 129     private int[] aux_crossings;
 130 
 131     // indices into the segment pointer lists. They indicate the "active"
 132     // sublist in the segment lists (the portion of the list that contains
 133     // all the segments that cross the next scan line).
 134     private int edgeCount;
 135     private int[] edgePtrs;
 136     // auxiliary storage for edge pointers (merge sort)
 137     private int[] aux_edgePtrs;
 138 
 139     // max used for both edgePtrs and crossings (stats only)
 140     private int activeEdgeMaxUsed;
 141 
 142     // crossings ref (dirty)
 143     private final IntArrayCache.Reference crossings_ref;
 144     // edgePtrs ref (dirty)
 145     private final IntArrayCache.Reference edgePtrs_ref;
 146     // merge sort initial arrays (large enough to satisfy most usages) (1024)
 147     // aux_crossings ref (dirty)
 148     private final IntArrayCache.Reference aux_crossings_ref;
 149     // aux_edgePtrs ref (dirty)
 150     private final IntArrayCache.Reference aux_edgePtrs_ref;
 151 
 152 //////////////////////////////////////////////////////////////////////////////
 153 //  EDGE LIST
 154 //////////////////////////////////////////////////////////////////////////////
 155     private int edgeMinY = Integer.MAX_VALUE;
 156     private int edgeMaxY = Integer.MIN_VALUE;
 157     private float edgeMinX = Float.POSITIVE_INFINITY;
 158     private float edgeMaxX = Float.NEGATIVE_INFINITY;
 159 
 160     // edges [floats|ints] stored in off-heap memory
 161     private final OffHeapArray edges;
 162 
 163     private int[] edgeBuckets;
 164     private int[] edgeBucketCounts; // 2*newedges + (1 if pruning needed)
 165     // used range for edgeBuckets / edgeBucketCounts
 166     private int buckets_minY;
 167     private int buckets_maxY;
 168     // sum of each edge delta Y (subpixels)
 169     private int edgeSumDeltaY;
 170 
 171     // edgeBuckets ref (clean)
 172     private final IntArrayCache.Reference edgeBuckets_ref;
 173     // edgeBucketCounts ref (clean)
 174     private final IntArrayCache.Reference edgeBucketCounts_ref;
 175 
 176     // Flattens using adaptive forward differencing. This only carries out
 177     // one iteration of the AFD loop. All it does is update AFD variables (i.e.
 178     // X0, Y0, D*[X|Y], COUNT; not variables used for computing scanline crossings).
 179     private void quadBreakIntoLinesAndAdd(float x0, float y0,
 180                                           final Curve c,
 181                                           final float x2, final float y2)
 182     {
 183         int count = 1; // dt = 1 / count
 184 
 185         // maximum(ddX|Y) = norm(dbx, dby) * dt^2 (= 1)
 186         float maxDD = FloatMath.max(Math.abs(c.dbx), Math.abs(c.dby));
 187 
 188         final float _DEC_BND = QUAD_DEC_BND;
 189 
 190         while (maxDD &gt;= _DEC_BND) {
 191             // divide step by half:
 192             maxDD /= 4f; // error divided by 2^2 = 4
 193 
 194             count &lt;&lt;= 1;
 195             if (DO_STATS) {
 196                 rdrCtx.stats.stat_rdr_quadBreak_dec.add(count);
 197             }
 198         }
 199 
 200         int nL = 0; // line count
 201         if (count &gt; 1) {
 202             final float icount = 1f / count; // dt
 203             final float icount2 = icount * icount; // dt^2
 204 
 205             final float ddx = c.dbx * icount2;
 206             final float ddy = c.dby * icount2;
 207             float dx = c.bx * icount2 + c.cx * icount;
 208             float dy = c.by * icount2 + c.cy * icount;
 209 
 210             float x1, y1;
 211 
 212             while (--count &gt; 0) {
 213                 x1 = x0 + dx;
 214                 dx += ddx;
 215                 y1 = y0 + dy;
 216                 dy += ddy;
 217 
 218                 addLine(x0, y0, x1, y1);
 219 
 220                 if (DO_STATS) { nL++; }
 221                 x0 = x1;
 222                 y0 = y1;
 223             }
 224         }
 225         addLine(x0, y0, x2, y2);
 226 
 227         if (DO_STATS) {
 228             rdrCtx.stats.stat_rdr_quadBreak.add(nL + 1);
 229         }
 230     }
 231 
 232     // x0, y0 and x3,y3 are the endpoints of the curve. We could compute these
 233     // using c.xat(0),c.yat(0) and c.xat(1),c.yat(1), but this might introduce
 234     // numerical errors, and our callers already have the exact values.
 235     // Another alternative would be to pass all the control points, and call
 236     // c.set here, but then too many numbers are passed around.
 237     private void curveBreakIntoLinesAndAdd(float x0, float y0,
 238                                            final Curve c,
 239                                            final float x3, final float y3)
 240     {
 241         int count           = CUB_COUNT;
 242         final float icount  = CUB_INV_COUNT;   // dt
 243         final float icount2 = CUB_INV_COUNT_2; // dt^2
 244         final float icount3 = CUB_INV_COUNT_3; // dt^3
 245 
 246         // the dx and dy refer to forward differencing variables, not the last
 247         // coefficients of the "points" polynomial
 248         float dddx, dddy, ddx, ddy, dx, dy;
 249         dddx = 2f * c.dax * icount3;
 250         dddy = 2f * c.day * icount3;
 251         ddx = dddx + c.dbx * icount2;
 252         ddy = dddy + c.dby * icount2;
 253         dx = c.ax * icount3 + c.bx * icount2 + c.cx * icount;
 254         dy = c.ay * icount3 + c.by * icount2 + c.cy * icount;
 255 
 256         // we use x0, y0 to walk the line
 257         float x1 = x0, y1 = y0;
 258         int nL = 0; // line count
 259 
 260         final float _DEC_BND = CUB_DEC_BND;
 261         final float _INC_BND = CUB_INC_BND;
 262 
 263         while (count &gt; 0) {
 264             // divide step by half:
 265             while (Math.abs(ddx) &gt;= _DEC_BND || Math.abs(ddy) &gt;= _DEC_BND) {
 266                 dddx /= 8f;
 267                 dddy /= 8f;
 268                 ddx = ddx/4f - dddx;
 269                 ddy = ddy/4f - dddy;
 270                 dx = (dx - ddx) / 2f;
 271                 dy = (dy - ddy) / 2f;
 272 
 273                 count &lt;&lt;= 1;
 274                 if (DO_STATS) {
 275                     rdrCtx.stats.stat_rdr_curveBreak_dec.add(count);
 276                 }
 277             }
 278 
 279             // double step:
 280             // TODO: why use first derivative dX|Y instead of second ddX|Y ?
 281             // both scale changes should use speed or acceleration to have the same metric.
 282 
 283             // can only do this on even "count" values, because we must divide count by 2
 284             while (count % 2 == 0
 285                    &amp;&amp; Math.abs(dx) &lt;= _INC_BND &amp;&amp; Math.abs(dy) &lt;= _INC_BND)
 286             {
 287                 dx = 2f * dx + ddx;
 288                 dy = 2f * dy + ddy;
 289                 ddx = 4f * (ddx + dddx);
 290                 ddy = 4f * (ddy + dddy);
 291                 dddx *= 8f;
 292                 dddy *= 8f;
 293 
 294                 count &gt;&gt;= 1;
 295                 if (DO_STATS) {
 296                     rdrCtx.stats.stat_rdr_curveBreak_inc.add(count);
 297                 }
 298             }
 299             if (--count &gt; 0) {
 300                 x1 += dx;
 301                 dx += ddx;
 302                 ddx += dddx;
 303                 y1 += dy;
 304                 dy += ddy;
 305                 ddy += dddy;
 306             } else {
 307                 x1 = x3;
 308                 y1 = y3;
 309             }
 310 
 311             addLine(x0, y0, x1, y1);
 312 
 313             if (DO_STATS) { nL++; }
 314             x0 = x1;
 315             y0 = y1;
 316         }
 317         if (DO_STATS) {
 318             rdrCtx.stats.stat_rdr_curveBreak.add(nL);
 319         }
 320     }
 321 
 322     private void addLine(float x1, float y1, float x2, float y2) {
 323         if (DO_MONITORS) {
 324             rdrCtx.stats.mon_rdr_addLine.start();
 325         }
 326         if (DO_STATS) {
 327             rdrCtx.stats.stat_rdr_addLine.add(1);
 328         }
 329         int or = 1; // orientation of the line. 1 if y increases, 0 otherwise.
 330         if (y2 &lt; y1) {
 331             or = 0;
 332             float tmp = y2;
 333             y2 = y1;
 334             y1 = tmp;
 335             tmp = x2;
 336             x2 = x1;
 337             x1 = tmp;
 338         }
 339 
 340         // convert subpixel coordinates (float) into pixel positions (int)
 341 
 342         // The index of the pixel that holds the next HPC is at ceil(trueY - 0.5)
 343         // Since y1 and y2 are biased by -0.5 in tosubpixy(), this is simply
 344         // ceil(y1) or ceil(y2)
 345         // upper integer (inclusive)
 346         final int firstCrossing = FloatMath.max(FloatMath.ceil_int(y1), boundsMinY);
 347 
 348         // note: use boundsMaxY (last Y exclusive) to compute correct coverage
 349         // upper integer (exclusive)
 350         final int lastCrossing  = FloatMath.min(FloatMath.ceil_int(y2), boundsMaxY);
 351 
 352         /* skip horizontal lines in pixel space and clip edges
 353            out of y range [boundsMinY; boundsMaxY] */
 354         if (firstCrossing &gt;= lastCrossing) {
 355             if (DO_MONITORS) {
 356                 rdrCtx.stats.mon_rdr_addLine.stop();
 357             }
 358             if (DO_STATS) {
 359                 rdrCtx.stats.stat_rdr_addLine_skip.add(1);
 360             }
 361             return;
 362         }
 363 
 364         // edge min/max X/Y are in subpixel space (inclusive) within bounds:
 365         // note: Use integer crossings to ensure consistent range within
 366         // edgeBuckets / edgeBucketCounts arrays in case of NaN values (int = 0)
 367         if (firstCrossing &lt; edgeMinY) {
 368             edgeMinY = firstCrossing;
 369         }
 370         if (lastCrossing &gt; edgeMaxY) {
 371             edgeMaxY = lastCrossing;
 372         }
 373 
 374         // Use double-precision for improved accuracy:
 375         final double x1d   = x1;
 376         final double y1d   = y1;
 377         final double slope = (x1d - x2) / (y1d - y2);
 378 
 379         if (slope &gt;= 0.0) { // &lt;==&gt; x1 &lt; x2
 380             if (x1 &lt; edgeMinX) {
 381                 edgeMinX = x1;
 382             }
 383             if (x2 &gt; edgeMaxX) {
 384                 edgeMaxX = x2;
 385             }
 386         } else {
 387             if (x2 &lt; edgeMinX) {
 388                 edgeMinX = x2;
 389             }
 390             if (x1 &gt; edgeMaxX) {
 391                 edgeMaxX = x1;
 392             }
 393         }
 394 
 395         // local variables for performance:
 396         final int _SIZEOF_EDGE_BYTES = SIZEOF_EDGE_BYTES;
 397 
 398         final OffHeapArray _edges = edges;
 399 
 400         // get free pointer (ie length in bytes)
 401         final int edgePtr = _edges.used;
 402 
 403         // use substraction to avoid integer overflow:
 404         if (_edges.length - edgePtr &lt; _SIZEOF_EDGE_BYTES) {
 405             // suppose _edges.length &gt; _SIZEOF_EDGE_BYTES
 406             // so doubling size is enough to add needed bytes
 407             // note: throw IOOB if neededSize &gt; 2Gb:
 408             final long edgeNewSize = ArrayCacheConst.getNewLargeSize(
 409                                         _edges.length,
 410                                         edgePtr + _SIZEOF_EDGE_BYTES);
 411 
 412             if (DO_STATS) {
 413                 rdrCtx.stats.stat_rdr_edges_resizes.add(edgeNewSize);
 414             }
 415             _edges.resize(edgeNewSize);
 416         }
 417 
 418 
 419         final Unsafe _unsafe = OffHeapArray.UNSAFE;
 420         final long SIZE_INT = 4L;
 421         long addr   = _edges.address + edgePtr;
 422 
 423         // The x value must be bumped up to its position at the next HPC we will evaluate.
 424         // "firstcrossing" is the (sub)pixel number where the next crossing occurs
 425         // thus, the actual coordinate of the next HPC is "firstcrossing + 0.5"
 426         // so the Y distance we cover is "firstcrossing + 0.5 - trueY".
 427         // Note that since y1 (and y2) are already biased by -0.5 in tosubpixy(), we have
 428         // y1 = trueY - 0.5
 429         // trueY = y1 + 0.5
 430         // firstcrossing + 0.5 - trueY = firstcrossing + 0.5 - (y1 + 0.5)
 431         //                             = firstcrossing - y1
 432         // The x coordinate at that HPC is then:
 433         // x1_intercept = x1 + (firstcrossing - y1) * slope
 434         // The next VPC is then given by:
 435         // VPC index = ceil(x1_intercept - 0.5), or alternately
 436         // VPC index = floor(x1_intercept - 0.5 + 1 - epsilon)
 437         // epsilon is hard to pin down in floating point, but easy in fixed point, so if
 438         // we convert to fixed point then these operations get easier:
 439         // long x1_fixed = x1_intercept * 2^32;  (fixed point 32.32 format)
 440         // curx = next VPC = fixed_floor(x1_fixed - 2^31 + 2^32 - 1)
 441         //                 = fixed_floor(x1_fixed + 2^31 - 1)
 442         //                 = fixed_floor(x1_fixed + 0x7fffffff)
 443         // and error       = fixed_fract(x1_fixed + 0x7fffffff)
 444         final double x1_intercept = x1d + (firstCrossing - y1d) * slope;
 445 
 446         // inlined scalb(x1_intercept, 32):
 447         final long x1_fixed_biased = ((long) (POWER_2_TO_32 * x1_intercept))
 448                                      + 0x7fffffffL;
 449         // curx:
 450         // last bit corresponds to the orientation
 451         _unsafe.putInt(addr, (((int) (x1_fixed_biased &gt;&gt; 31L)) &amp; ALL_BUT_LSB) | or);
 452         addr += SIZE_INT;
 453         _unsafe.putInt(addr,  ((int)  x1_fixed_biased) &gt;&gt;&gt; 1);
 454         addr += SIZE_INT;
 455 
 456         // inlined scalb(slope, 32):
 457         final long slope_fixed = (long) (POWER_2_TO_32 * slope);
 458 
 459         // last bit set to 0 to keep orientation:
 460         _unsafe.putInt(addr, (((int) (slope_fixed &gt;&gt; 31L)) &amp; ALL_BUT_LSB));
 461         addr += SIZE_INT;
 462         _unsafe.putInt(addr,  ((int)  slope_fixed) &gt;&gt;&gt; 1);
 463         addr += SIZE_INT;
 464 
 465         final int[] _edgeBuckets      = edgeBuckets;
 466         final int[] _edgeBucketCounts = edgeBucketCounts;
 467 
 468         final int _boundsMinY = boundsMinY;
 469 
 470         // each bucket is a linked list. this method adds ptr to the
 471         // start of the "bucket"th linked list.
 472         final int bucketIdx = firstCrossing - _boundsMinY;
 473 
 474         // pointer from bucket
 475         _unsafe.putInt(addr, _edgeBuckets[bucketIdx]);
 476         addr += SIZE_INT;
 477         // y max (inclusive)
 478         _unsafe.putInt(addr,  lastCrossing);
 479 
 480         // Update buckets:
 481         // directly the edge struct "pointer"
 482         _edgeBuckets[bucketIdx]       = edgePtr;
 483         _edgeBucketCounts[bucketIdx] += 2; // 1 &lt;&lt; 1
 484         // last bit means edge end
 485         _edgeBucketCounts[lastCrossing - _boundsMinY] |= 0x1;
 486 
 487         // update sum of delta Y (subpixels):
 488         edgeSumDeltaY += (lastCrossing - firstCrossing);
 489 
 490         // update free pointer (ie length in bytes)
 491         _edges.used += _SIZEOF_EDGE_BYTES;
 492 
 493         if (DO_MONITORS) {
 494             rdrCtx.stats.mon_rdr_addLine.stop();
 495         }
 496     }
 497 
 498 // END EDGE LIST
 499 //////////////////////////////////////////////////////////////////////////////
 500 
 501     // Cache to store RLE-encoded coverage mask of the current primitive
 502     final MarlinCache cache;
 503 
 504     // Bounds of the drawing region, at subpixel precision.
 505     private int boundsMinX, boundsMinY, boundsMaxX, boundsMaxY;
 506 
 507     // Current winding rule
 508     private int windingRule;
 509 
 510     // Current drawing position, i.e., final point of last segment
 511     private float x0, y0;
 512 
 513     // Position of most recent 'moveTo' command
 514     private float sx0, sy0;
 515 
 516     // per-thread renderer context
 517     final RendererContext rdrCtx;
 518     // dirty curve
 519     private final Curve curve;
 520 
 521     // clean alpha array (zero filled)
 522     private int[] alphaLine;
 523 
 524     // alphaLine ref (clean)
 525     private final IntArrayCache.Reference alphaLine_ref;
 526 
 527     private boolean enableBlkFlags = false;
 528     private boolean prevUseBlkFlags = false;
 529 
 530     /* block flags (0|1) */
 531     private int[] blkFlags;
 532 
 533     // blkFlags ref (clean)
 534     private final IntArrayCache.Reference blkFlags_ref;
 535 
 536     Renderer(final RendererContext rdrCtx) {
 537         this.rdrCtx = rdrCtx;
 538 
 539         this.edges = rdrCtx.newOffHeapArray(INITIAL_EDGES_CAPACITY); // 96K
 540 
 541         this.curve = rdrCtx.curve;
 542 
 543         edgeBuckets_ref      = rdrCtx.newCleanIntArrayRef(INITIAL_BUCKET_ARRAY); // 64K
 544         edgeBucketCounts_ref = rdrCtx.newCleanIntArrayRef(INITIAL_BUCKET_ARRAY); // 64K
 545 
 546         edgeBuckets      = edgeBuckets_ref.initial;
 547         edgeBucketCounts = edgeBucketCounts_ref.initial;
 548 
 549         // 2048 (pixelsize) pixel large
 550         alphaLine_ref = rdrCtx.newCleanIntArrayRef(INITIAL_AA_ARRAY); // 8K
 551         alphaLine     = alphaLine_ref.initial;
 552 
 553         this.cache = rdrCtx.cache;
 554 
 555         crossings_ref     = rdrCtx.newDirtyIntArrayRef(INITIAL_CROSSING_COUNT); // 2K
 556         aux_crossings_ref = rdrCtx.newDirtyIntArrayRef(INITIAL_CROSSING_COUNT); // 2K
 557         edgePtrs_ref      = rdrCtx.newDirtyIntArrayRef(INITIAL_CROSSING_COUNT); // 2K
 558         aux_edgePtrs_ref  = rdrCtx.newDirtyIntArrayRef(INITIAL_CROSSING_COUNT); // 2K
 559 
 560         crossings     = crossings_ref.initial;
 561         aux_crossings = aux_crossings_ref.initial;
 562         edgePtrs      = edgePtrs_ref.initial;
 563         aux_edgePtrs  = aux_edgePtrs_ref.initial;
 564 
 565         blkFlags_ref = rdrCtx.newCleanIntArrayRef(INITIAL_ARRAY); // 1K = 1 tile line
 566         blkFlags     = blkFlags_ref.initial;
 567     }
 568 
 569     Renderer init(final int pix_boundsX, final int pix_boundsY,
 570                   final int pix_boundsWidth, final int pix_boundsHeight,
 571                   final int windingRule) {
 572 
 573         this.windingRule = windingRule;
 574 
 575         // bounds as half-open intervals: minX &lt;= x &lt; maxX and minY &lt;= y &lt; maxY
 576         this.boundsMinX =  pix_boundsX &lt;&lt; SUBPIXEL_LG_POSITIONS_X;
 577         this.boundsMaxX =
 578             (pix_boundsX + pix_boundsWidth) &lt;&lt; SUBPIXEL_LG_POSITIONS_X;
 579         this.boundsMinY =  pix_boundsY &lt;&lt; SUBPIXEL_LG_POSITIONS_Y;
 580         this.boundsMaxY =
 581             (pix_boundsY + pix_boundsHeight) &lt;&lt; SUBPIXEL_LG_POSITIONS_Y;
 582 
 583         if (DO_LOG_BOUNDS) {
 584             MarlinUtils.logInfo("boundsXY = [" + boundsMinX + " ... "
 585                                 + boundsMaxX + "[ [" + boundsMinY + " ... "
 586                                 + boundsMaxY + "[");
 587         }
 588 
 589         // see addLine: ceil(boundsMaxY) =&gt; boundsMaxY + 1
 590         // +1 for edgeBucketCounts
 591         final int edgeBucketsLength = (boundsMaxY - boundsMinY) + 1;
 592 
 593         if (edgeBucketsLength &gt; INITIAL_BUCKET_ARRAY) {
 594             if (DO_STATS) {
 595                 rdrCtx.stats.stat_array_renderer_edgeBuckets
 596                     .add(edgeBucketsLength);
 597                 rdrCtx.stats.stat_array_renderer_edgeBucketCounts
 598                     .add(edgeBucketsLength);
 599             }
 600             edgeBuckets = edgeBuckets_ref.getArray(edgeBucketsLength);
 601             edgeBucketCounts = edgeBucketCounts_ref.getArray(edgeBucketsLength);
 602         }
 603 
 604         edgeMinY = Integer.MAX_VALUE;
 605         edgeMaxY = Integer.MIN_VALUE;
 606         edgeMinX = Float.POSITIVE_INFINITY;
 607         edgeMaxX = Float.NEGATIVE_INFINITY;
 608 
 609         // reset used mark:
 610         edgeCount = 0;
 611         activeEdgeMaxUsed = 0;
 612         edges.used = 0;
 613 
 614         edgeSumDeltaY = 0;
 615 
 616         return this; // fluent API
 617     }
 618 
 619     /**
 620      * Disposes this renderer and recycle it clean up before reusing this instance
 621      */
 622     void dispose() {
 623         if (DO_STATS) {
 624             rdrCtx.stats.stat_rdr_activeEdges.add(activeEdgeMaxUsed);
 625             rdrCtx.stats.stat_rdr_edges.add(edges.used);
 626             rdrCtx.stats.stat_rdr_edges_count.add(edges.used / SIZEOF_EDGE_BYTES);
 627             rdrCtx.stats.hist_rdr_edges_count.add(edges.used / SIZEOF_EDGE_BYTES);
 628             rdrCtx.stats.totalOffHeap += edges.length;
 629         }
 630         // Return arrays:
 631         crossings = crossings_ref.putArray(crossings);
 632         aux_crossings = aux_crossings_ref.putArray(aux_crossings);
 633 
 634         edgePtrs = edgePtrs_ref.putArray(edgePtrs);
 635         aux_edgePtrs = aux_edgePtrs_ref.putArray(aux_edgePtrs);
 636 
 637         alphaLine = alphaLine_ref.putArray(alphaLine, 0, 0); // already zero filled
 638         blkFlags  = blkFlags_ref.putArray(blkFlags, 0, 0); // already zero filled
 639 
 640         if (edgeMinY != Integer.MAX_VALUE) {
 641             // if context is maked as DIRTY:
 642             if (rdrCtx.dirty) {
 643                 // may happen if an exception if thrown in the pipeline processing:
 644                 // clear completely buckets arrays:
 645                 buckets_minY = 0;
 646                 buckets_maxY = boundsMaxY - boundsMinY;
 647             }
 648             // clear only used part
 649             edgeBuckets = edgeBuckets_ref.putArray(edgeBuckets, buckets_minY,
 650                                                                 buckets_maxY);
 651             edgeBucketCounts = edgeBucketCounts_ref.putArray(edgeBucketCounts,
 652                                                              buckets_minY,
 653                                                              buckets_maxY + 1);
 654         } else {
 655             // unused arrays
 656             edgeBuckets = edgeBuckets_ref.putArray(edgeBuckets, 0, 0);
 657             edgeBucketCounts = edgeBucketCounts_ref.putArray(edgeBucketCounts, 0, 0);
 658         }
 659 
 660         // At last: resize back off-heap edges to initial size
 661         if (edges.length != INITIAL_EDGES_CAPACITY) {
 662             // note: may throw OOME:
 663             edges.resize(INITIAL_EDGES_CAPACITY);
 664         }
 665         if (DO_CLEAN_DIRTY) {
 666             // Force zero-fill dirty arrays:
 667             edges.fill(BYTE_0);
 668         }
 669         if (DO_MONITORS) {
 670             rdrCtx.stats.mon_rdr_endRendering.stop();
 671         }
 672     }
 673 
 674     private static float tosubpixx(final float pix_x) {
 675         return F_SUBPIXEL_POSITIONS_X * pix_x;
 676     }
 677 
 678     private static float tosubpixy(final float pix_y) {
 679         // shift y by -0.5 for fast ceil(y - 0.5):
 680         return F_SUBPIXEL_POSITIONS_Y * pix_y - 0.5f;
 681     }
 682 
 683     @Override
 684     public void moveTo(float pix_x0, float pix_y0) {
 685         closePath();
 686         final float sx = tosubpixx(pix_x0);
 687         final float sy = tosubpixy(pix_y0);
 688         this.sx0 = sx;
 689         this.sy0 = sy;
 690         this.x0 = sx;
 691         this.y0 = sy;
 692     }
 693 
 694     @Override
 695     public void lineTo(float pix_x1, float pix_y1) {
 696         final float x1 = tosubpixx(pix_x1);
 697         final float y1 = tosubpixy(pix_y1);
 698         addLine(x0, y0, x1, y1);
 699         x0 = x1;
 700         y0 = y1;
 701     }
 702 
 703     @Override
 704     public void curveTo(float x1, float y1,
 705             float x2, float y2,
 706             float x3, float y3)
 707     {
 708         final float xe = tosubpixx(x3);
 709         final float ye = tosubpixy(y3);
 710         curve.set(x0, y0, tosubpixx(x1), tosubpixy(y1),
 711                           tosubpixx(x2), tosubpixy(y2), xe, ye);
 712         curveBreakIntoLinesAndAdd(x0, y0, curve, xe, ye);
 713         x0 = xe;
 714         y0 = ye;
 715     }
 716 
 717     @Override
 718     public void quadTo(float x1, float y1, float x2, float y2) {
 719         final float xe = tosubpixx(x2);
 720         final float ye = tosubpixy(y2);
 721         curve.set(x0, y0, tosubpixx(x1), tosubpixy(y1), xe, ye);
 722         quadBreakIntoLinesAndAdd(x0, y0, curve, xe, ye);
 723         x0 = xe;
 724         y0 = ye;
 725     }
 726 
 727     @Override
 728     public void closePath() {
 729         addLine(x0, y0, sx0, sy0);
 730         x0 = sx0;
 731         y0 = sy0;
 732     }
 733 
 734     @Override
 735     public void pathDone() {
 736         closePath();
 737     }
 738 
 739     @Override
 740     public long getNativeConsumer() {
 741         throw new InternalError("Renderer does not use a native consumer.");
 742     }
 743 
 744     private void _endRendering(final int ymin, final int ymax) {
 745         if (DISABLE_RENDER) {
 746             return;
 747         }
 748 
 749         // Get X bounds as true pixel boundaries to compute correct pixel coverage:
 750         final int bboxx0 = bbox_spminX;
 751         final int bboxx1 = bbox_spmaxX;
 752 
 753         final boolean windingRuleEvenOdd = (windingRule == WIND_EVEN_ODD);
 754 
 755         // Useful when processing tile line by tile line
 756         final int[] _alpha = alphaLine;
 757 
 758         // local vars (performance):
 759         final MarlinCache _cache = cache;
 760         final OffHeapArray _edges = edges;
 761         final int[] _edgeBuckets = edgeBuckets;
 762         final int[] _edgeBucketCounts = edgeBucketCounts;
 763 
 764         int[] _crossings = this.crossings;
 765         int[] _edgePtrs  = this.edgePtrs;
 766 
 767         // merge sort auxiliary storage:
 768         int[] _aux_crossings = this.aux_crossings;
 769         int[] _aux_edgePtrs  = this.aux_edgePtrs;
 770 
 771         // copy constants:
 772         final long _OFF_ERROR    = OFF_ERROR;
 773         final long _OFF_BUMP_X   = OFF_BUMP_X;
 774         final long _OFF_BUMP_ERR = OFF_BUMP_ERR;
 775 
 776         final long _OFF_NEXT     = OFF_NEXT;
 777         final long _OFF_YMAX     = OFF_YMAX;
 778 
 779         final int _ALL_BUT_LSB   = ALL_BUT_LSB;
 780         final int _ERR_STEP_MAX  = ERR_STEP_MAX;
 781 
 782         // unsafe I/O:
 783         final Unsafe _unsafe = OffHeapArray.UNSAFE;
 784         final long    addr0  = _edges.address;
 785         long addr;
 786         final int _SUBPIXEL_LG_POSITIONS_X = SUBPIXEL_LG_POSITIONS_X;
 787         final int _SUBPIXEL_LG_POSITIONS_Y = SUBPIXEL_LG_POSITIONS_Y;
 788         final int _SUBPIXEL_MASK_X = SUBPIXEL_MASK_X;
 789         final int _SUBPIXEL_MASK_Y = SUBPIXEL_MASK_Y;
 790         final int _SUBPIXEL_POSITIONS_X = SUBPIXEL_POSITIONS_X;
 791 
 792         final int _MIN_VALUE = Integer.MIN_VALUE;
 793         final int _MAX_VALUE = Integer.MAX_VALUE;
 794 
 795         // Now we iterate through the scanlines. We must tell emitRow the coord
 796         // of the first non-transparent pixel, so we must keep accumulators for
 797         // the first and last pixels of the section of the current pixel row
 798         // that we will emit.
 799         // We also need to accumulate pix_bbox, but the iterator does it
 800         // for us. We will just get the values from it once this loop is done
 801         int minX = _MAX_VALUE;
 802         int maxX = _MIN_VALUE;
 803 
 804         int y = ymin;
 805         int bucket = y - boundsMinY;
 806 
 807         int numCrossings = this.edgeCount;
 808         int edgePtrsLen = _edgePtrs.length;
 809         int crossingsLen = _crossings.length;
 810         int _arrayMaxUsed = activeEdgeMaxUsed;
 811         int ptrLen = 0, newCount, ptrEnd;
 812 
 813         int bucketcount, i, j, ecur;
 814         int cross, lastCross;
 815         int x0, x1, tmp, sum, prev, curx, curxo, crorientation, err;
 816         int pix_x, pix_xmaxm1, pix_xmax;
 817 
 818         int low, high, mid, prevNumCrossings;
 819         boolean useBinarySearch;
 820 
 821         final int[] _blkFlags = blkFlags;
 822         final int _BLK_SIZE_LG = BLOCK_SIZE_LG;
 823         final int _BLK_SIZE = BLOCK_SIZE;
 824 
 825         final boolean _enableBlkFlagsHeuristics = ENABLE_BLOCK_FLAGS_HEURISTICS &amp;&amp; this.enableBlkFlags;
 826 
 827         // Use block flags if large pixel span and few crossings:
 828         // ie mean(distance between crossings) is high
 829         boolean useBlkFlags = this.prevUseBlkFlags;
 830 
 831         final int stroking = rdrCtx.stroking;
 832 
 833         int lastY = -1; // last emited row
 834 
 835 
 836         // Iteration on scanlines
 837         for (; y &lt; ymax; y++, bucket++) {
 838             // --- from former ScanLineIterator.next()
 839             bucketcount = _edgeBucketCounts[bucket];
 840 
 841             // marker on previously sorted edges:
 842             prevNumCrossings = numCrossings;
 843 
 844             // bucketCount indicates new edge / edge end:
 845             if (bucketcount != 0) {
 846                 if (DO_STATS) {
 847                     rdrCtx.stats.stat_rdr_activeEdges_updates.add(numCrossings);
 848                 }
 849 
 850                 // last bit set to 1 means that edges ends
 851                 if ((bucketcount &amp; 0x1) != 0) {
 852                     // eviction in active edge list
 853                     // cache edges[] address + offset
 854                     addr = addr0 + _OFF_YMAX;
 855 
 856                     for (i = 0, newCount = 0; i &lt; numCrossings; i++) {
 857                         // get the pointer to the edge
 858                         ecur = _edgePtrs[i];
 859                         // random access so use unsafe:
 860                         if (_unsafe.getInt(addr + ecur) &gt; y) {
 861                             _edgePtrs[newCount++] = ecur;
 862                         }
 863                     }
 864                     // update marker on sorted edges minus removed edges:
 865                     prevNumCrossings = numCrossings = newCount;
 866                 }
 867 
 868                 ptrLen = bucketcount &gt;&gt; 1; // number of new edge
 869 
 870                 if (ptrLen != 0) {
 871                     if (DO_STATS) {
 872                         rdrCtx.stats.stat_rdr_activeEdges_adds.add(ptrLen);
 873                         if (ptrLen &gt; 10) {
 874                             rdrCtx.stats.stat_rdr_activeEdges_adds_high.add(ptrLen);
 875                         }
 876                     }
 877                     ptrEnd = numCrossings + ptrLen;
 878 
 879                     if (edgePtrsLen &lt; ptrEnd) {
 880                         if (DO_STATS) {
 881                             rdrCtx.stats.stat_array_renderer_edgePtrs.add(ptrEnd);
 882                         }
 883                         this.edgePtrs = _edgePtrs
 884                             = edgePtrs_ref.widenArray(_edgePtrs, numCrossings,
 885                                                       ptrEnd);
 886 
 887                         edgePtrsLen = _edgePtrs.length;
 888                         // Get larger auxiliary storage:
 889                         aux_edgePtrs_ref.putArray(_aux_edgePtrs);
 890 
 891                         // use ArrayCache.getNewSize() to use the same growing
 892                         // factor than widenArray():
 893                         if (DO_STATS) {
 894                             rdrCtx.stats.stat_array_renderer_aux_edgePtrs.add(ptrEnd);
 895                         }
 896                         this.aux_edgePtrs = _aux_edgePtrs
 897                             = aux_edgePtrs_ref.getArray(
 898                                 ArrayCacheConst.getNewSize(numCrossings, ptrEnd)
 899                             );
 900                     }
 901 
 902                     // cache edges[] address + offset
 903                     addr = addr0 + _OFF_NEXT;
 904 
 905                     // add new edges to active edge list:
 906                     for (ecur = _edgeBuckets[bucket];
 907                          numCrossings &lt; ptrEnd; numCrossings++)
 908                     {
 909                         // store the pointer to the edge
 910                         _edgePtrs[numCrossings] = ecur;
 911                         // random access so use unsafe:
 912                         ecur = _unsafe.getInt(addr + ecur);
 913                     }
 914 
 915                     if (crossingsLen &lt; numCrossings) {
 916                         // Get larger array:
 917                         crossings_ref.putArray(_crossings);
 918 
 919                         if (DO_STATS) {
 920                             rdrCtx.stats.stat_array_renderer_crossings
 921                                 .add(numCrossings);
 922                         }
 923                         this.crossings = _crossings
 924                             = crossings_ref.getArray(numCrossings);
 925 
 926                         // Get larger auxiliary storage:
 927                         aux_crossings_ref.putArray(_aux_crossings);
 928 
 929                         if (DO_STATS) {
 930                             rdrCtx.stats.stat_array_renderer_aux_crossings
 931                                 .add(numCrossings);
 932                         }
 933                         this.aux_crossings = _aux_crossings
 934                             = aux_crossings_ref.getArray(numCrossings);
 935 
 936                         crossingsLen = _crossings.length;
 937                     }
 938                     if (DO_STATS) {
 939                         // update max used mark
 940                         if (numCrossings &gt; _arrayMaxUsed) {
 941                             _arrayMaxUsed = numCrossings;
 942                         }
 943                     }
 944                 } // ptrLen != 0
 945             } // bucketCount != 0
 946 
 947 
 948             if (numCrossings != 0) {
 949                 /*
 950                  * thresholds to switch to optimized merge sort
 951                  * for newly added edges + final merge pass.
 952                  */
 953                 if ((ptrLen &lt; 10) || (numCrossings &lt; 40)) {
 954                     if (DO_STATS) {
 955                         rdrCtx.stats.hist_rdr_crossings.add(numCrossings);
 956                         rdrCtx.stats.hist_rdr_crossings_adds.add(ptrLen);
 957                     }
 958 
 959                     /*
 960                      * threshold to use binary insertion sort instead of
 961                      * straight insertion sort (to reduce minimize comparisons).
 962                      */
 963                     useBinarySearch = (numCrossings &gt;= 20);
 964 
 965                     // if small enough:
 966                     lastCross = _MIN_VALUE;
 967 
 968                     for (i = 0; i &lt; numCrossings; i++) {
 969                         // get the pointer to the edge
 970                         ecur = _edgePtrs[i];
 971 
 972                         /* convert subpixel coordinates (float) into pixel
 973                             positions (int) for coming scanline */
 974                         /* note: it is faster to always update edges even
 975                            if it is removed from AEL for coming or last scanline */
 976 
 977                         // random access so use unsafe:
 978                         addr = addr0 + ecur; // ecur + OFF_F_CURX
 979 
 980                         // get current crossing:
 981                         curx = _unsafe.getInt(addr);
 982 
 983                         // update crossing with orientation at last bit:
 984                         cross = curx;
 985 
 986                         // Increment x using DDA (fixed point):
 987                         curx += _unsafe.getInt(addr + _OFF_BUMP_X);
 988 
 989                         // Increment error:
 990                         err  =  _unsafe.getInt(addr + _OFF_ERROR)
 991                               + _unsafe.getInt(addr + _OFF_BUMP_ERR);
 992 
 993                         // Manual carry handling:
 994                         // keep sign and carry bit only and ignore last bit (preserve orientation):
 995                         _unsafe.putInt(addr,               curx - ((err &gt;&gt; 30) &amp; _ALL_BUT_LSB));
 996                         _unsafe.putInt(addr + _OFF_ERROR, (err &amp; _ERR_STEP_MAX));
 997 
 998                         if (DO_STATS) {
 999                             rdrCtx.stats.stat_rdr_crossings_updates.add(numCrossings);
1000                         }
1001 
1002                         // insertion sort of crossings:
1003                         if (cross &lt; lastCross) {
1004                             if (DO_STATS) {
1005                                 rdrCtx.stats.stat_rdr_crossings_sorts.add(i);
1006                             }
1007 
1008                             /* use binary search for newly added edges
1009                                in crossings if arrays are large enough */
1010                             if (useBinarySearch &amp;&amp; (i &gt;= prevNumCrossings)) {
1011                                 if (DO_STATS) {
1012                                     rdrCtx.stats.stat_rdr_crossings_bsearch.add(i);
1013                                 }
1014                                 low = 0;
1015                                 high = i - 1;
1016 
1017                                 do {
1018                                     // note: use signed shift (not &gt;&gt;&gt;) for performance
1019                                     // as indices are small enough to exceed Integer.MAX_VALUE
1020                                     mid = (low + high) &gt;&gt; 1;
1021 
1022                                     if (_crossings[mid] &lt; cross) {
1023                                         low = mid + 1;
1024                                     } else {
1025                                         high = mid - 1;
1026                                     }
1027                                 } while (low &lt;= high);
1028 
1029                                 for (j = i - 1; j &gt;= low; j--) {
1030                                     _crossings[j + 1] = _crossings[j];
1031                                     _edgePtrs [j + 1] = _edgePtrs[j];
1032                                 }
1033                                 _crossings[low] = cross;
1034                                 _edgePtrs [low] = ecur;
1035 
1036                             } else {
1037                                 j = i - 1;
1038                                 _crossings[i] = _crossings[j];
1039                                 _edgePtrs[i] = _edgePtrs[j];
1040 
1041                                 while ((--j &gt;= 0) &amp;&amp; (_crossings[j] &gt; cross)) {
1042                                     _crossings[j + 1] = _crossings[j];
1043                                     _edgePtrs [j + 1] = _edgePtrs[j];
1044                                 }
1045                                 _crossings[j + 1] = cross;
1046                                 _edgePtrs [j + 1] = ecur;
1047                             }
1048 
1049                         } else {
1050                             _crossings[i] = lastCross = cross;
1051                         }
1052                     }
1053                 } else {
1054                     if (DO_STATS) {
1055                         rdrCtx.stats.stat_rdr_crossings_msorts.add(numCrossings);
1056                         rdrCtx.stats.hist_rdr_crossings_ratio
1057                             .add((1000 * ptrLen) / numCrossings);
1058                         rdrCtx.stats.hist_rdr_crossings_msorts.add(numCrossings);
1059                         rdrCtx.stats.hist_rdr_crossings_msorts_adds.add(ptrLen);
1060                     }
1061 
1062                     // Copy sorted data in auxiliary arrays
1063                     // and perform insertion sort on almost sorted data
1064                     // (ie i &lt; prevNumCrossings):
1065 
1066                     lastCross = _MIN_VALUE;
1067 
1068                     for (i = 0; i &lt; numCrossings; i++) {
1069                         // get the pointer to the edge
1070                         ecur = _edgePtrs[i];
1071 
1072                         /* convert subpixel coordinates (float) into pixel
1073                             positions (int) for coming scanline */
1074                         /* note: it is faster to always update edges even
1075                            if it is removed from AEL for coming or last scanline */
1076 
1077                         // random access so use unsafe:
1078                         addr = addr0 + ecur; // ecur + OFF_F_CURX
1079 
1080                         // get current crossing:
1081                         curx = _unsafe.getInt(addr);
1082 
1083                         // update crossing with orientation at last bit:
1084                         cross = curx;
1085 
1086                         // Increment x using DDA (fixed point):
1087                         curx += _unsafe.getInt(addr + _OFF_BUMP_X);
1088 
1089                         // Increment error:
1090                         err  =  _unsafe.getInt(addr + _OFF_ERROR)
1091                               + _unsafe.getInt(addr + _OFF_BUMP_ERR);
1092 
1093                         // Manual carry handling:
1094                         // keep sign and carry bit only and ignore last bit (preserve orientation):
1095                         _unsafe.putInt(addr,               curx - ((err &gt;&gt; 30) &amp; _ALL_BUT_LSB));
1096                         _unsafe.putInt(addr + _OFF_ERROR, (err &amp; _ERR_STEP_MAX));
1097 
1098                         if (DO_STATS) {
1099                             rdrCtx.stats.stat_rdr_crossings_updates.add(numCrossings);
1100                         }
1101 
1102                         if (i &gt;= prevNumCrossings) {
1103                             // simply store crossing as edgePtrs is in-place:
1104                             // will be copied and sorted efficiently by mergesort later:
1105                             _crossings[i]     = cross;
1106 
1107                         } else if (cross &lt; lastCross) {
1108                             if (DO_STATS) {
1109                                 rdrCtx.stats.stat_rdr_crossings_sorts.add(i);
1110                             }
1111 
1112                             // (straight) insertion sort of crossings:
1113                             j = i - 1;
1114                             _aux_crossings[i] = _aux_crossings[j];
1115                             _aux_edgePtrs[i] = _aux_edgePtrs[j];
1116 
1117                             while ((--j &gt;= 0) &amp;&amp; (_aux_crossings[j] &gt; cross)) {
1118                                 _aux_crossings[j + 1] = _aux_crossings[j];
1119                                 _aux_edgePtrs [j + 1] = _aux_edgePtrs[j];
1120                             }
1121                             _aux_crossings[j + 1] = cross;
1122                             _aux_edgePtrs [j + 1] = ecur;
1123 
1124                         } else {
1125                             // auxiliary storage:
1126                             _aux_crossings[i] = lastCross = cross;
1127                             _aux_edgePtrs [i] = ecur;
1128                         }
1129                     }
1130 
1131                     // use Mergesort using auxiliary arrays (sort only right part)
1132                     MergeSort.mergeSortNoCopy(_crossings,     _edgePtrs,
1133                                               _aux_crossings, _aux_edgePtrs,
1134                                               numCrossings,   prevNumCrossings);
1135                 }
1136 
1137                 // reset ptrLen
1138                 ptrLen = 0;
1139                 // --- from former ScanLineIterator.next()
1140 
1141 
1142                 /* note: bboxx0 and bboxx1 must be pixel boundaries
1143                    to have correct coverage computation */
1144 
1145                 // right shift on crossings to get the x-coordinate:
1146                 curxo = _crossings[0];
1147                 x0    = curxo &gt;&gt; 1;
1148                 if (x0 &lt; minX) {
1149                     minX = x0; // subpixel coordinate
1150                 }
1151 
1152                 x1 = _crossings[numCrossings - 1] &gt;&gt; 1;
1153                 if (x1 &gt; maxX) {
1154                     maxX = x1; // subpixel coordinate
1155                 }
1156 
1157 
1158                 // compute pixel coverages
1159                 prev = curx = x0;
1160                 // to turn {0, 1} into {-1, 1}, multiply by 2 and subtract 1.
1161                 // last bit contains orientation (0 or 1)
1162                 crorientation = ((curxo &amp; 0x1) &lt;&lt; 1) - 1;
1163 
1164                 if (windingRuleEvenOdd) {
1165                     sum = crorientation;
1166 
1167                     // Even Odd winding rule: take care of mask ie sum(orientations)
1168                     for (i = 1; i &lt; numCrossings; i++) {
1169                         curxo = _crossings[i];
1170                         curx  =  curxo &gt;&gt; 1;
1171                         // to turn {0, 1} into {-1, 1}, multiply by 2 and subtract 1.
1172                         // last bit contains orientation (0 or 1)
1173                         crorientation = ((curxo &amp; 0x1) &lt;&lt; 1) - 1;
1174 
1175                         if ((sum &amp; 0x1) != 0) {
1176                             // TODO: perform line clipping on left-right sides
1177                             // to avoid such bound checks:
1178                             x0 = (prev &gt; bboxx0) ? prev : bboxx0;
1179                             x1 = (curx &lt; bboxx1) ? curx : bboxx1;
1180 
1181                             if (x0 &lt; x1) {
1182                                 x0 -= bboxx0; // turn x0, x1 from coords to indices
1183                                 x1 -= bboxx0; // in the alpha array.
1184 
1185                                 pix_x      =  x0      &gt;&gt; _SUBPIXEL_LG_POSITIONS_X;
1186                                 pix_xmaxm1 = (x1 - 1) &gt;&gt; _SUBPIXEL_LG_POSITIONS_X;
1187 
1188                                 if (pix_x == pix_xmaxm1) {
1189                                     // Start and end in same pixel
1190                                     tmp = (x1 - x0); // number of subpixels
1191                                     _alpha[pix_x    ] += tmp;
1192                                     _alpha[pix_x + 1] -= tmp;
1193 
1194                                     if (useBlkFlags) {
1195                                         // flag used blocks:
1196                                         _blkFlags[pix_x &gt;&gt; _BLK_SIZE_LG] = 1;
1197                                     }
1198                                 } else {
1199                                     tmp = (x0 &amp; _SUBPIXEL_MASK_X);
1200                                     _alpha[pix_x    ]
1201                                         += (_SUBPIXEL_POSITIONS_X - tmp);
1202                                     _alpha[pix_x + 1]
1203                                         += tmp;
1204 
1205                                     pix_xmax = x1 &gt;&gt; _SUBPIXEL_LG_POSITIONS_X;
1206 
1207                                     tmp = (x1 &amp; _SUBPIXEL_MASK_X);
1208                                     _alpha[pix_xmax    ]
1209                                         -= (_SUBPIXEL_POSITIONS_X - tmp);
1210                                     _alpha[pix_xmax + 1]
1211                                         -= tmp;
1212 
1213                                     if (useBlkFlags) {
1214                                         // flag used blocks:
1215                                         _blkFlags[pix_x    &gt;&gt; _BLK_SIZE_LG] = 1;
1216                                         _blkFlags[pix_xmax &gt;&gt; _BLK_SIZE_LG] = 1;
1217                                     }
1218                                 }
1219                             }
1220                         }
1221 
1222                         sum += crorientation;
1223                         prev = curx;
1224                     }
1225                 } else {
1226                     // Non-zero winding rule: optimize that case (default)
1227                     // and avoid processing intermediate crossings
1228                     for (i = 1, sum = 0;; i++) {
1229                         sum += crorientation;
1230 
1231                         if (sum != 0) {
1232                             // prev = min(curx)
1233                             if (prev &gt; curx) {
1234                                 prev = curx;
1235                             }
1236                         } else {
1237                             // TODO: perform line clipping on left-right sides
1238                             // to avoid such bound checks:
1239                             x0 = (prev &gt; bboxx0) ? prev : bboxx0;
1240                             x1 = (curx &lt; bboxx1) ? curx : bboxx1;
1241 
1242                             if (x0 &lt; x1) {
1243                                 x0 -= bboxx0; // turn x0, x1 from coords to indices
1244                                 x1 -= bboxx0; // in the alpha array.
1245 
1246                                 pix_x      =  x0      &gt;&gt; _SUBPIXEL_LG_POSITIONS_X;
1247                                 pix_xmaxm1 = (x1 - 1) &gt;&gt; _SUBPIXEL_LG_POSITIONS_X;
1248 
1249                                 if (pix_x == pix_xmaxm1) {
1250                                     // Start and end in same pixel
1251                                     tmp = (x1 - x0); // number of subpixels
1252                                     _alpha[pix_x    ] += tmp;
1253                                     _alpha[pix_x + 1] -= tmp;
1254 
1255                                     if (useBlkFlags) {
1256                                         // flag used blocks:
1257                                         _blkFlags[pix_x &gt;&gt; _BLK_SIZE_LG] = 1;
1258                                     }
1259                                 } else {
1260                                     tmp = (x0 &amp; _SUBPIXEL_MASK_X);
1261                                     _alpha[pix_x    ]
1262                                         += (_SUBPIXEL_POSITIONS_X - tmp);
1263                                     _alpha[pix_x + 1]
1264                                         += tmp;
1265 
1266                                     pix_xmax = x1 &gt;&gt; _SUBPIXEL_LG_POSITIONS_X;
1267 
1268                                     tmp = (x1 &amp; _SUBPIXEL_MASK_X);
1269                                     _alpha[pix_xmax    ]
1270                                         -= (_SUBPIXEL_POSITIONS_X - tmp);
1271                                     _alpha[pix_xmax + 1]
1272                                         -= tmp;
1273 
1274                                     if (useBlkFlags) {
1275                                         // flag used blocks:
1276                                         _blkFlags[pix_x    &gt;&gt; _BLK_SIZE_LG] = 1;
1277                                         _blkFlags[pix_xmax &gt;&gt; _BLK_SIZE_LG] = 1;
1278                                     }
1279                                 }
1280                             }
1281                             prev = _MAX_VALUE;
1282                         }
1283 
1284                         if (i == numCrossings) {
1285                             break;
1286                         }
1287 
1288                         curxo = _crossings[i];
1289                         curx  =  curxo &gt;&gt; 1;
1290                         // to turn {0, 1} into {-1, 1}, multiply by 2 and subtract 1.
1291                         // last bit contains orientation (0 or 1)
1292                         crorientation = ((curxo &amp; 0x1) &lt;&lt; 1) - 1;
1293                     }
1294                 }
1295             } // numCrossings &gt; 0
1296 
1297             // even if this last row had no crossings, alpha will be zeroed
1298             // from the last emitRow call. But this doesn't matter because
1299             // maxX &lt; minX, so no row will be emitted to the MarlinCache.
1300             if ((y &amp; _SUBPIXEL_MASK_Y) == _SUBPIXEL_MASK_Y) {
1301                 lastY = y &gt;&gt; _SUBPIXEL_LG_POSITIONS_Y;
1302 
1303                 // convert subpixel to pixel coordinate within boundaries:
1304                 minX = FloatMath.max(minX, bboxx0) &gt;&gt; _SUBPIXEL_LG_POSITIONS_X;
1305                 maxX = FloatMath.min(maxX, bboxx1) &gt;&gt; _SUBPIXEL_LG_POSITIONS_X;
1306 
1307                 if (maxX &gt;= minX) {
1308                     // note: alpha array will be zeroed by copyAARow()
1309                     // +2 because alpha [pix_minX; pix_maxX+1]
1310                     // fix range [x0; x1[
1311                     copyAARow(_alpha, lastY, minX, maxX + 2, useBlkFlags);
1312 
1313                     // speculative for next pixel row (scanline coherence):
1314                     if (_enableBlkFlagsHeuristics) {
1315                         // Use block flags if large pixel span and few crossings:
1316                         // ie mean(distance between crossings) is larger than
1317                         // 1 block size;
1318 
1319                         // fast check width:
1320                         maxX -= minX;
1321 
1322                         // if stroking: numCrossings /= 2
1323                         // =&gt; shift numCrossings by 1
1324                         // condition = (width / (numCrossings - 1)) &gt; blockSize
1325                         useBlkFlags = (maxX &gt; _BLK_SIZE) &amp;&amp; (maxX &gt;
1326                             (((numCrossings &gt;&gt; stroking) - 1) &lt;&lt; _BLK_SIZE_LG));
1327 
1328                         if (DO_STATS) {
1329                             tmp = FloatMath.max(1,
1330                                     ((numCrossings &gt;&gt; stroking) - 1));
1331                             rdrCtx.stats.hist_tile_generator_encoding_dist
1332                                 .add(maxX / tmp);
1333                         }
1334                     }
1335                 } else {
1336                     _cache.clearAARow(lastY);
1337                 }
1338                 minX = _MAX_VALUE;
1339                 maxX = _MIN_VALUE;
1340             }
1341         } // scan line iterator
1342 
1343         // Emit final row
1344         y--;
1345         y &gt;&gt;= _SUBPIXEL_LG_POSITIONS_Y;
1346 
1347         // convert subpixel to pixel coordinate within boundaries:
1348         minX = FloatMath.max(minX, bboxx0) &gt;&gt; _SUBPIXEL_LG_POSITIONS_X;
1349         maxX = FloatMath.min(maxX, bboxx1) &gt;&gt; _SUBPIXEL_LG_POSITIONS_X;
1350 
1351         if (maxX &gt;= minX) {
1352             // note: alpha array will be zeroed by copyAARow()
1353             // +2 because alpha [pix_minX; pix_maxX+1]
1354             // fix range [x0; x1[
1355             copyAARow(_alpha, y, minX, maxX + 2, useBlkFlags);
1356         } else if (y != lastY) {
1357             _cache.clearAARow(y);
1358         }
1359 
1360         // update member:
1361         edgeCount = numCrossings;
1362         prevUseBlkFlags = useBlkFlags;
1363 
1364         if (DO_STATS) {
1365             // update max used mark
1366             activeEdgeMaxUsed = _arrayMaxUsed;
1367         }
1368     }
1369 
1370     boolean endRendering() {
1371         if (DO_MONITORS) {
1372             rdrCtx.stats.mon_rdr_endRendering.start();
1373         }
1374         if (edgeMinY == Integer.MAX_VALUE) {
1375             return false; // undefined edges bounds
1376         }
1377 
1378         final int _boundsMinY = boundsMinY;
1379         final int _boundsMaxY = boundsMaxY;
1380 
1381         // bounds as inclusive intervals
1382         final int spminX = FloatMath.max(FloatMath.ceil_int(edgeMinX - 0.5f), boundsMinX);
1383         final int spmaxX = FloatMath.min(FloatMath.ceil_int(edgeMaxX - 0.5f), boundsMaxX - 1);
1384 
1385         // edge Min/Max Y are already rounded to subpixels within bounds:
1386         final int spminY = edgeMinY;
1387         final int spmaxY;
1388         int maxY = edgeMaxY;
1389 
1390         if (maxY &lt;= _boundsMaxY - 1) {
1391             spmaxY = maxY;
1392         } else {
1393             spmaxY = _boundsMaxY - 1;
1394             maxY   = _boundsMaxY;
1395         }
1396         buckets_minY = spminY - _boundsMinY;
1397         buckets_maxY = maxY   - _boundsMinY;
1398 
1399         if (DO_LOG_BOUNDS) {
1400             MarlinUtils.logInfo("edgesXY = [" + edgeMinX + " ... " + edgeMaxX
1401                                 + "][" + edgeMinY + " ... " + edgeMaxY + "]");
1402             MarlinUtils.logInfo("spXY    = [" + spminX + " ... " + spmaxX
1403                                 + "][" + spminY + " ... " + spmaxY + "]");
1404         }
1405 
1406         // test clipping for shapes out of bounds
1407         if ((spminX &gt; spmaxX) || (spminY &gt; spmaxY)) {
1408             return false;
1409         }
1410 
1411         // half open intervals
1412         // inclusive:
1413         final int pminX =  spminX                    &gt;&gt; SUBPIXEL_LG_POSITIONS_X;
1414         // exclusive:
1415         final int pmaxX = (spmaxX + SUBPIXEL_MASK_X) &gt;&gt; SUBPIXEL_LG_POSITIONS_X;
1416         // inclusive:
1417         final int pminY =  spminY                    &gt;&gt; SUBPIXEL_LG_POSITIONS_Y;
1418         // exclusive:
1419         final int pmaxY = (spmaxY + SUBPIXEL_MASK_Y) &gt;&gt; SUBPIXEL_LG_POSITIONS_Y;
1420 
1421         // store BBox to answer ptg.getBBox():
1422         this.cache.init(pminX, pminY, pmaxX, pmaxY, edgeSumDeltaY);
1423 
1424         // Heuristics for using block flags:
1425         if (ENABLE_BLOCK_FLAGS) {
1426             enableBlkFlags = this.cache.useRLE;
1427             prevUseBlkFlags = enableBlkFlags &amp;&amp; !ENABLE_BLOCK_FLAGS_HEURISTICS;
1428 
1429             if (enableBlkFlags) {
1430                 // ensure blockFlags array is large enough:
1431                 // note: +2 to ensure enough space left at end
1432                 final int nxTiles = ((pmaxX - pminX) &gt;&gt; TILE_SIZE_LG) + 2;
1433                 if (nxTiles &gt; INITIAL_ARRAY) {
1434                     blkFlags = blkFlags_ref.getArray(nxTiles);
1435                 }
1436             }
1437         }
1438 
1439         // memorize the rendering bounding box:
1440         /* note: bbox_spminX and bbox_spmaxX must be pixel boundaries
1441            to have correct coverage computation */
1442         // inclusive:
1443         bbox_spminX = pminX &lt;&lt; SUBPIXEL_LG_POSITIONS_X;
1444         // exclusive:
1445         bbox_spmaxX = pmaxX &lt;&lt; SUBPIXEL_LG_POSITIONS_X;
1446         // inclusive:
1447         bbox_spminY = spminY;
1448         // exclusive:
1449         bbox_spmaxY = FloatMath.min(spmaxY + 1, pmaxY &lt;&lt; SUBPIXEL_LG_POSITIONS_Y);
1450 
1451         if (DO_LOG_BOUNDS) {
1452             MarlinUtils.logInfo("pXY       = [" + pminX + " ... " + pmaxX
1453                                 + "[ [" + pminY + " ... " + pmaxY + "[");
1454             MarlinUtils.logInfo("bbox_spXY = [" + bbox_spminX + " ... "
1455                                 + bbox_spmaxX + "[ [" + bbox_spminY + " ... "
1456                                 + bbox_spmaxY + "[");
1457         }
1458 
1459         // Prepare alpha line:
1460         // add 2 to better deal with the last pixel in a pixel row.
1461         final int width = (pmaxX - pminX) + 2;
1462 
1463         // Useful when processing tile line by tile line
1464         if (width &gt; INITIAL_AA_ARRAY) {
1465             if (DO_STATS) {
1466                 rdrCtx.stats.stat_array_renderer_alphaline.add(width);
1467             }
1468             alphaLine = alphaLine_ref.getArray(width);
1469         }
1470 
1471         // process first tile line:
1472         endRendering(pminY);
1473 
1474         return true;
1475     }
1476 
1477     private int bbox_spminX, bbox_spmaxX, bbox_spminY, bbox_spmaxY;
1478 
1479     void endRendering(final int pminY) {
1480         if (DO_MONITORS) {
1481             rdrCtx.stats.mon_rdr_endRendering_Y.start();
1482         }
1483 
1484         final int spminY       = pminY &lt;&lt; SUBPIXEL_LG_POSITIONS_Y;
1485         final int fixed_spminY = FloatMath.max(bbox_spminY, spminY);
1486 
1487         // avoid rendering for last call to nextTile()
1488         if (fixed_spminY &lt; bbox_spmaxY) {
1489             // process a complete tile line ie scanlines for 32 rows
1490             final int spmaxY = FloatMath.min(bbox_spmaxY, spminY + SUBPIXEL_TILE);
1491 
1492             // process tile line [0 - 32]
1493             cache.resetTileLine(pminY);
1494 
1495             // Process only one tile line:
1496             _endRendering(fixed_spminY, spmaxY);
1497         }
1498         if (DO_MONITORS) {
1499             rdrCtx.stats.mon_rdr_endRendering_Y.stop();
1500         }
1501     }
1502 
1503     void copyAARow(final int[] alphaRow,
1504                    final int pix_y, final int pix_from, final int pix_to,
1505                    final boolean useBlockFlags)
1506     {
1507         if (useBlockFlags) {
1508             if (DO_STATS) {
1509                 rdrCtx.stats.hist_tile_generator_encoding.add(1);
1510             }
1511             cache.copyAARowRLE_WithBlockFlags(blkFlags, alphaRow, pix_y, pix_from, pix_to);
1512         } else {
1513             if (DO_STATS) {
1514                 rdrCtx.stats.hist_tile_generator_encoding.add(0);
1515             }
1516             cache.copyAARowNoRLE(alphaRow, pix_y, pix_from, pix_to);
1517         }
1518     }
1519 }
</pre></body></html>
