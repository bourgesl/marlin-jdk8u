<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-13693">13693</a> : <a href="https://bugs.openjdk.java.net/browse/JDK-8180055">8180055</a>: Upgrade the Marlin renderer in Java2D
Summary: added the double-precision variant + MarlinFX backports + Improved MarlinTileGenerator + higher precision of the cubic / quadratic curve
Reviewed-by: flar, pnarayanan</pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2007, 2015, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the "Classpath" exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.java2d.marlin;
  27 
<a name="1" id="anc1"></a>
  28 import sun.awt.geom.PathConsumer2D;
  29 import static sun.java2d.marlin.OffHeapArray.SIZE_INT;
  30 import sun.misc.Unsafe;
  31 
<a name="2" id="anc2"></a><span class="changed">  32 final class Renderer implements PathConsumer2D, MarlinRenderer {</span>
  33 
  34     static final boolean DISABLE_RENDER = false;
  35 
  36     static final boolean ENABLE_BLOCK_FLAGS = MarlinProperties.isUseTileFlags();
  37     static final boolean ENABLE_BLOCK_FLAGS_HEURISTICS = MarlinProperties.isUseTileFlagsWithHeuristics();
  38 
<a name="3" id="anc3"></a><span class="changed">  39     private static final int ALL_BUT_LSB = 0xFFFFFFFE;</span>
<span class="changed">  40     private static final int ERR_STEP_MAX = 0x7FFFFFFF; // = 2^31 - 1</span>
  41 
<a name="4" id="anc4"></a><span class="changed">  42     private static final double POWER_2_TO_32 = 0x1.0p32d;</span>
  43 
  44     // use float to make tosubpix methods faster (no int to float conversion)
<a name="5" id="anc5"></a><span class="changed">  45     static final float SUBPIXEL_SCALE_X = (float) SUBPIXEL_POSITIONS_X;</span>
<span class="changed">  46     static final float SUBPIXEL_SCALE_Y = (float) SUBPIXEL_POSITIONS_Y;</span>
<span class="changed">  47     static final int SUBPIXEL_MASK_X = SUBPIXEL_POSITIONS_X - 1;</span>
<span class="changed">  48     static final int SUBPIXEL_MASK_Y = SUBPIXEL_POSITIONS_Y - 1;</span>


  49 
  50     // number of subpixels corresponding to a tile line
  51     private static final int SUBPIXEL_TILE
<a name="6" id="anc6"></a><span class="changed">  52         = TILE_H &lt;&lt; SUBPIXEL_LG_POSITIONS_Y;</span>
  53 
  54     // 2048 (pixelSize) pixels (height) x 8 subpixels = 64K
  55     static final int INITIAL_BUCKET_ARRAY
  56         = INITIAL_PIXEL_DIM * SUBPIXEL_POSITIONS_Y;
  57 
<a name="7" id="anc7"></a><span class="changed">  58     // crossing capacity = edges count / 4 ~ 1024</span>
<span class="changed">  59     static final int INITIAL_CROSSING_COUNT = INITIAL_EDGES_COUNT &gt;&gt; 2;</span>
  60 
  61     public static final int WIND_EVEN_ODD = 0;
  62     public static final int WIND_NON_ZERO = 1;
  63 
  64     // common to all types of input path segments.
  65     // OFFSET as bytes
  66     // only integer values:
  67     public static final long OFF_CURX_OR  = 0;
  68     public static final long OFF_ERROR    = OFF_CURX_OR  + SIZE_INT;
  69     public static final long OFF_BUMP_X   = OFF_ERROR    + SIZE_INT;
  70     public static final long OFF_BUMP_ERR = OFF_BUMP_X   + SIZE_INT;
  71     public static final long OFF_NEXT     = OFF_BUMP_ERR + SIZE_INT;
  72     public static final long OFF_YMAX     = OFF_NEXT     + SIZE_INT;
  73 
  74     // size of one edge in bytes
  75     public static final int SIZEOF_EDGE_BYTES = (int)(OFF_YMAX + SIZE_INT);
  76 
  77     // curve break into lines
  78     // cubic error in subpixels to decrement step
  79     private static final float CUB_DEC_ERR_SUBPIX
<a name="8" id="anc8"></a><span class="changed">  80         = MarlinProperties.getCubicDecD2() * (NORM_SUBPIXELS / 8.0f); // 1 pixel</span>
  81     // cubic error in subpixels to increment step
  82     private static final float CUB_INC_ERR_SUBPIX
<a name="9" id="anc9"></a><span class="changed">  83         = MarlinProperties.getCubicIncD1() * (NORM_SUBPIXELS / 8.0f); // 0.4 pixel</span>
  84 
<a name="10" id="anc10"></a><span class="changed">  85     // TestNonAARasterization (JDK-8170879): cubics</span>
<span class="changed">  86     // bad paths (59294/100000 == 59,29%, 94335 bad pixels (avg = 1,59), 3966 warnings (avg = 0,07)</span>
<span class="changed">  87 </span>
<span class="changed">  88     // cubic bind length to decrement step</span>
  89     public static final float CUB_DEC_BND
<a name="11" id="anc11"></a><span class="changed">  90         = 8.0f * CUB_DEC_ERR_SUBPIX;</span>
<span class="changed">  91     // cubic bind length to increment step</span>
  92     public static final float CUB_INC_BND
<a name="12" id="anc12"></a><span class="changed">  93         = 8.0f * CUB_INC_ERR_SUBPIX;</span>
  94 
  95     // cubic countlg
  96     public static final int CUB_COUNT_LG = 2;
  97     // cubic count = 2^countlg
  98     private static final int CUB_COUNT = 1 &lt;&lt; CUB_COUNT_LG;
  99     // cubic count^2 = 4^countlg
 100     private static final int CUB_COUNT_2 = 1 &lt;&lt; (2 * CUB_COUNT_LG);
 101     // cubic count^3 = 8^countlg
 102     private static final int CUB_COUNT_3 = 1 &lt;&lt; (3 * CUB_COUNT_LG);
 103     // cubic dt = 1 / count
<a name="13" id="anc13"></a><span class="changed"> 104     private static final float CUB_INV_COUNT = 1.0f / CUB_COUNT;</span>
 105     // cubic dt^2 = 1 / count^2 = 1 / 4^countlg
<a name="14" id="anc14"></a><span class="changed"> 106     private static final float CUB_INV_COUNT_2 = 1.0f / CUB_COUNT_2;</span>
 107     // cubic dt^3 = 1 / count^3 = 1 / 8^countlg
<a name="15" id="anc15"></a><span class="changed"> 108     private static final float CUB_INV_COUNT_3 = 1.0f / CUB_COUNT_3;</span>
 109 
 110     // quad break into lines
 111     // quadratic error in subpixels
 112     private static final float QUAD_DEC_ERR_SUBPIX
<a name="16" id="anc16"></a><span class="changed"> 113         = MarlinProperties.getQuadDecD2() * (NORM_SUBPIXELS / 8.0f); // 0.5 pixel</span>
<span class="changed"> 114 </span>
<span class="changed"> 115     // TestNonAARasterization (JDK-8170879): quads</span>
<span class="changed"> 116     // bad paths (62916/100000 == 62,92%, 103818 bad pixels (avg = 1,65), 6514 warnings (avg = 0,10)</span>
 117 
<a name="17" id="anc17"></a><span class="changed"> 118     // quadratic bind length to decrement step</span>

 119     public static final float QUAD_DEC_BND
<a name="18" id="anc18"></a><span class="changed"> 120         = 8.0f * QUAD_DEC_ERR_SUBPIX;</span>
 121 
 122 //////////////////////////////////////////////////////////////////////////////
 123 //  SCAN LINE
 124 //////////////////////////////////////////////////////////////////////////////
 125     // crossings ie subpixel edge x coordinates
 126     private int[] crossings;
 127     // auxiliary storage for crossings (merge sort)
 128     private int[] aux_crossings;
 129 
 130     // indices into the segment pointer lists. They indicate the "active"
 131     // sublist in the segment lists (the portion of the list that contains
 132     // all the segments that cross the next scan line).
 133     private int edgeCount;
 134     private int[] edgePtrs;
 135     // auxiliary storage for edge pointers (merge sort)
 136     private int[] aux_edgePtrs;
 137 
 138     // max used for both edgePtrs and crossings (stats only)
 139     private int activeEdgeMaxUsed;
 140 
 141     // crossings ref (dirty)
 142     private final IntArrayCache.Reference crossings_ref;
 143     // edgePtrs ref (dirty)
 144     private final IntArrayCache.Reference edgePtrs_ref;
 145     // merge sort initial arrays (large enough to satisfy most usages) (1024)
 146     // aux_crossings ref (dirty)
 147     private final IntArrayCache.Reference aux_crossings_ref;
 148     // aux_edgePtrs ref (dirty)
 149     private final IntArrayCache.Reference aux_edgePtrs_ref;
 150 
 151 //////////////////////////////////////////////////////////////////////////////
 152 //  EDGE LIST
 153 //////////////////////////////////////////////////////////////////////////////
 154     private int edgeMinY = Integer.MAX_VALUE;
 155     private int edgeMaxY = Integer.MIN_VALUE;
 156     private float edgeMinX = Float.POSITIVE_INFINITY;
 157     private float edgeMaxX = Float.NEGATIVE_INFINITY;
 158 
<a name="19" id="anc19"></a><span class="changed"> 159     // edges [ints] stored in off-heap memory</span>
 160     private final OffHeapArray edges;
 161 
 162     private int[] edgeBuckets;
 163     private int[] edgeBucketCounts; // 2*newedges + (1 if pruning needed)
 164     // used range for edgeBuckets / edgeBucketCounts
 165     private int buckets_minY;
 166     private int buckets_maxY;
<a name="20" id="anc20"></a>

 167 
 168     // edgeBuckets ref (clean)
 169     private final IntArrayCache.Reference edgeBuckets_ref;
 170     // edgeBucketCounts ref (clean)
 171     private final IntArrayCache.Reference edgeBucketCounts_ref;
 172 
 173     // Flattens using adaptive forward differencing. This only carries out
 174     // one iteration of the AFD loop. All it does is update AFD variables (i.e.
 175     // X0, Y0, D*[X|Y], COUNT; not variables used for computing scanline crossings).
 176     private void quadBreakIntoLinesAndAdd(float x0, float y0,
 177                                           final Curve c,
 178                                           final float x2, final float y2)
 179     {
 180         int count = 1; // dt = 1 / count
 181 
 182         // maximum(ddX|Y) = norm(dbx, dby) * dt^2 (= 1)
<a name="21" id="anc21"></a><span class="changed"> 183         float maxDD = Math.abs(c.dbx) + Math.abs(c.dby);</span>
 184 
 185         final float _DEC_BND = QUAD_DEC_BND;
 186 
 187         while (maxDD &gt;= _DEC_BND) {
 188             // divide step by half:
<a name="22" id="anc22"></a><span class="changed"> 189             maxDD /= 4.0f; // error divided by 2^2 = 4</span>
 190 
 191             count &lt;&lt;= 1;
 192             if (DO_STATS) {
 193                 rdrCtx.stats.stat_rdr_quadBreak_dec.add(count);
 194             }
 195         }
 196 
 197         int nL = 0; // line count
 198         if (count &gt; 1) {
<a name="23" id="anc23"></a><span class="changed"> 199             final float icount = 1.0f / count; // dt</span>
 200             final float icount2 = icount * icount; // dt^2
 201 
 202             final float ddx = c.dbx * icount2;
 203             final float ddy = c.dby * icount2;
 204             float dx = c.bx * icount2 + c.cx * icount;
 205             float dy = c.by * icount2 + c.cy * icount;
 206 
 207             float x1, y1;
 208 
 209             while (--count &gt; 0) {
 210                 x1 = x0 + dx;
 211                 dx += ddx;
 212                 y1 = y0 + dy;
 213                 dy += ddy;
 214 
 215                 addLine(x0, y0, x1, y1);
 216 
 217                 if (DO_STATS) { nL++; }
 218                 x0 = x1;
 219                 y0 = y1;
 220             }
 221         }
 222         addLine(x0, y0, x2, y2);
 223 
 224         if (DO_STATS) {
 225             rdrCtx.stats.stat_rdr_quadBreak.add(nL + 1);
 226         }
 227     }
 228 
 229     // x0, y0 and x3,y3 are the endpoints of the curve. We could compute these
 230     // using c.xat(0),c.yat(0) and c.xat(1),c.yat(1), but this might introduce
 231     // numerical errors, and our callers already have the exact values.
 232     // Another alternative would be to pass all the control points, and call
 233     // c.set here, but then too many numbers are passed around.
 234     private void curveBreakIntoLinesAndAdd(float x0, float y0,
 235                                            final Curve c,
 236                                            final float x3, final float y3)
 237     {
 238         int count           = CUB_COUNT;
 239         final float icount  = CUB_INV_COUNT;   // dt
 240         final float icount2 = CUB_INV_COUNT_2; // dt^2
 241         final float icount3 = CUB_INV_COUNT_3; // dt^3
 242 
 243         // the dx and dy refer to forward differencing variables, not the last
 244         // coefficients of the "points" polynomial
 245         float dddx, dddy, ddx, ddy, dx, dy;
<a name="24" id="anc24"></a><span class="changed"> 246         dddx = 2.0f * c.dax * icount3;</span>
<span class="changed"> 247         dddy = 2.0f * c.day * icount3;</span>
 248         ddx = dddx + c.dbx * icount2;
 249         ddy = dddy + c.dby * icount2;
 250         dx = c.ax * icount3 + c.bx * icount2 + c.cx * icount;
 251         dy = c.ay * icount3 + c.by * icount2 + c.cy * icount;
 252 
 253         // we use x0, y0 to walk the line
 254         float x1 = x0, y1 = y0;
 255         int nL = 0; // line count
 256 
 257         final float _DEC_BND = CUB_DEC_BND;
 258         final float _INC_BND = CUB_INC_BND;
 259 
 260         while (count &gt; 0) {
 261             // divide step by half:
<a name="25" id="anc25"></a><span class="changed"> 262             while (Math.abs(ddx) + Math.abs(ddy) &gt;= _DEC_BND) {</span>
<span class="changed"> 263                 dddx /= 8.0f;</span>
<span class="changed"> 264                 dddy /= 8.0f;</span>
<span class="changed"> 265                 ddx = ddx / 4.0f - dddx;</span>
<span class="changed"> 266                 ddy = ddy / 4.0f - dddy;</span>
<span class="changed"> 267                 dx = (dx - ddx) / 2.0f;</span>
<span class="changed"> 268                 dy = (dy - ddy) / 2.0f;</span>
 269 
 270                 count &lt;&lt;= 1;
 271                 if (DO_STATS) {
 272                     rdrCtx.stats.stat_rdr_curveBreak_dec.add(count);
 273                 }
 274             }
 275 
 276             // double step:
<a name="26" id="anc26"></a>


 277             // can only do this on even "count" values, because we must divide count by 2
 278             while (count % 2 == 0
<a name="27" id="anc27"></a><span class="changed"> 279                    &amp;&amp; Math.abs(dx) + Math.abs(dy) &lt;= _INC_BND)</span>
 280             {
<a name="28" id="anc28"></a><span class="changed"> 281                 dx = 2.0f * dx + ddx;</span>
<span class="changed"> 282                 dy = 2.0f * dy + ddy;</span>
<span class="changed"> 283                 ddx = 4.0f * (ddx + dddx);</span>
<span class="changed"> 284                 ddy = 4.0f * (ddy + dddy);</span>
<span class="changed"> 285                 dddx *= 8.0f;</span>
<span class="changed"> 286                 dddy *= 8.0f;</span>
 287 
 288                 count &gt;&gt;= 1;
 289                 if (DO_STATS) {
 290                     rdrCtx.stats.stat_rdr_curveBreak_inc.add(count);
 291                 }
 292             }
 293             if (--count &gt; 0) {
 294                 x1 += dx;
 295                 dx += ddx;
 296                 ddx += dddx;
 297                 y1 += dy;
 298                 dy += ddy;
 299                 ddy += dddy;
 300             } else {
 301                 x1 = x3;
 302                 y1 = y3;
 303             }
 304 
 305             addLine(x0, y0, x1, y1);
 306 
 307             if (DO_STATS) { nL++; }
 308             x0 = x1;
 309             y0 = y1;
 310         }
 311         if (DO_STATS) {
 312             rdrCtx.stats.stat_rdr_curveBreak.add(nL);
 313         }
 314     }
 315 
 316     private void addLine(float x1, float y1, float x2, float y2) {
 317         if (DO_MONITORS) {
 318             rdrCtx.stats.mon_rdr_addLine.start();
 319         }
 320         if (DO_STATS) {
 321             rdrCtx.stats.stat_rdr_addLine.add(1);
 322         }
 323         int or = 1; // orientation of the line. 1 if y increases, 0 otherwise.
 324         if (y2 &lt; y1) {
 325             or = 0;
 326             float tmp = y2;
 327             y2 = y1;
 328             y1 = tmp;
 329             tmp = x2;
 330             x2 = x1;
 331             x1 = tmp;
 332         }
 333 
<a name="29" id="anc29"></a><span class="changed"> 334         // convert subpixel coordinates [float] into pixel positions [int]</span>
 335 
 336         // The index of the pixel that holds the next HPC is at ceil(trueY - 0.5)
 337         // Since y1 and y2 are biased by -0.5 in tosubpixy(), this is simply
 338         // ceil(y1) or ceil(y2)
 339         // upper integer (inclusive)
 340         final int firstCrossing = FloatMath.max(FloatMath.ceil_int(y1), boundsMinY);
 341 
 342         // note: use boundsMaxY (last Y exclusive) to compute correct coverage
 343         // upper integer (exclusive)
 344         final int lastCrossing  = FloatMath.min(FloatMath.ceil_int(y2), boundsMaxY);
 345 
 346         /* skip horizontal lines in pixel space and clip edges
 347            out of y range [boundsMinY; boundsMaxY] */
 348         if (firstCrossing &gt;= lastCrossing) {
 349             if (DO_MONITORS) {
 350                 rdrCtx.stats.mon_rdr_addLine.stop();
 351             }
 352             if (DO_STATS) {
 353                 rdrCtx.stats.stat_rdr_addLine_skip.add(1);
 354             }
 355             return;
 356         }
 357 
<a name="30" id="anc30"></a><span class="changed"> 358         // edge min/max X/Y are in subpixel space (half-open interval):</span>
 359         // note: Use integer crossings to ensure consistent range within
 360         // edgeBuckets / edgeBucketCounts arrays in case of NaN values (int = 0)
 361         if (firstCrossing &lt; edgeMinY) {
 362             edgeMinY = firstCrossing;
 363         }
 364         if (lastCrossing &gt; edgeMaxY) {
 365             edgeMaxY = lastCrossing;
 366         }
 367 
 368         // Use double-precision for improved accuracy:
 369         final double x1d   = x1;
 370         final double y1d   = y1;
 371         final double slope = (x1d - x2) / (y1d - y2);
 372 
<a name="31" id="anc31"></a><span class="changed"> 373         if (slope &gt;= 0.0d) { // &lt;==&gt; x1 &lt; x2</span>
 374             if (x1 &lt; edgeMinX) {
 375                 edgeMinX = x1;
 376             }
 377             if (x2 &gt; edgeMaxX) {
 378                 edgeMaxX = x2;
 379             }
 380         } else {
 381             if (x2 &lt; edgeMinX) {
 382                 edgeMinX = x2;
 383             }
 384             if (x1 &gt; edgeMaxX) {
 385                 edgeMaxX = x1;
 386             }
 387         }
 388 
 389         // local variables for performance:
 390         final int _SIZEOF_EDGE_BYTES = SIZEOF_EDGE_BYTES;
 391 
 392         final OffHeapArray _edges = edges;
 393 
 394         // get free pointer (ie length in bytes)
 395         final int edgePtr = _edges.used;
 396 
 397         // use substraction to avoid integer overflow:
 398         if (_edges.length - edgePtr &lt; _SIZEOF_EDGE_BYTES) {
 399             // suppose _edges.length &gt; _SIZEOF_EDGE_BYTES
 400             // so doubling size is enough to add needed bytes
 401             // note: throw IOOB if neededSize &gt; 2Gb:
 402             final long edgeNewSize = ArrayCacheConst.getNewLargeSize(
 403                                         _edges.length,
 404                                         edgePtr + _SIZEOF_EDGE_BYTES);
 405 
 406             if (DO_STATS) {
 407                 rdrCtx.stats.stat_rdr_edges_resizes.add(edgeNewSize);
 408             }
 409             _edges.resize(edgeNewSize);
 410         }
 411 
 412 
 413         final Unsafe _unsafe = OffHeapArray.UNSAFE;
 414         final long SIZE_INT = 4L;
 415         long addr   = _edges.address + edgePtr;
 416 
 417         // The x value must be bumped up to its position at the next HPC we will evaluate.
 418         // "firstcrossing" is the (sub)pixel number where the next crossing occurs
 419         // thus, the actual coordinate of the next HPC is "firstcrossing + 0.5"
 420         // so the Y distance we cover is "firstcrossing + 0.5 - trueY".
 421         // Note that since y1 (and y2) are already biased by -0.5 in tosubpixy(), we have
 422         // y1 = trueY - 0.5
 423         // trueY = y1 + 0.5
 424         // firstcrossing + 0.5 - trueY = firstcrossing + 0.5 - (y1 + 0.5)
 425         //                             = firstcrossing - y1
 426         // The x coordinate at that HPC is then:
 427         // x1_intercept = x1 + (firstcrossing - y1) * slope
 428         // The next VPC is then given by:
 429         // VPC index = ceil(x1_intercept - 0.5), or alternately
 430         // VPC index = floor(x1_intercept - 0.5 + 1 - epsilon)
 431         // epsilon is hard to pin down in floating point, but easy in fixed point, so if
 432         // we convert to fixed point then these operations get easier:
 433         // long x1_fixed = x1_intercept * 2^32;  (fixed point 32.32 format)
 434         // curx = next VPC = fixed_floor(x1_fixed - 2^31 + 2^32 - 1)
 435         //                 = fixed_floor(x1_fixed + 2^31 - 1)
<a name="32" id="anc32"></a><span class="changed"> 436         //                 = fixed_floor(x1_fixed + 0x7FFFFFFF)</span>
<span class="changed"> 437         // and error       = fixed_fract(x1_fixed + 0x7FFFFFFF)</span>
 438         final double x1_intercept = x1d + (firstCrossing - y1d) * slope;
 439 
 440         // inlined scalb(x1_intercept, 32):
 441         final long x1_fixed_biased = ((long) (POWER_2_TO_32 * x1_intercept))
<a name="33" id="anc33"></a><span class="changed"> 442                                      + 0x7FFFFFFFL;</span>
 443         // curx:
 444         // last bit corresponds to the orientation
 445         _unsafe.putInt(addr, (((int) (x1_fixed_biased &gt;&gt; 31L)) &amp; ALL_BUT_LSB) | or);
 446         addr += SIZE_INT;
 447         _unsafe.putInt(addr,  ((int)  x1_fixed_biased) &gt;&gt;&gt; 1);
 448         addr += SIZE_INT;
 449 
 450         // inlined scalb(slope, 32):
 451         final long slope_fixed = (long) (POWER_2_TO_32 * slope);
 452 
 453         // last bit set to 0 to keep orientation:
 454         _unsafe.putInt(addr, (((int) (slope_fixed &gt;&gt; 31L)) &amp; ALL_BUT_LSB));
 455         addr += SIZE_INT;
 456         _unsafe.putInt(addr,  ((int)  slope_fixed) &gt;&gt;&gt; 1);
 457         addr += SIZE_INT;
 458 
 459         final int[] _edgeBuckets      = edgeBuckets;
 460         final int[] _edgeBucketCounts = edgeBucketCounts;
 461 
 462         final int _boundsMinY = boundsMinY;
 463 
 464         // each bucket is a linked list. this method adds ptr to the
 465         // start of the "bucket"th linked list.
 466         final int bucketIdx = firstCrossing - _boundsMinY;
 467 
 468         // pointer from bucket
 469         _unsafe.putInt(addr, _edgeBuckets[bucketIdx]);
 470         addr += SIZE_INT;
<a name="34" id="anc34"></a><span class="changed"> 471         // y max (exclusive)</span>
 472         _unsafe.putInt(addr,  lastCrossing);
 473 
 474         // Update buckets:
 475         // directly the edge struct "pointer"
 476         _edgeBuckets[bucketIdx]       = edgePtr;
 477         _edgeBucketCounts[bucketIdx] += 2; // 1 &lt;&lt; 1
 478         // last bit means edge end
 479         _edgeBucketCounts[lastCrossing - _boundsMinY] |= 0x1;
 480 
<a name="35" id="anc35"></a>


 481         // update free pointer (ie length in bytes)
 482         _edges.used += _SIZEOF_EDGE_BYTES;
 483 
 484         if (DO_MONITORS) {
 485             rdrCtx.stats.mon_rdr_addLine.stop();
 486         }
 487     }
 488 
 489 // END EDGE LIST
 490 //////////////////////////////////////////////////////////////////////////////
 491 
 492     // Cache to store RLE-encoded coverage mask of the current primitive
 493     final MarlinCache cache;
 494 
 495     // Bounds of the drawing region, at subpixel precision.
 496     private int boundsMinX, boundsMinY, boundsMaxX, boundsMaxY;
 497 
 498     // Current winding rule
 499     private int windingRule;
 500 
 501     // Current drawing position, i.e., final point of last segment
 502     private float x0, y0;
 503 
 504     // Position of most recent 'moveTo' command
 505     private float sx0, sy0;
 506 
 507     // per-thread renderer context
 508     final RendererContext rdrCtx;
 509     // dirty curve
 510     private final Curve curve;
 511 
 512     // clean alpha array (zero filled)
 513     private int[] alphaLine;
 514 
 515     // alphaLine ref (clean)
 516     private final IntArrayCache.Reference alphaLine_ref;
 517 
 518     private boolean enableBlkFlags = false;
 519     private boolean prevUseBlkFlags = false;
 520 
 521     /* block flags (0|1) */
 522     private int[] blkFlags;
 523 
 524     // blkFlags ref (clean)
 525     private final IntArrayCache.Reference blkFlags_ref;
 526 
 527     Renderer(final RendererContext rdrCtx) {
 528         this.rdrCtx = rdrCtx;
 529 
 530         this.edges = rdrCtx.newOffHeapArray(INITIAL_EDGES_CAPACITY); // 96K
 531 
 532         this.curve = rdrCtx.curve;
 533 
 534         edgeBuckets_ref      = rdrCtx.newCleanIntArrayRef(INITIAL_BUCKET_ARRAY); // 64K
 535         edgeBucketCounts_ref = rdrCtx.newCleanIntArrayRef(INITIAL_BUCKET_ARRAY); // 64K
 536 
 537         edgeBuckets      = edgeBuckets_ref.initial;
 538         edgeBucketCounts = edgeBucketCounts_ref.initial;
 539 
 540         // 2048 (pixelsize) pixel large
 541         alphaLine_ref = rdrCtx.newCleanIntArrayRef(INITIAL_AA_ARRAY); // 8K
 542         alphaLine     = alphaLine_ref.initial;
 543 
 544         this.cache = rdrCtx.cache;
 545 
 546         crossings_ref     = rdrCtx.newDirtyIntArrayRef(INITIAL_CROSSING_COUNT); // 2K
 547         aux_crossings_ref = rdrCtx.newDirtyIntArrayRef(INITIAL_CROSSING_COUNT); // 2K
 548         edgePtrs_ref      = rdrCtx.newDirtyIntArrayRef(INITIAL_CROSSING_COUNT); // 2K
 549         aux_edgePtrs_ref  = rdrCtx.newDirtyIntArrayRef(INITIAL_CROSSING_COUNT); // 2K
 550 
 551         crossings     = crossings_ref.initial;
 552         aux_crossings = aux_crossings_ref.initial;
 553         edgePtrs      = edgePtrs_ref.initial;
 554         aux_edgePtrs  = aux_edgePtrs_ref.initial;
 555 
 556         blkFlags_ref = rdrCtx.newCleanIntArrayRef(INITIAL_ARRAY); // 1K = 1 tile line
 557         blkFlags     = blkFlags_ref.initial;
 558     }
 559 
 560     Renderer init(final int pix_boundsX, final int pix_boundsY,
 561                   final int pix_boundsWidth, final int pix_boundsHeight,
<a name="36" id="anc36"></a><span class="changed"> 562                   final int windingRule)</span>
<span class="changed"> 563     {</span>
 564         this.windingRule = windingRule;
 565 
 566         // bounds as half-open intervals: minX &lt;= x &lt; maxX and minY &lt;= y &lt; maxY
 567         this.boundsMinX =  pix_boundsX &lt;&lt; SUBPIXEL_LG_POSITIONS_X;
 568         this.boundsMaxX =
 569             (pix_boundsX + pix_boundsWidth) &lt;&lt; SUBPIXEL_LG_POSITIONS_X;
 570         this.boundsMinY =  pix_boundsY &lt;&lt; SUBPIXEL_LG_POSITIONS_Y;
 571         this.boundsMaxY =
 572             (pix_boundsY + pix_boundsHeight) &lt;&lt; SUBPIXEL_LG_POSITIONS_Y;
 573 
 574         if (DO_LOG_BOUNDS) {
 575             MarlinUtils.logInfo("boundsXY = [" + boundsMinX + " ... "
 576                                 + boundsMaxX + "[ [" + boundsMinY + " ... "
 577                                 + boundsMaxY + "[");
 578         }
 579 
 580         // see addLine: ceil(boundsMaxY) =&gt; boundsMaxY + 1
 581         // +1 for edgeBucketCounts
 582         final int edgeBucketsLength = (boundsMaxY - boundsMinY) + 1;
 583 
 584         if (edgeBucketsLength &gt; INITIAL_BUCKET_ARRAY) {
 585             if (DO_STATS) {
 586                 rdrCtx.stats.stat_array_renderer_edgeBuckets
 587                     .add(edgeBucketsLength);
 588                 rdrCtx.stats.stat_array_renderer_edgeBucketCounts
 589                     .add(edgeBucketsLength);
 590             }
 591             edgeBuckets = edgeBuckets_ref.getArray(edgeBucketsLength);
 592             edgeBucketCounts = edgeBucketCounts_ref.getArray(edgeBucketsLength);
 593         }
 594 
 595         edgeMinY = Integer.MAX_VALUE;
 596         edgeMaxY = Integer.MIN_VALUE;
 597         edgeMinX = Float.POSITIVE_INFINITY;
 598         edgeMaxX = Float.NEGATIVE_INFINITY;
 599 
 600         // reset used mark:
 601         edgeCount = 0;
 602         activeEdgeMaxUsed = 0;
 603         edges.used = 0;
 604 
<a name="37" id="anc37"></a>

 605         return this; // fluent API
 606     }
 607 
 608     /**
 609      * Disposes this renderer and recycle it clean up before reusing this instance
 610      */
 611     void dispose() {
 612         if (DO_STATS) {
 613             rdrCtx.stats.stat_rdr_activeEdges.add(activeEdgeMaxUsed);
 614             rdrCtx.stats.stat_rdr_edges.add(edges.used);
 615             rdrCtx.stats.stat_rdr_edges_count.add(edges.used / SIZEOF_EDGE_BYTES);
 616             rdrCtx.stats.hist_rdr_edges_count.add(edges.used / SIZEOF_EDGE_BYTES);
 617             rdrCtx.stats.totalOffHeap += edges.length;
 618         }
 619         // Return arrays:
 620         crossings = crossings_ref.putArray(crossings);
 621         aux_crossings = aux_crossings_ref.putArray(aux_crossings);
 622 
 623         edgePtrs = edgePtrs_ref.putArray(edgePtrs);
 624         aux_edgePtrs = aux_edgePtrs_ref.putArray(aux_edgePtrs);
 625 
 626         alphaLine = alphaLine_ref.putArray(alphaLine, 0, 0); // already zero filled
 627         blkFlags  = blkFlags_ref.putArray(blkFlags, 0, 0); // already zero filled
 628 
 629         if (edgeMinY != Integer.MAX_VALUE) {
 630             // if context is maked as DIRTY:
 631             if (rdrCtx.dirty) {
 632                 // may happen if an exception if thrown in the pipeline processing:
 633                 // clear completely buckets arrays:
 634                 buckets_minY = 0;
 635                 buckets_maxY = boundsMaxY - boundsMinY;
 636             }
 637             // clear only used part
 638             edgeBuckets = edgeBuckets_ref.putArray(edgeBuckets, buckets_minY,
 639                                                                 buckets_maxY);
 640             edgeBucketCounts = edgeBucketCounts_ref.putArray(edgeBucketCounts,
 641                                                              buckets_minY,
 642                                                              buckets_maxY + 1);
 643         } else {
 644             // unused arrays
 645             edgeBuckets = edgeBuckets_ref.putArray(edgeBuckets, 0, 0);
 646             edgeBucketCounts = edgeBucketCounts_ref.putArray(edgeBucketCounts, 0, 0);
 647         }
 648 
 649         // At last: resize back off-heap edges to initial size
 650         if (edges.length != INITIAL_EDGES_CAPACITY) {
 651             // note: may throw OOME:
 652             edges.resize(INITIAL_EDGES_CAPACITY);
 653         }
 654         if (DO_CLEAN_DIRTY) {
 655             // Force zero-fill dirty arrays:
 656             edges.fill(BYTE_0);
 657         }
 658         if (DO_MONITORS) {
 659             rdrCtx.stats.mon_rdr_endRendering.stop();
 660         }
<a name="38" id="anc38"></a><span class="new"> 661         // recycle the RendererContext instance</span>
<span class="new"> 662         MarlinRenderingEngine.returnRendererContext(rdrCtx);</span>
 663     }
 664 
 665     private static float tosubpixx(final float pix_x) {
<a name="39" id="anc39"></a><span class="changed"> 666         return SUBPIXEL_SCALE_X * pix_x;</span>
 667     }
 668 
 669     private static float tosubpixy(final float pix_y) {
 670         // shift y by -0.5 for fast ceil(y - 0.5):
<a name="40" id="anc40"></a><span class="changed"> 671         return SUBPIXEL_SCALE_Y * pix_y - 0.5f;</span>
 672     }
 673 
 674     @Override
 675     public void moveTo(float pix_x0, float pix_y0) {
 676         closePath();
 677         final float sx = tosubpixx(pix_x0);
 678         final float sy = tosubpixy(pix_y0);
 679         this.sx0 = sx;
 680         this.sy0 = sy;
 681         this.x0 = sx;
 682         this.y0 = sy;
 683     }
 684 
 685     @Override
 686     public void lineTo(float pix_x1, float pix_y1) {
 687         final float x1 = tosubpixx(pix_x1);
 688         final float y1 = tosubpixy(pix_y1);
 689         addLine(x0, y0, x1, y1);
 690         x0 = x1;
 691         y0 = y1;
 692     }
 693 
 694     @Override
 695     public void curveTo(float x1, float y1,
 696                         float x2, float y2,
 697                         float x3, float y3)
 698     {
 699         final float xe = tosubpixx(x3);
 700         final float ye = tosubpixy(y3);
 701         curve.set(x0, y0, tosubpixx(x1), tosubpixy(y1),
 702                           tosubpixx(x2), tosubpixy(y2), xe, ye);
 703         curveBreakIntoLinesAndAdd(x0, y0, curve, xe, ye);
 704         x0 = xe;
 705         y0 = ye;
 706     }
 707 
 708     @Override
 709     public void quadTo(float x1, float y1, float x2, float y2) {
 710         final float xe = tosubpixx(x2);
 711         final float ye = tosubpixy(y2);
 712         curve.set(x0, y0, tosubpixx(x1), tosubpixy(y1), xe, ye);
 713         quadBreakIntoLinesAndAdd(x0, y0, curve, xe, ye);
 714         x0 = xe;
 715         y0 = ye;
 716     }
 717 
 718     @Override
 719     public void closePath() {
 720         addLine(x0, y0, sx0, sy0);
 721         x0 = sx0;
 722         y0 = sy0;
 723     }
 724 
 725     @Override
 726     public void pathDone() {
 727         closePath();
 728     }
 729 
 730     @Override
 731     public long getNativeConsumer() {
 732         throw new InternalError("Renderer does not use a native consumer.");
 733     }
 734 
 735     private void _endRendering(final int ymin, final int ymax) {
 736         if (DISABLE_RENDER) {
 737             return;
 738         }
 739 
 740         // Get X bounds as true pixel boundaries to compute correct pixel coverage:
 741         final int bboxx0 = bbox_spminX;
 742         final int bboxx1 = bbox_spmaxX;
 743 
 744         final boolean windingRuleEvenOdd = (windingRule == WIND_EVEN_ODD);
 745 
 746         // Useful when processing tile line by tile line
 747         final int[] _alpha = alphaLine;
 748 
 749         // local vars (performance):
 750         final MarlinCache _cache = cache;
 751         final OffHeapArray _edges = edges;
 752         final int[] _edgeBuckets = edgeBuckets;
 753         final int[] _edgeBucketCounts = edgeBucketCounts;
 754 
 755         int[] _crossings = this.crossings;
 756         int[] _edgePtrs  = this.edgePtrs;
 757 
 758         // merge sort auxiliary storage:
 759         int[] _aux_crossings = this.aux_crossings;
 760         int[] _aux_edgePtrs  = this.aux_edgePtrs;
 761 
 762         // copy constants:
 763         final long _OFF_ERROR    = OFF_ERROR;
 764         final long _OFF_BUMP_X   = OFF_BUMP_X;
 765         final long _OFF_BUMP_ERR = OFF_BUMP_ERR;
 766 
 767         final long _OFF_NEXT     = OFF_NEXT;
 768         final long _OFF_YMAX     = OFF_YMAX;
 769 
 770         final int _ALL_BUT_LSB   = ALL_BUT_LSB;
 771         final int _ERR_STEP_MAX  = ERR_STEP_MAX;
 772 
 773         // unsafe I/O:
 774         final Unsafe _unsafe = OffHeapArray.UNSAFE;
 775         final long    addr0  = _edges.address;
 776         long addr;
 777         final int _SUBPIXEL_LG_POSITIONS_X = SUBPIXEL_LG_POSITIONS_X;
 778         final int _SUBPIXEL_LG_POSITIONS_Y = SUBPIXEL_LG_POSITIONS_Y;
 779         final int _SUBPIXEL_MASK_X = SUBPIXEL_MASK_X;
 780         final int _SUBPIXEL_MASK_Y = SUBPIXEL_MASK_Y;
 781         final int _SUBPIXEL_POSITIONS_X = SUBPIXEL_POSITIONS_X;
 782 
 783         final int _MIN_VALUE = Integer.MIN_VALUE;
 784         final int _MAX_VALUE = Integer.MAX_VALUE;
 785 
 786         // Now we iterate through the scanlines. We must tell emitRow the coord
 787         // of the first non-transparent pixel, so we must keep accumulators for
 788         // the first and last pixels of the section of the current pixel row
 789         // that we will emit.
 790         // We also need to accumulate pix_bbox, but the iterator does it
 791         // for us. We will just get the values from it once this loop is done
 792         int minX = _MAX_VALUE;
 793         int maxX = _MIN_VALUE;
 794 
 795         int y = ymin;
 796         int bucket = y - boundsMinY;
 797 
 798         int numCrossings = this.edgeCount;
 799         int edgePtrsLen = _edgePtrs.length;
 800         int crossingsLen = _crossings.length;
 801         int _arrayMaxUsed = activeEdgeMaxUsed;
 802         int ptrLen = 0, newCount, ptrEnd;
 803 
 804         int bucketcount, i, j, ecur;
 805         int cross, lastCross;
 806         int x0, x1, tmp, sum, prev, curx, curxo, crorientation, err;
 807         int pix_x, pix_xmaxm1, pix_xmax;
 808 
 809         int low, high, mid, prevNumCrossings;
 810         boolean useBinarySearch;
 811 
 812         final int[] _blkFlags = blkFlags;
 813         final int _BLK_SIZE_LG = BLOCK_SIZE_LG;
 814         final int _BLK_SIZE = BLOCK_SIZE;
 815 
 816         final boolean _enableBlkFlagsHeuristics = ENABLE_BLOCK_FLAGS_HEURISTICS &amp;&amp; this.enableBlkFlags;
 817 
 818         // Use block flags if large pixel span and few crossings:
 819         // ie mean(distance between crossings) is high
 820         boolean useBlkFlags = this.prevUseBlkFlags;
 821 
 822         final int stroking = rdrCtx.stroking;
 823 
 824         int lastY = -1; // last emited row
 825 
 826 
 827         // Iteration on scanlines
 828         for (; y &lt; ymax; y++, bucket++) {
 829             // --- from former ScanLineIterator.next()
 830             bucketcount = _edgeBucketCounts[bucket];
 831 
 832             // marker on previously sorted edges:
 833             prevNumCrossings = numCrossings;
 834 
 835             // bucketCount indicates new edge / edge end:
 836             if (bucketcount != 0) {
 837                 if (DO_STATS) {
 838                     rdrCtx.stats.stat_rdr_activeEdges_updates.add(numCrossings);
 839                 }
 840 
 841                 // last bit set to 1 means that edges ends
 842                 if ((bucketcount &amp; 0x1) != 0) {
 843                     // eviction in active edge list
 844                     // cache edges[] address + offset
 845                     addr = addr0 + _OFF_YMAX;
 846 
 847                     for (i = 0, newCount = 0; i &lt; numCrossings; i++) {
 848                         // get the pointer to the edge
 849                         ecur = _edgePtrs[i];
 850                         // random access so use unsafe:
 851                         if (_unsafe.getInt(addr + ecur) &gt; y) {
 852                             _edgePtrs[newCount++] = ecur;
 853                         }
 854                     }
 855                     // update marker on sorted edges minus removed edges:
 856                     prevNumCrossings = numCrossings = newCount;
 857                 }
 858 
 859                 ptrLen = bucketcount &gt;&gt; 1; // number of new edge
 860 
 861                 if (ptrLen != 0) {
 862                     if (DO_STATS) {
 863                         rdrCtx.stats.stat_rdr_activeEdges_adds.add(ptrLen);
 864                         if (ptrLen &gt; 10) {
 865                             rdrCtx.stats.stat_rdr_activeEdges_adds_high.add(ptrLen);
 866                         }
 867                     }
 868                     ptrEnd = numCrossings + ptrLen;
 869 
 870                     if (edgePtrsLen &lt; ptrEnd) {
 871                         if (DO_STATS) {
 872                             rdrCtx.stats.stat_array_renderer_edgePtrs.add(ptrEnd);
 873                         }
 874                         this.edgePtrs = _edgePtrs
 875                             = edgePtrs_ref.widenArray(_edgePtrs, numCrossings,
 876                                                       ptrEnd);
 877 
 878                         edgePtrsLen = _edgePtrs.length;
 879                         // Get larger auxiliary storage:
 880                         aux_edgePtrs_ref.putArray(_aux_edgePtrs);
 881 
 882                         // use ArrayCache.getNewSize() to use the same growing
 883                         // factor than widenArray():
 884                         if (DO_STATS) {
 885                             rdrCtx.stats.stat_array_renderer_aux_edgePtrs.add(ptrEnd);
 886                         }
 887                         this.aux_edgePtrs = _aux_edgePtrs
 888                             = aux_edgePtrs_ref.getArray(
 889                                 ArrayCacheConst.getNewSize(numCrossings, ptrEnd)
 890                             );
 891                     }
 892 
 893                     // cache edges[] address + offset
 894                     addr = addr0 + _OFF_NEXT;
 895 
 896                     // add new edges to active edge list:
 897                     for (ecur = _edgeBuckets[bucket];
 898                          numCrossings &lt; ptrEnd; numCrossings++)
 899                     {
 900                         // store the pointer to the edge
 901                         _edgePtrs[numCrossings] = ecur;
 902                         // random access so use unsafe:
 903                         ecur = _unsafe.getInt(addr + ecur);
 904                     }
 905 
 906                     if (crossingsLen &lt; numCrossings) {
 907                         // Get larger array:
 908                         crossings_ref.putArray(_crossings);
 909 
 910                         if (DO_STATS) {
 911                             rdrCtx.stats.stat_array_renderer_crossings
 912                                 .add(numCrossings);
 913                         }
 914                         this.crossings = _crossings
 915                             = crossings_ref.getArray(numCrossings);
 916 
 917                         // Get larger auxiliary storage:
 918                         aux_crossings_ref.putArray(_aux_crossings);
 919 
 920                         if (DO_STATS) {
 921                             rdrCtx.stats.stat_array_renderer_aux_crossings
 922                                 .add(numCrossings);
 923                         }
 924                         this.aux_crossings = _aux_crossings
 925                             = aux_crossings_ref.getArray(numCrossings);
 926 
 927                         crossingsLen = _crossings.length;
 928                     }
 929                     if (DO_STATS) {
 930                         // update max used mark
 931                         if (numCrossings &gt; _arrayMaxUsed) {
 932                             _arrayMaxUsed = numCrossings;
 933                         }
 934                     }
 935                 } // ptrLen != 0
 936             } // bucketCount != 0
 937 
 938 
 939             if (numCrossings != 0) {
 940                 /*
 941                  * thresholds to switch to optimized merge sort
 942                  * for newly added edges + final merge pass.
 943                  */
 944                 if ((ptrLen &lt; 10) || (numCrossings &lt; 40)) {
 945                     if (DO_STATS) {
 946                         rdrCtx.stats.hist_rdr_crossings.add(numCrossings);
 947                         rdrCtx.stats.hist_rdr_crossings_adds.add(ptrLen);
 948                     }
 949 
 950                     /*
 951                      * threshold to use binary insertion sort instead of
 952                      * straight insertion sort (to reduce minimize comparisons).
 953                      */
 954                     useBinarySearch = (numCrossings &gt;= 20);
 955 
 956                     // if small enough:
 957                     lastCross = _MIN_VALUE;
 958 
 959                     for (i = 0; i &lt; numCrossings; i++) {
 960                         // get the pointer to the edge
 961                         ecur = _edgePtrs[i];
 962 
<a name="41" id="anc41"></a><span class="changed"> 963                         /* convert subpixel coordinates into pixel</span>
<span class="changed"> 964                             positions for coming scanline */</span>
 965                         /* note: it is faster to always update edges even
 966                            if it is removed from AEL for coming or last scanline */
 967 
 968                         // random access so use unsafe:
 969                         addr = addr0 + ecur; // ecur + OFF_F_CURX
 970 
 971                         // get current crossing:
 972                         curx = _unsafe.getInt(addr);
 973 
 974                         // update crossing with orientation at last bit:
 975                         cross = curx;
 976 
 977                         // Increment x using DDA (fixed point):
 978                         curx += _unsafe.getInt(addr + _OFF_BUMP_X);
 979 
 980                         // Increment error:
 981                         err  =  _unsafe.getInt(addr + _OFF_ERROR)
 982                               + _unsafe.getInt(addr + _OFF_BUMP_ERR);
 983 
 984                         // Manual carry handling:
 985                         // keep sign and carry bit only and ignore last bit (preserve orientation):
 986                         _unsafe.putInt(addr,               curx - ((err &gt;&gt; 30) &amp; _ALL_BUT_LSB));
 987                         _unsafe.putInt(addr + _OFF_ERROR, (err &amp; _ERR_STEP_MAX));
 988 
 989                         if (DO_STATS) {
 990                             rdrCtx.stats.stat_rdr_crossings_updates.add(numCrossings);
 991                         }
 992 
 993                         // insertion sort of crossings:
 994                         if (cross &lt; lastCross) {
 995                             if (DO_STATS) {
 996                                 rdrCtx.stats.stat_rdr_crossings_sorts.add(i);
 997                             }
 998 
 999                             /* use binary search for newly added edges
1000                                in crossings if arrays are large enough */
1001                             if (useBinarySearch &amp;&amp; (i &gt;= prevNumCrossings)) {
1002                                 if (DO_STATS) {
1003                                     rdrCtx.stats.stat_rdr_crossings_bsearch.add(i);
1004                                 }
1005                                 low = 0;
1006                                 high = i - 1;
1007 
1008                                 do {
1009                                     // note: use signed shift (not &gt;&gt;&gt;) for performance
1010                                     // as indices are small enough to exceed Integer.MAX_VALUE
1011                                     mid = (low + high) &gt;&gt; 1;
1012 
1013                                     if (_crossings[mid] &lt; cross) {
1014                                         low = mid + 1;
1015                                     } else {
1016                                         high = mid - 1;
1017                                     }
1018                                 } while (low &lt;= high);
1019 
1020                                 for (j = i - 1; j &gt;= low; j--) {
1021                                     _crossings[j + 1] = _crossings[j];
1022                                     _edgePtrs [j + 1] = _edgePtrs[j];
1023                                 }
1024                                 _crossings[low] = cross;
1025                                 _edgePtrs [low] = ecur;
1026 
1027                             } else {
1028                                 j = i - 1;
1029                                 _crossings[i] = _crossings[j];
1030                                 _edgePtrs[i] = _edgePtrs[j];
1031 
1032                                 while ((--j &gt;= 0) &amp;&amp; (_crossings[j] &gt; cross)) {
1033                                     _crossings[j + 1] = _crossings[j];
1034                                     _edgePtrs [j + 1] = _edgePtrs[j];
1035                                 }
1036                                 _crossings[j + 1] = cross;
1037                                 _edgePtrs [j + 1] = ecur;
1038                             }
1039 
1040                         } else {
1041                             _crossings[i] = lastCross = cross;
1042                         }
1043                     }
1044                 } else {
1045                     if (DO_STATS) {
1046                         rdrCtx.stats.stat_rdr_crossings_msorts.add(numCrossings);
1047                         rdrCtx.stats.hist_rdr_crossings_ratio
1048                             .add((1000 * ptrLen) / numCrossings);
1049                         rdrCtx.stats.hist_rdr_crossings_msorts.add(numCrossings);
1050                         rdrCtx.stats.hist_rdr_crossings_msorts_adds.add(ptrLen);
1051                     }
1052 
1053                     // Copy sorted data in auxiliary arrays
1054                     // and perform insertion sort on almost sorted data
1055                     // (ie i &lt; prevNumCrossings):
1056 
1057                     lastCross = _MIN_VALUE;
1058 
1059                     for (i = 0; i &lt; numCrossings; i++) {
1060                         // get the pointer to the edge
1061                         ecur = _edgePtrs[i];
1062 
<a name="42" id="anc42"></a><span class="changed">1063                         /* convert subpixel coordinates into pixel</span>
<span class="changed">1064                             positions for coming scanline */</span>
1065                         /* note: it is faster to always update edges even
1066                            if it is removed from AEL for coming or last scanline */
1067 
1068                         // random access so use unsafe:
1069                         addr = addr0 + ecur; // ecur + OFF_F_CURX
1070 
1071                         // get current crossing:
1072                         curx = _unsafe.getInt(addr);
1073 
1074                         // update crossing with orientation at last bit:
1075                         cross = curx;
1076 
1077                         // Increment x using DDA (fixed point):
1078                         curx += _unsafe.getInt(addr + _OFF_BUMP_X);
1079 
1080                         // Increment error:
1081                         err  =  _unsafe.getInt(addr + _OFF_ERROR)
1082                               + _unsafe.getInt(addr + _OFF_BUMP_ERR);
1083 
1084                         // Manual carry handling:
1085                         // keep sign and carry bit only and ignore last bit (preserve orientation):
1086                         _unsafe.putInt(addr,               curx - ((err &gt;&gt; 30) &amp; _ALL_BUT_LSB));
1087                         _unsafe.putInt(addr + _OFF_ERROR, (err &amp; _ERR_STEP_MAX));
1088 
1089                         if (DO_STATS) {
1090                             rdrCtx.stats.stat_rdr_crossings_updates.add(numCrossings);
1091                         }
1092 
1093                         if (i &gt;= prevNumCrossings) {
1094                             // simply store crossing as edgePtrs is in-place:
1095                             // will be copied and sorted efficiently by mergesort later:
1096                             _crossings[i]     = cross;
1097 
1098                         } else if (cross &lt; lastCross) {
1099                             if (DO_STATS) {
1100                                 rdrCtx.stats.stat_rdr_crossings_sorts.add(i);
1101                             }
1102 
1103                             // (straight) insertion sort of crossings:
1104                             j = i - 1;
1105                             _aux_crossings[i] = _aux_crossings[j];
1106                             _aux_edgePtrs[i] = _aux_edgePtrs[j];
1107 
1108                             while ((--j &gt;= 0) &amp;&amp; (_aux_crossings[j] &gt; cross)) {
1109                                 _aux_crossings[j + 1] = _aux_crossings[j];
1110                                 _aux_edgePtrs [j + 1] = _aux_edgePtrs[j];
1111                             }
1112                             _aux_crossings[j + 1] = cross;
1113                             _aux_edgePtrs [j + 1] = ecur;
1114 
1115                         } else {
1116                             // auxiliary storage:
1117                             _aux_crossings[i] = lastCross = cross;
1118                             _aux_edgePtrs [i] = ecur;
1119                         }
1120                     }
1121 
1122                     // use Mergesort using auxiliary arrays (sort only right part)
1123                     MergeSort.mergeSortNoCopy(_crossings,     _edgePtrs,
1124                                               _aux_crossings, _aux_edgePtrs,
1125                                               numCrossings,   prevNumCrossings);
1126                 }
1127 
1128                 // reset ptrLen
1129                 ptrLen = 0;
1130                 // --- from former ScanLineIterator.next()
1131 
1132 
1133                 /* note: bboxx0 and bboxx1 must be pixel boundaries
1134                    to have correct coverage computation */
1135 
1136                 // right shift on crossings to get the x-coordinate:
1137                 curxo = _crossings[0];
1138                 x0    = curxo &gt;&gt; 1;
1139                 if (x0 &lt; minX) {
1140                     minX = x0; // subpixel coordinate
1141                 }
1142 
1143                 x1 = _crossings[numCrossings - 1] &gt;&gt; 1;
1144                 if (x1 &gt; maxX) {
1145                     maxX = x1; // subpixel coordinate
1146                 }
1147 
1148 
1149                 // compute pixel coverages
1150                 prev = curx = x0;
1151                 // to turn {0, 1} into {-1, 1}, multiply by 2 and subtract 1.
1152                 // last bit contains orientation (0 or 1)
1153                 crorientation = ((curxo &amp; 0x1) &lt;&lt; 1) - 1;
1154 
1155                 if (windingRuleEvenOdd) {
1156                     sum = crorientation;
1157 
1158                     // Even Odd winding rule: take care of mask ie sum(orientations)
1159                     for (i = 1; i &lt; numCrossings; i++) {
1160                         curxo = _crossings[i];
1161                         curx  =  curxo &gt;&gt; 1;
1162                         // to turn {0, 1} into {-1, 1}, multiply by 2 and subtract 1.
1163                         // last bit contains orientation (0 or 1)
1164                         crorientation = ((curxo &amp; 0x1) &lt;&lt; 1) - 1;
1165 
1166                         if ((sum &amp; 0x1) != 0) {
1167                             // TODO: perform line clipping on left-right sides
1168                             // to avoid such bound checks:
1169                             x0 = (prev &gt; bboxx0) ? prev : bboxx0;
<a name="43" id="anc43"></a><span class="changed">1170 </span>
<span class="changed">1171                             if (curx &lt; bboxx1) {</span>
<span class="changed">1172                                 x1 = curx;</span>
<span class="changed">1173                             } else {</span>
<span class="changed">1174                                 x1 = bboxx1;</span>
<span class="changed">1175                                 // skip right side (fast exit loop):</span>
<span class="changed">1176                                 i = numCrossings;</span>
<span class="changed">1177                             }</span>
1178 
1179                             if (x0 &lt; x1) {
1180                                 x0 -= bboxx0; // turn x0, x1 from coords to indices
1181                                 x1 -= bboxx0; // in the alpha array.
1182 
1183                                 pix_x      =  x0      &gt;&gt; _SUBPIXEL_LG_POSITIONS_X;
1184                                 pix_xmaxm1 = (x1 - 1) &gt;&gt; _SUBPIXEL_LG_POSITIONS_X;
1185 
1186                                 if (pix_x == pix_xmaxm1) {
1187                                     // Start and end in same pixel
1188                                     tmp = (x1 - x0); // number of subpixels
1189                                     _alpha[pix_x    ] += tmp;
1190                                     _alpha[pix_x + 1] -= tmp;
1191 
1192                                     if (useBlkFlags) {
1193                                         // flag used blocks:
<a name="44" id="anc44"></a><span class="new">1194                                         // note: block processing handles extra pixel:</span>
1195                                         _blkFlags[pix_x    &gt;&gt; _BLK_SIZE_LG] = 1;
1196                                     }
1197                                 } else {
1198                                     tmp = (x0 &amp; _SUBPIXEL_MASK_X);
1199                                     _alpha[pix_x    ]
1200                                         += (_SUBPIXEL_POSITIONS_X - tmp);
1201                                     _alpha[pix_x + 1]
1202                                         += tmp;
1203 
1204                                     pix_xmax = x1 &gt;&gt; _SUBPIXEL_LG_POSITIONS_X;
1205 
1206                                     tmp = (x1 &amp; _SUBPIXEL_MASK_X);
1207                                     _alpha[pix_xmax    ]
1208                                         -= (_SUBPIXEL_POSITIONS_X - tmp);
1209                                     _alpha[pix_xmax + 1]
1210                                         -= tmp;
1211 
1212                                     if (useBlkFlags) {
1213                                         // flag used blocks:
<a name="45" id="anc45"></a><span class="new">1214                                         // note: block processing handles extra pixel:</span>
1215                                         _blkFlags[pix_x    &gt;&gt; _BLK_SIZE_LG] = 1;
1216                                         _blkFlags[pix_xmax &gt;&gt; _BLK_SIZE_LG] = 1;
1217                                     }
1218                                 }
1219                             }
1220                         }
1221 
1222                         sum += crorientation;
1223                         prev = curx;
1224                     }
1225                 } else {
1226                     // Non-zero winding rule: optimize that case (default)
1227                     // and avoid processing intermediate crossings
1228                     for (i = 1, sum = 0;; i++) {
1229                         sum += crorientation;
1230 
1231                         if (sum != 0) {
1232                             // prev = min(curx)
1233                             if (prev &gt; curx) {
1234                                 prev = curx;
1235                             }
1236                         } else {
1237                             // TODO: perform line clipping on left-right sides
1238                             // to avoid such bound checks:
1239                             x0 = (prev &gt; bboxx0) ? prev : bboxx0;
<a name="46" id="anc46"></a><span class="changed">1240 </span>
<span class="changed">1241                             if (curx &lt; bboxx1) {</span>
<span class="changed">1242                                 x1 = curx;</span>
<span class="changed">1243                             } else {</span>
<span class="changed">1244                                 x1 = bboxx1;</span>
<span class="changed">1245                                 // skip right side (fast exit loop):</span>
<span class="changed">1246                                 i = numCrossings;</span>
<span class="changed">1247                             }</span>
1248 
1249                             if (x0 &lt; x1) {
1250                                 x0 -= bboxx0; // turn x0, x1 from coords to indices
1251                                 x1 -= bboxx0; // in the alpha array.
1252 
1253                                 pix_x      =  x0      &gt;&gt; _SUBPIXEL_LG_POSITIONS_X;
1254                                 pix_xmaxm1 = (x1 - 1) &gt;&gt; _SUBPIXEL_LG_POSITIONS_X;
1255 
1256                                 if (pix_x == pix_xmaxm1) {
1257                                     // Start and end in same pixel
1258                                     tmp = (x1 - x0); // number of subpixels
1259                                     _alpha[pix_x    ] += tmp;
1260                                     _alpha[pix_x + 1] -= tmp;
1261 
1262                                     if (useBlkFlags) {
1263                                         // flag used blocks:
<a name="47" id="anc47"></a><span class="new">1264                                         // note: block processing handles extra pixel:</span>
1265                                         _blkFlags[pix_x    &gt;&gt; _BLK_SIZE_LG] = 1;
1266                                     }
1267                                 } else {
1268                                     tmp = (x0 &amp; _SUBPIXEL_MASK_X);
1269                                     _alpha[pix_x    ]
1270                                         += (_SUBPIXEL_POSITIONS_X - tmp);
1271                                     _alpha[pix_x + 1]
1272                                         += tmp;
1273 
1274                                     pix_xmax = x1 &gt;&gt; _SUBPIXEL_LG_POSITIONS_X;
1275 
1276                                     tmp = (x1 &amp; _SUBPIXEL_MASK_X);
1277                                     _alpha[pix_xmax    ]
1278                                         -= (_SUBPIXEL_POSITIONS_X - tmp);
1279                                     _alpha[pix_xmax + 1]
1280                                         -= tmp;
1281 
1282                                     if (useBlkFlags) {
1283                                         // flag used blocks:
<a name="48" id="anc48"></a><span class="new">1284                                         // note: block processing handles extra pixel:</span>
1285                                         _blkFlags[pix_x    &gt;&gt; _BLK_SIZE_LG] = 1;
1286                                         _blkFlags[pix_xmax &gt;&gt; _BLK_SIZE_LG] = 1;
1287                                     }
1288                                 }
1289                             }
1290                             prev = _MAX_VALUE;
1291                         }
1292 
1293                         if (i == numCrossings) {
1294                             break;
1295                         }
1296 
1297                         curxo = _crossings[i];
1298                         curx  =  curxo &gt;&gt; 1;
1299                         // to turn {0, 1} into {-1, 1}, multiply by 2 and subtract 1.
1300                         // last bit contains orientation (0 or 1)
1301                         crorientation = ((curxo &amp; 0x1) &lt;&lt; 1) - 1;
1302                     }
1303                 }
1304             } // numCrossings &gt; 0
1305 
1306             // even if this last row had no crossings, alpha will be zeroed
1307             // from the last emitRow call. But this doesn't matter because
1308             // maxX &lt; minX, so no row will be emitted to the MarlinCache.
1309             if ((y &amp; _SUBPIXEL_MASK_Y) == _SUBPIXEL_MASK_Y) {
1310                 lastY = y &gt;&gt; _SUBPIXEL_LG_POSITIONS_Y;
1311 
1312                 // convert subpixel to pixel coordinate within boundaries:
1313                 minX = FloatMath.max(minX, bboxx0) &gt;&gt; _SUBPIXEL_LG_POSITIONS_X;
1314                 maxX = FloatMath.min(maxX, bboxx1) &gt;&gt; _SUBPIXEL_LG_POSITIONS_X;
1315 
1316                 if (maxX &gt;= minX) {
1317                     // note: alpha array will be zeroed by copyAARow()
<a name="49" id="anc49"></a><span class="changed">1318                     // +1 because alpha [pix_minX; pix_maxX[</span>
1319                     // fix range [x0; x1[
<a name="50" id="anc50"></a><span class="changed">1320                     // note: if x1=bboxx1, then alpha is written up to bboxx1+1</span>
<span class="changed">1321                     // inclusive: alpha[bboxx1] ignored, alpha[bboxx1+1] == 0</span>
<span class="changed">1322                     // (normally so never cleared below)</span>
<span class="changed">1323                     copyAARow(_alpha, lastY, minX, maxX + 1, useBlkFlags);</span>
1324 
1325                     // speculative for next pixel row (scanline coherence):
1326                     if (_enableBlkFlagsHeuristics) {
1327                         // Use block flags if large pixel span and few crossings:
1328                         // ie mean(distance between crossings) is larger than
1329                         // 1 block size;
1330 
1331                         // fast check width:
1332                         maxX -= minX;
1333 
1334                         // if stroking: numCrossings /= 2
1335                         // =&gt; shift numCrossings by 1
1336                         // condition = (width / (numCrossings - 1)) &gt; blockSize
1337                         useBlkFlags = (maxX &gt; _BLK_SIZE) &amp;&amp; (maxX &gt;
1338                             (((numCrossings &gt;&gt; stroking) - 1) &lt;&lt; _BLK_SIZE_LG));
1339 
1340                         if (DO_STATS) {
1341                             tmp = FloatMath.max(1,
1342                                     ((numCrossings &gt;&gt; stroking) - 1));
1343                             rdrCtx.stats.hist_tile_generator_encoding_dist
1344                                 .add(maxX / tmp);
1345                         }
1346                     }
1347                 } else {
1348                     _cache.clearAARow(lastY);
1349                 }
1350                 minX = _MAX_VALUE;
1351                 maxX = _MIN_VALUE;
1352             }
1353         } // scan line iterator
1354 
1355         // Emit final row
1356         y--;
1357         y &gt;&gt;= _SUBPIXEL_LG_POSITIONS_Y;
1358 
1359         // convert subpixel to pixel coordinate within boundaries:
1360         minX = FloatMath.max(minX, bboxx0) &gt;&gt; _SUBPIXEL_LG_POSITIONS_X;
1361         maxX = FloatMath.min(maxX, bboxx1) &gt;&gt; _SUBPIXEL_LG_POSITIONS_X;
1362 
1363         if (maxX &gt;= minX) {
1364             // note: alpha array will be zeroed by copyAARow()
<a name="51" id="anc51"></a><span class="changed">1365             // +1 because alpha [pix_minX; pix_maxX[</span>
1366             // fix range [x0; x1[
<a name="52" id="anc52"></a><span class="changed">1367             // note: if x1=bboxx1, then alpha is written up to bboxx1+1</span>
<span class="changed">1368             // inclusive: alpha[bboxx1] ignored then cleared and</span>
<span class="changed">1369             // alpha[bboxx1+1] == 0 (normally so never cleared after)</span>
<span class="changed">1370             copyAARow(_alpha, y, minX, maxX + 1, useBlkFlags);</span>
1371         } else if (y != lastY) {
1372             _cache.clearAARow(y);
1373         }
1374 
1375         // update member:
1376         edgeCount = numCrossings;
1377         prevUseBlkFlags = useBlkFlags;
1378 
1379         if (DO_STATS) {
1380             // update max used mark
1381             activeEdgeMaxUsed = _arrayMaxUsed;
1382         }
1383     }
1384 
1385     boolean endRendering() {
1386         if (DO_MONITORS) {
1387             rdrCtx.stats.mon_rdr_endRendering.start();
1388         }
1389         if (edgeMinY == Integer.MAX_VALUE) {
1390             return false; // undefined edges bounds
1391         }
1392 
<a name="53" id="anc53"></a><span class="changed">1393         // bounds as half-open intervals</span>



1394         final int spminX = FloatMath.max(FloatMath.ceil_int(edgeMinX - 0.5f), boundsMinX);
<a name="54" id="anc54"></a><span class="changed">1395         final int spmaxX = FloatMath.min(FloatMath.ceil_int(edgeMaxX - 0.5f), boundsMaxX);</span>
1396 
1397         // edge Min/Max Y are already rounded to subpixels within bounds:
1398         final int spminY = edgeMinY;
<a name="55" id="anc55"></a><span class="changed">1399         final int spmaxY = edgeMaxY;</span>

1400 
<a name="56" id="anc56"></a><span class="changed">1401         buckets_minY = spminY - boundsMinY;</span>
<span class="changed">1402         buckets_maxY = spmaxY - boundsMinY;</span>






1403 
1404         if (DO_LOG_BOUNDS) {
1405             MarlinUtils.logInfo("edgesXY = [" + edgeMinX + " ... " + edgeMaxX
<a name="57" id="anc57"></a><span class="changed">1406                                 + "[ [" + edgeMinY + " ... " + edgeMaxY + "[");</span>
1407             MarlinUtils.logInfo("spXY    = [" + spminX + " ... " + spmaxX
<a name="58" id="anc58"></a><span class="changed">1408                                 + "[ [" + spminY + " ... " + spmaxY + "[");</span>
1409         }
1410 
1411         // test clipping for shapes out of bounds
<a name="59" id="anc59"></a><span class="changed">1412         if ((spminX &gt;= spmaxX) || (spminY &gt;= spmaxY)) {</span>
1413             return false;
1414         }
1415 
1416         // half open intervals
1417         // inclusive:
1418         final int pminX =  spminX                    &gt;&gt; SUBPIXEL_LG_POSITIONS_X;
1419         // exclusive:
1420         final int pmaxX = (spmaxX + SUBPIXEL_MASK_X) &gt;&gt; SUBPIXEL_LG_POSITIONS_X;
1421         // inclusive:
1422         final int pminY =  spminY                    &gt;&gt; SUBPIXEL_LG_POSITIONS_Y;
1423         // exclusive:
1424         final int pmaxY = (spmaxY + SUBPIXEL_MASK_Y) &gt;&gt; SUBPIXEL_LG_POSITIONS_Y;
1425 
1426         // store BBox to answer ptg.getBBox():
<a name="60" id="anc60"></a><span class="changed">1427         this.cache.init(pminX, pminY, pmaxX, pmaxY);</span>
1428 
1429         // Heuristics for using block flags:
1430         if (ENABLE_BLOCK_FLAGS) {
1431             enableBlkFlags = this.cache.useRLE;
1432             prevUseBlkFlags = enableBlkFlags &amp;&amp; !ENABLE_BLOCK_FLAGS_HEURISTICS;
1433 
1434             if (enableBlkFlags) {
1435                 // ensure blockFlags array is large enough:
1436                 // note: +2 to ensure enough space left at end
<a name="61" id="anc61"></a><span class="changed">1437                 final int blkLen = ((pmaxX - pminX) &gt;&gt; BLOCK_SIZE_LG) + 2;</span>
<span class="changed">1438                 if (blkLen &gt; INITIAL_ARRAY) {</span>
<span class="changed">1439                     blkFlags = blkFlags_ref.getArray(blkLen);</span>
1440                 }
1441             }
1442         }
1443 
1444         // memorize the rendering bounding box:
1445         /* note: bbox_spminX and bbox_spmaxX must be pixel boundaries
1446            to have correct coverage computation */
1447         // inclusive:
1448         bbox_spminX = pminX &lt;&lt; SUBPIXEL_LG_POSITIONS_X;
1449         // exclusive:
1450         bbox_spmaxX = pmaxX &lt;&lt; SUBPIXEL_LG_POSITIONS_X;
1451         // inclusive:
1452         bbox_spminY = spminY;
1453         // exclusive:
<a name="62" id="anc62"></a><span class="changed">1454         bbox_spmaxY = spmaxY;</span>
1455 
1456         if (DO_LOG_BOUNDS) {
1457             MarlinUtils.logInfo("pXY       = [" + pminX + " ... " + pmaxX
1458                                 + "[ [" + pminY + " ... " + pmaxY + "[");
1459             MarlinUtils.logInfo("bbox_spXY = [" + bbox_spminX + " ... "
1460                                 + bbox_spmaxX + "[ [" + bbox_spminY + " ... "
1461                                 + bbox_spmaxY + "[");
1462         }
1463 
1464         // Prepare alpha line:
1465         // add 2 to better deal with the last pixel in a pixel row.
1466         final int width = (pmaxX - pminX) + 2;
1467 
1468         // Useful when processing tile line by tile line
1469         if (width &gt; INITIAL_AA_ARRAY) {
1470             if (DO_STATS) {
1471                 rdrCtx.stats.stat_array_renderer_alphaline.add(width);
1472             }
1473             alphaLine = alphaLine_ref.getArray(width);
1474         }
1475 
1476         // process first tile line:
1477         endRendering(pminY);
1478 
1479         return true;
1480     }
1481 
1482     private int bbox_spminX, bbox_spmaxX, bbox_spminY, bbox_spmaxY;
1483 
1484     void endRendering(final int pminY) {
1485         if (DO_MONITORS) {
1486             rdrCtx.stats.mon_rdr_endRendering_Y.start();
1487         }
1488 
1489         final int spminY       = pminY &lt;&lt; SUBPIXEL_LG_POSITIONS_Y;
1490         final int fixed_spminY = FloatMath.max(bbox_spminY, spminY);
1491 
1492         // avoid rendering for last call to nextTile()
1493         if (fixed_spminY &lt; bbox_spmaxY) {
1494             // process a complete tile line ie scanlines for 32 rows
1495             final int spmaxY = FloatMath.min(bbox_spmaxY, spminY + SUBPIXEL_TILE);
1496 
1497             // process tile line [0 - 32]
1498             cache.resetTileLine(pminY);
1499 
1500             // Process only one tile line:
1501             _endRendering(fixed_spminY, spmaxY);
1502         }
1503         if (DO_MONITORS) {
1504             rdrCtx.stats.mon_rdr_endRendering_Y.stop();
1505         }
1506     }
1507 
1508     void copyAARow(final int[] alphaRow,
1509                    final int pix_y, final int pix_from, final int pix_to,
1510                    final boolean useBlockFlags)
1511     {
<a name="63" id="anc63"></a><span class="new">1512         if (DO_MONITORS) {</span>
<span class="new">1513             rdrCtx.stats.mon_rdr_copyAARow.start();</span>
<span class="new">1514         }</span>
1515         if (useBlockFlags) {
1516             if (DO_STATS) {
1517                 rdrCtx.stats.hist_tile_generator_encoding.add(1);
1518             }
1519             cache.copyAARowRLE_WithBlockFlags(blkFlags, alphaRow, pix_y, pix_from, pix_to);
1520         } else {
1521             if (DO_STATS) {
1522                 rdrCtx.stats.hist_tile_generator_encoding.add(0);
1523             }
1524             cache.copyAARowNoRLE(alphaRow, pix_y, pix_from, pix_to);
1525         }
<a name="64" id="anc64"></a><span class="new">1526         if (DO_MONITORS) {</span>
<span class="new">1527             rdrCtx.stats.mon_rdr_copyAARow.stop();</span>
<span class="new">1528         }</span>
1529     }
1530 }
<a name="65" id="anc65"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="65" type="hidden" /></form></body></html>
