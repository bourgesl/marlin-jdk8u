<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>Old src/share/classes/sun/java2d/marlin/DRenderer.java</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2007, 2017, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the "Classpath" exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.java2d.marlin;
  27 
  28 import sun.misc.Unsafe;
  29 
  30 import static sun.java2d.marlin.OffHeapArray.SIZE_INT;
  31 
  32 final class DRenderer implements DPathConsumer2D, MarlinRenderer {
  33 
  34     static final boolean DISABLE_RENDER = false;
  35 
  36     static final boolean ENABLE_BLOCK_FLAGS = MarlinProperties.isUseTileFlags();
  37     static final boolean ENABLE_BLOCK_FLAGS_HEURISTICS = MarlinProperties.isUseTileFlagsWithHeuristics();
  38 
  39     private static final int ALL_BUT_LSB = 0xFFFFFFFE;
  40     private static final int ERR_STEP_MAX = 0x7FFFFFFF; // = 2^31 - 1
  41 
  42     private static final double POWER_2_TO_32 = 0x1.0p32d;
  43 
  44     // use double to make tosubpix methods faster (no int to double conversion)
  45     static final double SUBPIXEL_SCALE_X = SUBPIXEL_POSITIONS_X;
  46     static final double SUBPIXEL_SCALE_Y = SUBPIXEL_POSITIONS_Y;
  47     static final int SUBPIXEL_MASK_X = SUBPIXEL_POSITIONS_X - 1;
  48     static final int SUBPIXEL_MASK_Y = SUBPIXEL_POSITIONS_Y - 1;
  49 
  50     // number of subpixels corresponding to a tile line
  51     private static final int SUBPIXEL_TILE
  52         = TILE_H &lt;&lt; SUBPIXEL_LG_POSITIONS_Y;
  53 
  54     // 2048 (pixelSize) pixels (height) x 8 subpixels = 64K
  55     static final int INITIAL_BUCKET_ARRAY
  56         = INITIAL_PIXEL_DIM * SUBPIXEL_POSITIONS_Y;
  57 
  58     // crossing capacity = edges count / 4 ~ 1024
  59     static final int INITIAL_CROSSING_COUNT = INITIAL_EDGES_COUNT &gt;&gt; 2;
  60 
  61     public static final int WIND_EVEN_ODD = 0;
  62     public static final int WIND_NON_ZERO = 1;
  63 
  64     // common to all types of input path segments.
  65     // OFFSET as bytes
  66     // only integer values:
  67     public static final long OFF_CURX_OR  = 0;
  68     public static final long OFF_ERROR    = OFF_CURX_OR  + SIZE_INT;
  69     public static final long OFF_BUMP_X   = OFF_ERROR    + SIZE_INT;
  70     public static final long OFF_BUMP_ERR = OFF_BUMP_X   + SIZE_INT;
  71     public static final long OFF_NEXT     = OFF_BUMP_ERR + SIZE_INT;
  72     public static final long OFF_YMAX     = OFF_NEXT     + SIZE_INT;
  73 
  74     // size of one edge in bytes
  75     public static final int SIZEOF_EDGE_BYTES = (int)(OFF_YMAX + SIZE_INT);
  76 
  77     // curve break into lines
  78     // cubic error in subpixels to decrement step
  79     private static final double CUB_DEC_ERR_SUBPIX
  80         = MarlinProperties.getCubicDecD2() * (NORM_SUBPIXELS / 8.0d); // 1 pixel
  81     // cubic error in subpixels to increment step
  82     private static final double CUB_INC_ERR_SUBPIX
  83         = MarlinProperties.getCubicIncD1() * (NORM_SUBPIXELS / 8.0d); // 0.4 pixel
  84 
  85     // TestNonAARasterization (JDK-8170879): cubics
  86     // bad paths (59294/100000 == 59,29%, 94335 bad pixels (avg = 1,59), 3966 warnings (avg = 0,07)
  87 
  88     // cubic bind length to decrement step
  89     public static final double CUB_DEC_BND
  90         = 8.0d * CUB_DEC_ERR_SUBPIX;
  91     // cubic bind length to increment step
  92     public static final double CUB_INC_BND
  93         = 8.0d * CUB_INC_ERR_SUBPIX;
  94 
  95     // cubic countlg
  96     public static final int CUB_COUNT_LG = 2;
  97     // cubic count = 2^countlg
  98     private static final int CUB_COUNT = 1 &lt;&lt; CUB_COUNT_LG;
  99     // cubic count^2 = 4^countlg
 100     private static final int CUB_COUNT_2 = 1 &lt;&lt; (2 * CUB_COUNT_LG);
 101     // cubic count^3 = 8^countlg
 102     private static final int CUB_COUNT_3 = 1 &lt;&lt; (3 * CUB_COUNT_LG);
 103     // cubic dt = 1 / count
 104     private static final double CUB_INV_COUNT = 1.0d / CUB_COUNT;
 105     // cubic dt^2 = 1 / count^2 = 1 / 4^countlg
 106     private static final double CUB_INV_COUNT_2 = 1.0d / CUB_COUNT_2;
 107     // cubic dt^3 = 1 / count^3 = 1 / 8^countlg
 108     private static final double CUB_INV_COUNT_3 = 1.0d / CUB_COUNT_3;
 109 
 110     // quad break into lines
 111     // quadratic error in subpixels
 112     private static final double QUAD_DEC_ERR_SUBPIX
 113         = MarlinProperties.getQuadDecD2() * (NORM_SUBPIXELS / 8.0d); // 0.5 pixel
 114 
 115     // TestNonAARasterization (JDK-8170879): quads
 116     // bad paths (62916/100000 == 62,92%, 103818 bad pixels (avg = 1,65), 6514 warnings (avg = 0,10)
 117 
 118     // quadratic bind length to decrement step
 119     public static final double QUAD_DEC_BND
 120         = 8.0d * QUAD_DEC_ERR_SUBPIX;
 121 
 122 //////////////////////////////////////////////////////////////////////////////
 123 //  SCAN LINE
 124 //////////////////////////////////////////////////////////////////////////////
 125     // crossings ie subpixel edge x coordinates
 126     private int[] crossings;
 127     // auxiliary storage for crossings (merge sort)
 128     private int[] aux_crossings;
 129 
 130     // indices into the segment pointer lists. They indicate the "active"
 131     // sublist in the segment lists (the portion of the list that contains
 132     // all the segments that cross the next scan line).
 133     private int edgeCount;
 134     private int[] edgePtrs;
 135     // auxiliary storage for edge pointers (merge sort)
 136     private int[] aux_edgePtrs;
 137 
 138     // max used for both edgePtrs and crossings (stats only)
 139     private int activeEdgeMaxUsed;
 140 
 141     // crossings ref (dirty)
 142     private final IntArrayCache.Reference crossings_ref;
 143     // edgePtrs ref (dirty)
 144     private final IntArrayCache.Reference edgePtrs_ref;
 145     // merge sort initial arrays (large enough to satisfy most usages) (1024)
 146     // aux_crossings ref (dirty)
 147     private final IntArrayCache.Reference aux_crossings_ref;
 148     // aux_edgePtrs ref (dirty)
 149     private final IntArrayCache.Reference aux_edgePtrs_ref;
 150 
 151 //////////////////////////////////////////////////////////////////////////////
 152 //  EDGE LIST
 153 //////////////////////////////////////////////////////////////////////////////
 154     private int edgeMinY = Integer.MAX_VALUE;
 155     private int edgeMaxY = Integer.MIN_VALUE;
 156     private double edgeMinX = Double.POSITIVE_INFINITY;
 157     private double edgeMaxX = Double.NEGATIVE_INFINITY;
 158 
 159     // edges [ints] stored in off-heap memory
 160     private final OffHeapArray edges;
 161 
 162     private int[] edgeBuckets;
 163     private int[] edgeBucketCounts; // 2*newedges + (1 if pruning needed)
 164     // used range for edgeBuckets / edgeBucketCounts
 165     private int buckets_minY;
 166     private int buckets_maxY;
 167 
 168     // edgeBuckets ref (clean)
 169     private final IntArrayCache.Reference edgeBuckets_ref;
 170     // edgeBucketCounts ref (clean)
 171     private final IntArrayCache.Reference edgeBucketCounts_ref;
 172 
 173     // Flattens using adaptive forward differencing. This only carries out
 174     // one iteration of the AFD loop. All it does is update AFD variables (i.e.
 175     // X0, Y0, D*[X|Y], COUNT; not variables used for computing scanline crossings).
 176     private void quadBreakIntoLinesAndAdd(double x0, double y0,
 177                                           final DCurve c,
 178                                           final double x2, final double y2)
 179     {
 180         int count = 1; // dt = 1 / count
 181 
 182         // maximum(ddX|Y) = norm(dbx, dby) * dt^2 (= 1)
 183         double maxDD = Math.abs(c.dbx) + Math.abs(c.dby);
 184 
 185         final double _DEC_BND = QUAD_DEC_BND;
 186 
 187         while (maxDD &gt;= _DEC_BND) {
 188             // divide step by half:
 189             maxDD /= 4.0d; // error divided by 2^2 = 4
 190 
 191             count &lt;&lt;= 1;
 192             if (DO_STATS) {
 193                 rdrCtx.stats.stat_rdr_quadBreak_dec.add(count);
 194             }
 195         }
 196 
 197         int nL = 0; // line count
 198         if (count &gt; 1) {
 199             final double icount = 1.0d / count; // dt
 200             final double icount2 = icount * icount; // dt^2
 201 
 202             final double ddx = c.dbx * icount2;
 203             final double ddy = c.dby * icount2;
 204             double dx = c.bx * icount2 + c.cx * icount;
 205             double dy = c.by * icount2 + c.cy * icount;
 206 
 207             double x1, y1;
 208 
 209             while (--count &gt; 0) {
 210                 x1 = x0 + dx;
 211                 dx += ddx;
 212                 y1 = y0 + dy;
 213                 dy += ddy;
 214 
 215                 addLine(x0, y0, x1, y1);
 216 
 217                 if (DO_STATS) { nL++; }
 218                 x0 = x1;
 219                 y0 = y1;
 220             }
 221         }
 222         addLine(x0, y0, x2, y2);
 223 
 224         if (DO_STATS) {
 225             rdrCtx.stats.stat_rdr_quadBreak.add(nL + 1);
 226         }
 227     }
 228 
 229     // x0, y0 and x3,y3 are the endpoints of the curve. We could compute these
 230     // using c.xat(0),c.yat(0) and c.xat(1),c.yat(1), but this might introduce
 231     // numerical errors, and our callers already have the exact values.
 232     // Another alternative would be to pass all the control points, and call
 233     // c.set here, but then too many numbers are passed around.
 234     private void curveBreakIntoLinesAndAdd(double x0, double y0,
 235                                            final DCurve c,
 236                                            final double x3, final double y3)
 237     {
 238         int count           = CUB_COUNT;
 239         final double icount  = CUB_INV_COUNT;   // dt
 240         final double icount2 = CUB_INV_COUNT_2; // dt^2
 241         final double icount3 = CUB_INV_COUNT_3; // dt^3
 242 
 243         // the dx and dy refer to forward differencing variables, not the last
 244         // coefficients of the "points" polynomial
 245         double dddx, dddy, ddx, ddy, dx, dy;
 246         dddx = 2.0d * c.dax * icount3;
 247         dddy = 2.0d * c.day * icount3;
 248         ddx = dddx + c.dbx * icount2;
 249         ddy = dddy + c.dby * icount2;
 250         dx = c.ax * icount3 + c.bx * icount2 + c.cx * icount;
 251         dy = c.ay * icount3 + c.by * icount2 + c.cy * icount;
 252 
 253         // we use x0, y0 to walk the line
 254         double x1 = x0, y1 = y0;
 255         int nL = 0; // line count
 256 
 257         final double _DEC_BND = CUB_DEC_BND;
 258         final double _INC_BND = CUB_INC_BND;
 259 
 260         while (count &gt; 0) {
 261             // divide step by half:
 262             while (Math.abs(ddx) + Math.abs(ddy) &gt;= _DEC_BND) {
 263                 dddx /= 8.0d;
 264                 dddy /= 8.0d;
 265                 ddx = ddx / 4.0d - dddx;
 266                 ddy = ddy / 4.0d - dddy;
 267                 dx = (dx - ddx) / 2.0d;
 268                 dy = (dy - ddy) / 2.0d;
 269 
 270                 count &lt;&lt;= 1;
 271                 if (DO_STATS) {
 272                     rdrCtx.stats.stat_rdr_curveBreak_dec.add(count);
 273                 }
 274             }
 275 
 276             // double step:
 277             // can only do this on even "count" values, because we must divide count by 2
 278             while (count % 2 == 0
 279                    &amp;&amp; Math.abs(dx) + Math.abs(dy) &lt;= _INC_BND)
 280             {
 281                 dx = 2.0d * dx + ddx;
 282                 dy = 2.0d * dy + ddy;
 283                 ddx = 4.0d * (ddx + dddx);
 284                 ddy = 4.0d * (ddy + dddy);
 285                 dddx *= 8.0d;
 286                 dddy *= 8.0d;
 287 
 288                 count &gt;&gt;= 1;
 289                 if (DO_STATS) {
 290                     rdrCtx.stats.stat_rdr_curveBreak_inc.add(count);
 291                 }
 292             }
 293             if (--count &gt; 0) {
 294                 x1 += dx;
 295                 dx += ddx;
 296                 ddx += dddx;
 297                 y1 += dy;
 298                 dy += ddy;
 299                 ddy += dddy;
 300             } else {
 301                 x1 = x3;
 302                 y1 = y3;
 303             }
 304 
 305             addLine(x0, y0, x1, y1);
 306 
 307             if (DO_STATS) { nL++; }
 308             x0 = x1;
 309             y0 = y1;
 310         }
 311         if (DO_STATS) {
 312             rdrCtx.stats.stat_rdr_curveBreak.add(nL);
 313         }
 314     }
 315 
 316     private void addLine(double x1, double y1, double x2, double y2) {
 317         if (DO_MONITORS) {
 318             rdrCtx.stats.mon_rdr_addLine.start();
 319         }
 320         if (DO_STATS) {
 321             rdrCtx.stats.stat_rdr_addLine.add(1);
 322         }
 323         int or = 1; // orientation of the line. 1 if y increases, 0 otherwise.
 324         if (y2 &lt; y1) {
 325             or = 0;
 326             double tmp = y2;
 327             y2 = y1;
 328             y1 = tmp;
 329             tmp = x2;
 330             x2 = x1;
 331             x1 = tmp;
 332         }
 333 
 334         // convert subpixel coordinates [double] into pixel positions [int]
 335 
 336         // The index of the pixel that holds the next HPC is at ceil(trueY - 0.5)
 337         // Since y1 and y2 are biased by -0.5 in tosubpixy(), this is simply
 338         // ceil(y1) or ceil(y2)
 339         // upper integer (inclusive)
 340         final int firstCrossing = FloatMath.max(FloatMath.ceil_int(y1), boundsMinY);
 341 
 342         // note: use boundsMaxY (last Y exclusive) to compute correct coverage
 343         // upper integer (exclusive)
 344         final int lastCrossing  = FloatMath.min(FloatMath.ceil_int(y2), boundsMaxY);
 345 
 346         /* skip horizontal lines in pixel space and clip edges
 347            out of y range [boundsMinY; boundsMaxY] */
 348         if (firstCrossing &gt;= lastCrossing) {
 349             if (DO_MONITORS) {
 350                 rdrCtx.stats.mon_rdr_addLine.stop();
 351             }
 352             if (DO_STATS) {
 353                 rdrCtx.stats.stat_rdr_addLine_skip.add(1);
 354             }
 355             return;
 356         }
 357 
 358         // edge min/max X/Y are in subpixel space (half-open interval):
 359         // note: Use integer crossings to ensure consistent range within
 360         // edgeBuckets / edgeBucketCounts arrays in case of NaN values (int = 0)
 361         if (firstCrossing &lt; edgeMinY) {
 362             edgeMinY = firstCrossing;
 363         }
 364         if (lastCrossing &gt; edgeMaxY) {
 365             edgeMaxY = lastCrossing;
 366         }
 367 
 368         final double slope = (x1 - x2) / (y1 - y2);
 369 
 370         if (slope &gt;= 0.0d) { // &lt;==&gt; x1 &lt; x2
 371             if (x1 &lt; edgeMinX) {
 372                 edgeMinX = x1;
 373             }
 374             if (x2 &gt; edgeMaxX) {
 375                 edgeMaxX = x2;
 376             }
 377         } else {
 378             if (x2 &lt; edgeMinX) {
 379                 edgeMinX = x2;
 380             }
 381             if (x1 &gt; edgeMaxX) {
 382                 edgeMaxX = x1;
 383             }
 384         }
 385 
 386         // local variables for performance:
 387         final int _SIZEOF_EDGE_BYTES = SIZEOF_EDGE_BYTES;
 388 
 389         final OffHeapArray _edges = edges;
 390 
 391         // get free pointer (ie length in bytes)
 392         final int edgePtr = _edges.used;
 393 
 394         // use substraction to avoid integer overflow:
 395         if (_edges.length - edgePtr &lt; _SIZEOF_EDGE_BYTES) {
 396             // suppose _edges.length &gt; _SIZEOF_EDGE_BYTES
 397             // so doubling size is enough to add needed bytes
 398             // note: throw IOOB if neededSize &gt; 2Gb:
 399             final long edgeNewSize = ArrayCacheConst.getNewLargeSize(
 400                                         _edges.length,
 401                                         edgePtr + _SIZEOF_EDGE_BYTES);
 402 
 403             if (DO_STATS) {
 404                 rdrCtx.stats.stat_rdr_edges_resizes.add(edgeNewSize);
 405             }
 406             _edges.resize(edgeNewSize);
 407         }
 408 
 409 
 410         final Unsafe _unsafe = OffHeapArray.UNSAFE;
 411         final long SIZE_INT = 4L;
 412         long addr   = _edges.address + edgePtr;
 413 
 414         // The x value must be bumped up to its position at the next HPC we will evaluate.
 415         // "firstcrossing" is the (sub)pixel number where the next crossing occurs
 416         // thus, the actual coordinate of the next HPC is "firstcrossing + 0.5"
 417         // so the Y distance we cover is "firstcrossing + 0.5 - trueY".
 418         // Note that since y1 (and y2) are already biased by -0.5 in tosubpixy(), we have
 419         // y1 = trueY - 0.5
 420         // trueY = y1 + 0.5
 421         // firstcrossing + 0.5 - trueY = firstcrossing + 0.5 - (y1 + 0.5)
 422         //                             = firstcrossing - y1
 423         // The x coordinate at that HPC is then:
 424         // x1_intercept = x1 + (firstcrossing - y1) * slope
 425         // The next VPC is then given by:
 426         // VPC index = ceil(x1_intercept - 0.5), or alternately
 427         // VPC index = floor(x1_intercept - 0.5 + 1 - epsilon)
 428         // epsilon is hard to pin down in floating point, but easy in fixed point, so if
 429         // we convert to fixed point then these operations get easier:
 430         // long x1_fixed = x1_intercept * 2^32;  (fixed point 32.32 format)
 431         // curx = next VPC = fixed_floor(x1_fixed - 2^31 + 2^32 - 1)
 432         //                 = fixed_floor(x1_fixed + 2^31 - 1)
 433         //                 = fixed_floor(x1_fixed + 0x7FFFFFFF)
 434         // and error       = fixed_fract(x1_fixed + 0x7FFFFFFF)
 435         final double x1_intercept = x1 + (firstCrossing - y1) * slope;
 436 
 437         // inlined scalb(x1_intercept, 32):
 438         final long x1_fixed_biased = ((long) (POWER_2_TO_32 * x1_intercept))
 439                                      + 0x7FFFFFFFL;
 440         // curx:
 441         // last bit corresponds to the orientation
 442         _unsafe.putInt(addr, (((int) (x1_fixed_biased &gt;&gt; 31L)) &amp; ALL_BUT_LSB) | or);
 443         addr += SIZE_INT;
 444         _unsafe.putInt(addr,  ((int)  x1_fixed_biased) &gt;&gt;&gt; 1);
 445         addr += SIZE_INT;
 446 
 447         // inlined scalb(slope, 32):
 448         final long slope_fixed = (long) (POWER_2_TO_32 * slope);
 449 
 450         // last bit set to 0 to keep orientation:
 451         _unsafe.putInt(addr, (((int) (slope_fixed &gt;&gt; 31L)) &amp; ALL_BUT_LSB));
 452         addr += SIZE_INT;
 453         _unsafe.putInt(addr,  ((int)  slope_fixed) &gt;&gt;&gt; 1);
 454         addr += SIZE_INT;
 455 
 456         final int[] _edgeBuckets      = edgeBuckets;
 457         final int[] _edgeBucketCounts = edgeBucketCounts;
 458 
 459         final int _boundsMinY = boundsMinY;
 460 
 461         // each bucket is a linked list. this method adds ptr to the
 462         // start of the "bucket"th linked list.
 463         final int bucketIdx = firstCrossing - _boundsMinY;
 464 
 465         // pointer from bucket
 466         _unsafe.putInt(addr, _edgeBuckets[bucketIdx]);
 467         addr += SIZE_INT;
 468         // y max (exclusive)
 469         _unsafe.putInt(addr,  lastCrossing);
 470 
 471         // Update buckets:
 472         // directly the edge struct "pointer"
 473         _edgeBuckets[bucketIdx]       = edgePtr;
 474         _edgeBucketCounts[bucketIdx] += 2; // 1 &lt;&lt; 1
 475         // last bit means edge end
 476         _edgeBucketCounts[lastCrossing - _boundsMinY] |= 0x1;
 477 
 478         // update free pointer (ie length in bytes)
 479         _edges.used += _SIZEOF_EDGE_BYTES;
 480 
 481         if (DO_MONITORS) {
 482             rdrCtx.stats.mon_rdr_addLine.stop();
 483         }
 484     }
 485 
 486 // END EDGE LIST
 487 //////////////////////////////////////////////////////////////////////////////
 488 
 489     // Cache to store RLE-encoded coverage mask of the current primitive
 490     final MarlinCache cache;
 491 
 492     // Bounds of the drawing region, at subpixel precision.
 493     private int boundsMinX, boundsMinY, boundsMaxX, boundsMaxY;
 494 
 495     // Current winding rule
 496     private int windingRule;
 497 
 498     // Current drawing position, i.e., final point of last segment
 499     private double x0, y0;
 500 
 501     // Position of most recent 'moveTo' command
 502     private double sx0, sy0;
 503 
 504     // per-thread renderer context
 505     final DRendererContext rdrCtx;
 506     // dirty curve
 507     private final DCurve curve;
 508 
 509     // clean alpha array (zero filled)
 510     private int[] alphaLine;
 511 
 512     // alphaLine ref (clean)
 513     private final IntArrayCache.Reference alphaLine_ref;
 514 
 515     private boolean enableBlkFlags = false;
 516     private boolean prevUseBlkFlags = false;
 517 
 518     /* block flags (0|1) */
 519     private int[] blkFlags;
 520 
 521     // blkFlags ref (clean)
 522     private final IntArrayCache.Reference blkFlags_ref;
 523 
 524     DRenderer(final DRendererContext rdrCtx) {
 525         this.rdrCtx = rdrCtx;
 526 
 527         this.edges = rdrCtx.newOffHeapArray(INITIAL_EDGES_CAPACITY); // 96K
 528 
 529         this.curve = rdrCtx.curve;
 530 
 531         edgeBuckets_ref      = rdrCtx.newCleanIntArrayRef(INITIAL_BUCKET_ARRAY); // 64K
 532         edgeBucketCounts_ref = rdrCtx.newCleanIntArrayRef(INITIAL_BUCKET_ARRAY); // 64K
 533 
 534         edgeBuckets      = edgeBuckets_ref.initial;
 535         edgeBucketCounts = edgeBucketCounts_ref.initial;
 536 
 537         // 2048 (pixelsize) pixel large
 538         alphaLine_ref = rdrCtx.newCleanIntArrayRef(INITIAL_AA_ARRAY); // 8K
 539         alphaLine     = alphaLine_ref.initial;
 540 
 541         this.cache = rdrCtx.cache;
 542 
 543         crossings_ref     = rdrCtx.newDirtyIntArrayRef(INITIAL_CROSSING_COUNT); // 2K
 544         aux_crossings_ref = rdrCtx.newDirtyIntArrayRef(INITIAL_CROSSING_COUNT); // 2K
 545         edgePtrs_ref      = rdrCtx.newDirtyIntArrayRef(INITIAL_CROSSING_COUNT); // 2K
 546         aux_edgePtrs_ref  = rdrCtx.newDirtyIntArrayRef(INITIAL_CROSSING_COUNT); // 2K
 547 
 548         crossings     = crossings_ref.initial;
 549         aux_crossings = aux_crossings_ref.initial;
 550         edgePtrs      = edgePtrs_ref.initial;
 551         aux_edgePtrs  = aux_edgePtrs_ref.initial;
 552 
 553         blkFlags_ref = rdrCtx.newCleanIntArrayRef(INITIAL_ARRAY); // 1K = 1 tile line
 554         blkFlags     = blkFlags_ref.initial;
 555     }
 556 
 557     DRenderer init(final int pix_boundsX, final int pix_boundsY,
 558                   final int pix_boundsWidth, final int pix_boundsHeight,
 559                   final int windingRule)
 560     {
 561         this.windingRule = windingRule;
 562 
 563         // bounds as half-open intervals: minX &lt;= x &lt; maxX and minY &lt;= y &lt; maxY
 564         this.boundsMinX =  pix_boundsX &lt;&lt; SUBPIXEL_LG_POSITIONS_X;
 565         this.boundsMaxX =
 566             (pix_boundsX + pix_boundsWidth) &lt;&lt; SUBPIXEL_LG_POSITIONS_X;
 567         this.boundsMinY =  pix_boundsY &lt;&lt; SUBPIXEL_LG_POSITIONS_Y;
 568         this.boundsMaxY =
 569             (pix_boundsY + pix_boundsHeight) &lt;&lt; SUBPIXEL_LG_POSITIONS_Y;
 570 
 571         if (DO_LOG_BOUNDS) {
 572             MarlinUtils.logInfo("boundsXY = [" + boundsMinX + " ... "
 573                                 + boundsMaxX + "[ [" + boundsMinY + " ... "
 574                                 + boundsMaxY + "[");
 575         }
 576 
 577         // see addLine: ceil(boundsMaxY) =&gt; boundsMaxY + 1
 578         // +1 for edgeBucketCounts
 579         final int edgeBucketsLength = (boundsMaxY - boundsMinY) + 1;
 580 
 581         if (edgeBucketsLength &gt; INITIAL_BUCKET_ARRAY) {
 582             if (DO_STATS) {
 583                 rdrCtx.stats.stat_array_renderer_edgeBuckets
 584                     .add(edgeBucketsLength);
 585                 rdrCtx.stats.stat_array_renderer_edgeBucketCounts
 586                     .add(edgeBucketsLength);
 587             }
 588             edgeBuckets = edgeBuckets_ref.getArray(edgeBucketsLength);
 589             edgeBucketCounts = edgeBucketCounts_ref.getArray(edgeBucketsLength);
 590         }
 591 
 592         edgeMinY = Integer.MAX_VALUE;
 593         edgeMaxY = Integer.MIN_VALUE;
 594         edgeMinX = Double.POSITIVE_INFINITY;
 595         edgeMaxX = Double.NEGATIVE_INFINITY;
 596 
 597         // reset used mark:
 598         edgeCount = 0;
 599         activeEdgeMaxUsed = 0;
 600         edges.used = 0;
 601 
 602         return this; // fluent API
 603     }
 604 
 605     /**
 606      * Disposes this renderer and recycle it clean up before reusing this instance
 607      */
 608     void dispose() {
 609         if (DO_STATS) {
 610             rdrCtx.stats.stat_rdr_activeEdges.add(activeEdgeMaxUsed);
 611             rdrCtx.stats.stat_rdr_edges.add(edges.used);
 612             rdrCtx.stats.stat_rdr_edges_count.add(edges.used / SIZEOF_EDGE_BYTES);
 613             rdrCtx.stats.hist_rdr_edges_count.add(edges.used / SIZEOF_EDGE_BYTES);
 614             rdrCtx.stats.totalOffHeap += edges.length;
 615         }
 616         // Return arrays:
 617         crossings = crossings_ref.putArray(crossings);
 618         aux_crossings = aux_crossings_ref.putArray(aux_crossings);
 619 
 620         edgePtrs = edgePtrs_ref.putArray(edgePtrs);
 621         aux_edgePtrs = aux_edgePtrs_ref.putArray(aux_edgePtrs);
 622 
 623         alphaLine = alphaLine_ref.putArray(alphaLine, 0, 0); // already zero filled
 624         blkFlags  = blkFlags_ref.putArray(blkFlags, 0, 0); // already zero filled
 625 
 626         if (edgeMinY != Integer.MAX_VALUE) {
 627             // if context is maked as DIRTY:
 628             if (rdrCtx.dirty) {
 629                 // may happen if an exception if thrown in the pipeline processing:
 630                 // clear completely buckets arrays:
 631                 buckets_minY = 0;
 632                 buckets_maxY = boundsMaxY - boundsMinY;
 633             }
 634             // clear only used part
 635             edgeBuckets = edgeBuckets_ref.putArray(edgeBuckets, buckets_minY,
 636                                                                 buckets_maxY);
 637             edgeBucketCounts = edgeBucketCounts_ref.putArray(edgeBucketCounts,
 638                                                              buckets_minY,
 639                                                              buckets_maxY + 1);
 640         } else {
 641             // unused arrays
 642             edgeBuckets = edgeBuckets_ref.putArray(edgeBuckets, 0, 0);
 643             edgeBucketCounts = edgeBucketCounts_ref.putArray(edgeBucketCounts, 0, 0);
 644         }
 645 
 646         // At last: resize back off-heap edges to initial size
 647         if (edges.length != INITIAL_EDGES_CAPACITY) {
 648             // note: may throw OOME:
 649             edges.resize(INITIAL_EDGES_CAPACITY);
 650         }
 651         if (DO_CLEAN_DIRTY) {
 652             // Force zero-fill dirty arrays:
 653             edges.fill(BYTE_0);
 654         }
 655         if (DO_MONITORS) {
 656             rdrCtx.stats.mon_rdr_endRendering.stop();
 657         }
 658         // recycle the RendererContext instance
 659         DMarlinRenderingEngine.returnRendererContext(rdrCtx);
 660     }
 661 
 662     private static double tosubpixx(final double pix_x) {
 663         return SUBPIXEL_SCALE_X * pix_x;
 664     }
 665 
 666     private static double tosubpixy(final double pix_y) {
 667         // shift y by -0.5 for fast ceil(y - 0.5):
 668         return SUBPIXEL_SCALE_Y * pix_y - 0.5d;
 669     }
 670 
 671     @Override
 672     public void moveTo(double pix_x0, double pix_y0) {
 673         closePath();
 674         final double sx = tosubpixx(pix_x0);
 675         final double sy = tosubpixy(pix_y0);
 676         this.sx0 = sx;
 677         this.sy0 = sy;
 678         this.x0 = sx;
 679         this.y0 = sy;
 680     }
 681 
 682     @Override
 683     public void lineTo(double pix_x1, double pix_y1) {
 684         final double x1 = tosubpixx(pix_x1);
 685         final double y1 = tosubpixy(pix_y1);
 686         addLine(x0, y0, x1, y1);
 687         x0 = x1;
 688         y0 = y1;
 689     }
 690 
 691     @Override
 692     public void curveTo(double x1, double y1,
 693                         double x2, double y2,
 694                         double x3, double y3)
 695     {
 696         final double xe = tosubpixx(x3);
 697         final double ye = tosubpixy(y3);
 698         curve.set(x0, y0, tosubpixx(x1), tosubpixy(y1),
 699                           tosubpixx(x2), tosubpixy(y2), xe, ye);
 700         curveBreakIntoLinesAndAdd(x0, y0, curve, xe, ye);
 701         x0 = xe;
 702         y0 = ye;
 703     }
 704 
 705     @Override
 706     public void quadTo(double x1, double y1, double x2, double y2) {
 707         final double xe = tosubpixx(x2);
 708         final double ye = tosubpixy(y2);
 709         curve.set(x0, y0, tosubpixx(x1), tosubpixy(y1), xe, ye);
 710         quadBreakIntoLinesAndAdd(x0, y0, curve, xe, ye);
 711         x0 = xe;
 712         y0 = ye;
 713     }
 714 
 715     @Override
 716     public void closePath() {
 717         addLine(x0, y0, sx0, sy0);
 718         x0 = sx0;
 719         y0 = sy0;
 720     }
 721 
 722     @Override
 723     public void pathDone() {
 724         closePath();
 725     }
 726 
 727     @Override
 728     public long getNativeConsumer() {
 729         throw new InternalError("Renderer does not use a native consumer.");
 730     }
 731 
 732     private void _endRendering(final int ymin, final int ymax) {
 733         if (DISABLE_RENDER) {
 734             return;
 735         }
 736 
 737         // Get X bounds as true pixel boundaries to compute correct pixel coverage:
 738         final int bboxx0 = bbox_spminX;
 739         final int bboxx1 = bbox_spmaxX;
 740 
 741         final boolean windingRuleEvenOdd = (windingRule == WIND_EVEN_ODD);
 742 
 743         // Useful when processing tile line by tile line
 744         final int[] _alpha = alphaLine;
 745 
 746         // local vars (performance):
 747         final MarlinCache _cache = cache;
 748         final OffHeapArray _edges = edges;
 749         final int[] _edgeBuckets = edgeBuckets;
 750         final int[] _edgeBucketCounts = edgeBucketCounts;
 751 
 752         int[] _crossings = this.crossings;
 753         int[] _edgePtrs  = this.edgePtrs;
 754 
 755         // merge sort auxiliary storage:
 756         int[] _aux_crossings = this.aux_crossings;
 757         int[] _aux_edgePtrs  = this.aux_edgePtrs;
 758 
 759         // copy constants:
 760         final long _OFF_ERROR    = OFF_ERROR;
 761         final long _OFF_BUMP_X   = OFF_BUMP_X;
 762         final long _OFF_BUMP_ERR = OFF_BUMP_ERR;
 763 
 764         final long _OFF_NEXT     = OFF_NEXT;
 765         final long _OFF_YMAX     = OFF_YMAX;
 766 
 767         final int _ALL_BUT_LSB   = ALL_BUT_LSB;
 768         final int _ERR_STEP_MAX  = ERR_STEP_MAX;
 769 
 770         // unsafe I/O:
 771         final Unsafe _unsafe = OffHeapArray.UNSAFE;
 772         final long    addr0  = _edges.address;
 773         long addr;
 774         final int _SUBPIXEL_LG_POSITIONS_X = SUBPIXEL_LG_POSITIONS_X;
 775         final int _SUBPIXEL_LG_POSITIONS_Y = SUBPIXEL_LG_POSITIONS_Y;
 776         final int _SUBPIXEL_MASK_X = SUBPIXEL_MASK_X;
 777         final int _SUBPIXEL_MASK_Y = SUBPIXEL_MASK_Y;
 778         final int _SUBPIXEL_POSITIONS_X = SUBPIXEL_POSITIONS_X;
 779 
 780         final int _MIN_VALUE = Integer.MIN_VALUE;
 781         final int _MAX_VALUE = Integer.MAX_VALUE;
 782 
 783         // Now we iterate through the scanlines. We must tell emitRow the coord
 784         // of the first non-transparent pixel, so we must keep accumulators for
 785         // the first and last pixels of the section of the current pixel row
 786         // that we will emit.
 787         // We also need to accumulate pix_bbox, but the iterator does it
 788         // for us. We will just get the values from it once this loop is done
 789         int minX = _MAX_VALUE;
 790         int maxX = _MIN_VALUE;
 791 
 792         int y = ymin;
 793         int bucket = y - boundsMinY;
 794 
 795         int numCrossings = this.edgeCount;
 796         int edgePtrsLen = _edgePtrs.length;
 797         int crossingsLen = _crossings.length;
 798         int _arrayMaxUsed = activeEdgeMaxUsed;
 799         int ptrLen = 0, newCount, ptrEnd;
 800 
 801         int bucketcount, i, j, ecur;
 802         int cross, lastCross;
 803         int x0, x1, tmp, sum, prev, curx, curxo, crorientation, err;
 804         int pix_x, pix_xmaxm1, pix_xmax;
 805 
 806         int low, high, mid, prevNumCrossings;
 807         boolean useBinarySearch;
 808 
 809         final int[] _blkFlags = blkFlags;
 810         final int _BLK_SIZE_LG = BLOCK_SIZE_LG;
 811         final int _BLK_SIZE = BLOCK_SIZE;
 812 
 813         final boolean _enableBlkFlagsHeuristics = ENABLE_BLOCK_FLAGS_HEURISTICS &amp;&amp; this.enableBlkFlags;
 814 
 815         // Use block flags if large pixel span and few crossings:
 816         // ie mean(distance between crossings) is high
 817         boolean useBlkFlags = this.prevUseBlkFlags;
 818 
 819         final int stroking = rdrCtx.stroking;
 820 
 821         int lastY = -1; // last emited row
 822 
 823 
 824         // Iteration on scanlines
 825         for (; y &lt; ymax; y++, bucket++) {
 826             // --- from former ScanLineIterator.next()
 827             bucketcount = _edgeBucketCounts[bucket];
 828 
 829             // marker on previously sorted edges:
 830             prevNumCrossings = numCrossings;
 831 
 832             // bucketCount indicates new edge / edge end:
 833             if (bucketcount != 0) {
 834                 if (DO_STATS) {
 835                     rdrCtx.stats.stat_rdr_activeEdges_updates.add(numCrossings);
 836                 }
 837 
 838                 // last bit set to 1 means that edges ends
 839                 if ((bucketcount &amp; 0x1) != 0) {
 840                     // eviction in active edge list
 841                     // cache edges[] address + offset
 842                     addr = addr0 + _OFF_YMAX;
 843 
 844                     for (i = 0, newCount = 0; i &lt; numCrossings; i++) {
 845                         // get the pointer to the edge
 846                         ecur = _edgePtrs[i];
 847                         // random access so use unsafe:
 848                         if (_unsafe.getInt(addr + ecur) &gt; y) {
 849                             _edgePtrs[newCount++] = ecur;
 850                         }
 851                     }
 852                     // update marker on sorted edges minus removed edges:
 853                     prevNumCrossings = numCrossings = newCount;
 854                 }
 855 
 856                 ptrLen = bucketcount &gt;&gt; 1; // number of new edge
 857 
 858                 if (ptrLen != 0) {
 859                     if (DO_STATS) {
 860                         rdrCtx.stats.stat_rdr_activeEdges_adds.add(ptrLen);
 861                         if (ptrLen &gt; 10) {
 862                             rdrCtx.stats.stat_rdr_activeEdges_adds_high.add(ptrLen);
 863                         }
 864                     }
 865                     ptrEnd = numCrossings + ptrLen;
 866 
 867                     if (edgePtrsLen &lt; ptrEnd) {
 868                         if (DO_STATS) {
 869                             rdrCtx.stats.stat_array_renderer_edgePtrs.add(ptrEnd);
 870                         }
 871                         this.edgePtrs = _edgePtrs
 872                             = edgePtrs_ref.widenArray(_edgePtrs, numCrossings,
 873                                                       ptrEnd);
 874 
 875                         edgePtrsLen = _edgePtrs.length;
 876                         // Get larger auxiliary storage:
 877                         aux_edgePtrs_ref.putArray(_aux_edgePtrs);
 878 
 879                         // use ArrayCache.getNewSize() to use the same growing
 880                         // factor than widenArray():
 881                         if (DO_STATS) {
 882                             rdrCtx.stats.stat_array_renderer_aux_edgePtrs.add(ptrEnd);
 883                         }
 884                         this.aux_edgePtrs = _aux_edgePtrs
 885                             = aux_edgePtrs_ref.getArray(
 886                                 ArrayCacheConst.getNewSize(numCrossings, ptrEnd)
 887                             );
 888                     }
 889 
 890                     // cache edges[] address + offset
 891                     addr = addr0 + _OFF_NEXT;
 892 
 893                     // add new edges to active edge list:
 894                     for (ecur = _edgeBuckets[bucket];
 895                          numCrossings &lt; ptrEnd; numCrossings++)
 896                     {
 897                         // store the pointer to the edge
 898                         _edgePtrs[numCrossings] = ecur;
 899                         // random access so use unsafe:
 900                         ecur = _unsafe.getInt(addr + ecur);
 901                     }
 902 
 903                     if (crossingsLen &lt; numCrossings) {
 904                         // Get larger array:
 905                         crossings_ref.putArray(_crossings);
 906 
 907                         if (DO_STATS) {
 908                             rdrCtx.stats.stat_array_renderer_crossings
 909                                 .add(numCrossings);
 910                         }
 911                         this.crossings = _crossings
 912                             = crossings_ref.getArray(numCrossings);
 913 
 914                         // Get larger auxiliary storage:
 915                         aux_crossings_ref.putArray(_aux_crossings);
 916 
 917                         if (DO_STATS) {
 918                             rdrCtx.stats.stat_array_renderer_aux_crossings
 919                                 .add(numCrossings);
 920                         }
 921                         this.aux_crossings = _aux_crossings
 922                             = aux_crossings_ref.getArray(numCrossings);
 923 
 924                         crossingsLen = _crossings.length;
 925                     }
 926                     if (DO_STATS) {
 927                         // update max used mark
 928                         if (numCrossings &gt; _arrayMaxUsed) {
 929                             _arrayMaxUsed = numCrossings;
 930                         }
 931                     }
 932                 } // ptrLen != 0
 933             } // bucketCount != 0
 934 
 935 
 936             if (numCrossings != 0) {
 937                 /*
 938                  * thresholds to switch to optimized merge sort
 939                  * for newly added edges + final merge pass.
 940                  */
 941                 if ((ptrLen &lt; 10) || (numCrossings &lt; 40)) {
 942                     if (DO_STATS) {
 943                         rdrCtx.stats.hist_rdr_crossings.add(numCrossings);
 944                         rdrCtx.stats.hist_rdr_crossings_adds.add(ptrLen);
 945                     }
 946 
 947                     /*
 948                      * threshold to use binary insertion sort instead of
 949                      * straight insertion sort (to reduce minimize comparisons).
 950                      */
 951                     useBinarySearch = (numCrossings &gt;= 20);
 952 
 953                     // if small enough:
 954                     lastCross = _MIN_VALUE;
 955 
 956                     for (i = 0; i &lt; numCrossings; i++) {
 957                         // get the pointer to the edge
 958                         ecur = _edgePtrs[i];
 959 
 960                         /* convert subpixel coordinates into pixel
 961                             positions for coming scanline */
 962                         /* note: it is faster to always update edges even
 963                            if it is removed from AEL for coming or last scanline */
 964 
 965                         // random access so use unsafe:
 966                         addr = addr0 + ecur; // ecur + OFF_F_CURX
 967 
 968                         // get current crossing:
 969                         curx = _unsafe.getInt(addr);
 970 
 971                         // update crossing with orientation at last bit:
 972                         cross = curx;
 973 
 974                         // Increment x using DDA (fixed point):
 975                         curx += _unsafe.getInt(addr + _OFF_BUMP_X);
 976 
 977                         // Increment error:
 978                         err  =  _unsafe.getInt(addr + _OFF_ERROR)
 979                               + _unsafe.getInt(addr + _OFF_BUMP_ERR);
 980 
 981                         // Manual carry handling:
 982                         // keep sign and carry bit only and ignore last bit (preserve orientation):
 983                         _unsafe.putInt(addr,               curx - ((err &gt;&gt; 30) &amp; _ALL_BUT_LSB));
 984                         _unsafe.putInt(addr + _OFF_ERROR, (err &amp; _ERR_STEP_MAX));
 985 
 986                         if (DO_STATS) {
 987                             rdrCtx.stats.stat_rdr_crossings_updates.add(numCrossings);
 988                         }
 989 
 990                         // insertion sort of crossings:
 991                         if (cross &lt; lastCross) {
 992                             if (DO_STATS) {
 993                                 rdrCtx.stats.stat_rdr_crossings_sorts.add(i);
 994                             }
 995 
 996                             /* use binary search for newly added edges
 997                                in crossings if arrays are large enough */
 998                             if (useBinarySearch &amp;&amp; (i &gt;= prevNumCrossings)) {
 999                                 if (DO_STATS) {
1000                                     rdrCtx.stats.stat_rdr_crossings_bsearch.add(i);
1001                                 }
1002                                 low = 0;
1003                                 high = i - 1;
1004 
1005                                 do {
1006                                     // note: use signed shift (not &gt;&gt;&gt;) for performance
1007                                     // as indices are small enough to exceed Integer.MAX_VALUE
1008                                     mid = (low + high) &gt;&gt; 1;
1009 
1010                                     if (_crossings[mid] &lt; cross) {
1011                                         low = mid + 1;
1012                                     } else {
1013                                         high = mid - 1;
1014                                     }
1015                                 } while (low &lt;= high);
1016 
1017                                 for (j = i - 1; j &gt;= low; j--) {
1018                                     _crossings[j + 1] = _crossings[j];
1019                                     _edgePtrs [j + 1] = _edgePtrs[j];
1020                                 }
1021                                 _crossings[low] = cross;
1022                                 _edgePtrs [low] = ecur;
1023 
1024                             } else {
1025                                 j = i - 1;
1026                                 _crossings[i] = _crossings[j];
1027                                 _edgePtrs[i] = _edgePtrs[j];
1028 
1029                                 while ((--j &gt;= 0) &amp;&amp; (_crossings[j] &gt; cross)) {
1030                                     _crossings[j + 1] = _crossings[j];
1031                                     _edgePtrs [j + 1] = _edgePtrs[j];
1032                                 }
1033                                 _crossings[j + 1] = cross;
1034                                 _edgePtrs [j + 1] = ecur;
1035                             }
1036 
1037                         } else {
1038                             _crossings[i] = lastCross = cross;
1039                         }
1040                     }
1041                 } else {
1042                     if (DO_STATS) {
1043                         rdrCtx.stats.stat_rdr_crossings_msorts.add(numCrossings);
1044                         rdrCtx.stats.hist_rdr_crossings_ratio
1045                             .add((1000 * ptrLen) / numCrossings);
1046                         rdrCtx.stats.hist_rdr_crossings_msorts.add(numCrossings);
1047                         rdrCtx.stats.hist_rdr_crossings_msorts_adds.add(ptrLen);
1048                     }
1049 
1050                     // Copy sorted data in auxiliary arrays
1051                     // and perform insertion sort on almost sorted data
1052                     // (ie i &lt; prevNumCrossings):
1053 
1054                     lastCross = _MIN_VALUE;
1055 
1056                     for (i = 0; i &lt; numCrossings; i++) {
1057                         // get the pointer to the edge
1058                         ecur = _edgePtrs[i];
1059 
1060                         /* convert subpixel coordinates into pixel
1061                             positions for coming scanline */
1062                         /* note: it is faster to always update edges even
1063                            if it is removed from AEL for coming or last scanline */
1064 
1065                         // random access so use unsafe:
1066                         addr = addr0 + ecur; // ecur + OFF_F_CURX
1067 
1068                         // get current crossing:
1069                         curx = _unsafe.getInt(addr);
1070 
1071                         // update crossing with orientation at last bit:
1072                         cross = curx;
1073 
1074                         // Increment x using DDA (fixed point):
1075                         curx += _unsafe.getInt(addr + _OFF_BUMP_X);
1076 
1077                         // Increment error:
1078                         err  =  _unsafe.getInt(addr + _OFF_ERROR)
1079                               + _unsafe.getInt(addr + _OFF_BUMP_ERR);
1080 
1081                         // Manual carry handling:
1082                         // keep sign and carry bit only and ignore last bit (preserve orientation):
1083                         _unsafe.putInt(addr,               curx - ((err &gt;&gt; 30) &amp; _ALL_BUT_LSB));
1084                         _unsafe.putInt(addr + _OFF_ERROR, (err &amp; _ERR_STEP_MAX));
1085 
1086                         if (DO_STATS) {
1087                             rdrCtx.stats.stat_rdr_crossings_updates.add(numCrossings);
1088                         }
1089 
1090                         if (i &gt;= prevNumCrossings) {
1091                             // simply store crossing as edgePtrs is in-place:
1092                             // will be copied and sorted efficiently by mergesort later:
1093                             _crossings[i]     = cross;
1094 
1095                         } else if (cross &lt; lastCross) {
1096                             if (DO_STATS) {
1097                                 rdrCtx.stats.stat_rdr_crossings_sorts.add(i);
1098                             }
1099 
1100                             // (straight) insertion sort of crossings:
1101                             j = i - 1;
1102                             _aux_crossings[i] = _aux_crossings[j];
1103                             _aux_edgePtrs[i] = _aux_edgePtrs[j];
1104 
1105                             while ((--j &gt;= 0) &amp;&amp; (_aux_crossings[j] &gt; cross)) {
1106                                 _aux_crossings[j + 1] = _aux_crossings[j];
1107                                 _aux_edgePtrs [j + 1] = _aux_edgePtrs[j];
1108                             }
1109                             _aux_crossings[j + 1] = cross;
1110                             _aux_edgePtrs [j + 1] = ecur;
1111 
1112                         } else {
1113                             // auxiliary storage:
1114                             _aux_crossings[i] = lastCross = cross;
1115                             _aux_edgePtrs [i] = ecur;
1116                         }
1117                     }
1118 
1119                     // use Mergesort using auxiliary arrays (sort only right part)
1120                     MergeSort.mergeSortNoCopy(_crossings,     _edgePtrs,
1121                                               _aux_crossings, _aux_edgePtrs,
1122                                               numCrossings,   prevNumCrossings);
1123                 }
1124 
1125                 // reset ptrLen
1126                 ptrLen = 0;
1127                 // --- from former ScanLineIterator.next()
1128 
1129 
1130                 /* note: bboxx0 and bboxx1 must be pixel boundaries
1131                    to have correct coverage computation */
1132 
1133                 // right shift on crossings to get the x-coordinate:
1134                 curxo = _crossings[0];
1135                 x0    = curxo &gt;&gt; 1;
1136                 if (x0 &lt; minX) {
1137                     minX = x0; // subpixel coordinate
1138                 }
1139 
1140                 x1 = _crossings[numCrossings - 1] &gt;&gt; 1;
1141                 if (x1 &gt; maxX) {
1142                     maxX = x1; // subpixel coordinate
1143                 }
1144 
1145 
1146                 // compute pixel coverages
1147                 prev = curx = x0;
1148                 // to turn {0, 1} into {-1, 1}, multiply by 2 and subtract 1.
1149                 // last bit contains orientation (0 or 1)
1150                 crorientation = ((curxo &amp; 0x1) &lt;&lt; 1) - 1;
1151 
1152                 if (windingRuleEvenOdd) {
1153                     sum = crorientation;
1154 
1155                     // Even Odd winding rule: take care of mask ie sum(orientations)
1156                     for (i = 1; i &lt; numCrossings; i++) {
1157                         curxo = _crossings[i];
1158                         curx  =  curxo &gt;&gt; 1;
1159                         // to turn {0, 1} into {-1, 1}, multiply by 2 and subtract 1.
1160                         // last bit contains orientation (0 or 1)
1161                         crorientation = ((curxo &amp; 0x1) &lt;&lt; 1) - 1;
1162 
1163                         if ((sum &amp; 0x1) != 0) {
1164                             // TODO: perform line clipping on left-right sides
1165                             // to avoid such bound checks:
1166                             x0 = (prev &gt; bboxx0) ? prev : bboxx0;
1167 
1168                             if (curx &lt; bboxx1) {
1169                                 x1 = curx;
1170                             } else {
1171                                 x1 = bboxx1;
1172                                 // skip right side (fast exit loop):
1173                                 i = numCrossings;
1174                             }
1175 
1176                             if (x0 &lt; x1) {
1177                                 x0 -= bboxx0; // turn x0, x1 from coords to indices
1178                                 x1 -= bboxx0; // in the alpha array.
1179 
1180                                 pix_x      =  x0      &gt;&gt; _SUBPIXEL_LG_POSITIONS_X;
1181                                 pix_xmaxm1 = (x1 - 1) &gt;&gt; _SUBPIXEL_LG_POSITIONS_X;
1182 
1183                                 if (pix_x == pix_xmaxm1) {
1184                                     // Start and end in same pixel
1185                                     tmp = (x1 - x0); // number of subpixels
1186                                     _alpha[pix_x    ] += tmp;
1187                                     _alpha[pix_x + 1] -= tmp;
1188 
1189                                     if (useBlkFlags) {
1190                                         // flag used blocks:
1191                                         // note: block processing handles extra pixel:
1192                                         _blkFlags[pix_x    &gt;&gt; _BLK_SIZE_LG] = 1;
1193                                     }
1194                                 } else {
1195                                     tmp = (x0 &amp; _SUBPIXEL_MASK_X);
1196                                     _alpha[pix_x    ]
1197                                         += (_SUBPIXEL_POSITIONS_X - tmp);
1198                                     _alpha[pix_x + 1]
1199                                         += tmp;
1200 
1201                                     pix_xmax = x1 &gt;&gt; _SUBPIXEL_LG_POSITIONS_X;
1202 
1203                                     tmp = (x1 &amp; _SUBPIXEL_MASK_X);
1204                                     _alpha[pix_xmax    ]
1205                                         -= (_SUBPIXEL_POSITIONS_X - tmp);
1206                                     _alpha[pix_xmax + 1]
1207                                         -= tmp;
1208 
1209                                     if (useBlkFlags) {
1210                                         // flag used blocks:
1211                                         // note: block processing handles extra pixel:
1212                                         _blkFlags[pix_x    &gt;&gt; _BLK_SIZE_LG] = 1;
1213                                         _blkFlags[pix_xmax &gt;&gt; _BLK_SIZE_LG] = 1;
1214                                     }
1215                                 }
1216                             }
1217                         }
1218 
1219                         sum += crorientation;
1220                         prev = curx;
1221                     }
1222                 } else {
1223                     // Non-zero winding rule: optimize that case (default)
1224                     // and avoid processing intermediate crossings
1225                     for (i = 1, sum = 0;; i++) {
1226                         sum += crorientation;
1227 
1228                         if (sum != 0) {
1229                             // prev = min(curx)
1230                             if (prev &gt; curx) {
1231                                 prev = curx;
1232                             }
1233                         } else {
1234                             // TODO: perform line clipping on left-right sides
1235                             // to avoid such bound checks:
1236                             x0 = (prev &gt; bboxx0) ? prev : bboxx0;
1237 
1238                             if (curx &lt; bboxx1) {
1239                                 x1 = curx;
1240                             } else {
1241                                 x1 = bboxx1;
1242                                 // skip right side (fast exit loop):
1243                                 i = numCrossings;
1244                             }
1245 
1246                             if (x0 &lt; x1) {
1247                                 x0 -= bboxx0; // turn x0, x1 from coords to indices
1248                                 x1 -= bboxx0; // in the alpha array.
1249 
1250                                 pix_x      =  x0      &gt;&gt; _SUBPIXEL_LG_POSITIONS_X;
1251                                 pix_xmaxm1 = (x1 - 1) &gt;&gt; _SUBPIXEL_LG_POSITIONS_X;
1252 
1253                                 if (pix_x == pix_xmaxm1) {
1254                                     // Start and end in same pixel
1255                                     tmp = (x1 - x0); // number of subpixels
1256                                     _alpha[pix_x    ] += tmp;
1257                                     _alpha[pix_x + 1] -= tmp;
1258 
1259                                     if (useBlkFlags) {
1260                                         // flag used blocks:
1261                                         // note: block processing handles extra pixel:
1262                                         _blkFlags[pix_x    &gt;&gt; _BLK_SIZE_LG] = 1;
1263                                     }
1264                                 } else {
1265                                     tmp = (x0 &amp; _SUBPIXEL_MASK_X);
1266                                     _alpha[pix_x    ]
1267                                         += (_SUBPIXEL_POSITIONS_X - tmp);
1268                                     _alpha[pix_x + 1]
1269                                         += tmp;
1270 
1271                                     pix_xmax = x1 &gt;&gt; _SUBPIXEL_LG_POSITIONS_X;
1272 
1273                                     tmp = (x1 &amp; _SUBPIXEL_MASK_X);
1274                                     _alpha[pix_xmax    ]
1275                                         -= (_SUBPIXEL_POSITIONS_X - tmp);
1276                                     _alpha[pix_xmax + 1]
1277                                         -= tmp;
1278 
1279                                     if (useBlkFlags) {
1280                                         // flag used blocks:
1281                                         // note: block processing handles extra pixel:
1282                                         _blkFlags[pix_x    &gt;&gt; _BLK_SIZE_LG] = 1;
1283                                         _blkFlags[pix_xmax &gt;&gt; _BLK_SIZE_LG] = 1;
1284                                     }
1285                                 }
1286                             }
1287                             prev = _MAX_VALUE;
1288                         }
1289 
1290                         if (i == numCrossings) {
1291                             break;
1292                         }
1293 
1294                         curxo = _crossings[i];
1295                         curx  =  curxo &gt;&gt; 1;
1296                         // to turn {0, 1} into {-1, 1}, multiply by 2 and subtract 1.
1297                         // last bit contains orientation (0 or 1)
1298                         crorientation = ((curxo &amp; 0x1) &lt;&lt; 1) - 1;
1299                     }
1300                 }
1301             } // numCrossings &gt; 0
1302 
1303             // even if this last row had no crossings, alpha will be zeroed
1304             // from the last emitRow call. But this doesn't matter because
1305             // maxX &lt; minX, so no row will be emitted to the MarlinCache.
1306             if ((y &amp; _SUBPIXEL_MASK_Y) == _SUBPIXEL_MASK_Y) {
1307                 lastY = y &gt;&gt; _SUBPIXEL_LG_POSITIONS_Y;
1308 
1309                 // convert subpixel to pixel coordinate within boundaries:
1310                 minX = FloatMath.max(minX, bboxx0) &gt;&gt; _SUBPIXEL_LG_POSITIONS_X;
1311                 maxX = FloatMath.min(maxX, bboxx1) &gt;&gt; _SUBPIXEL_LG_POSITIONS_X;
1312 
1313                 if (maxX &gt;= minX) {
1314                     // note: alpha array will be zeroed by copyAARow()
1315                     // +1 because alpha [pix_minX; pix_maxX[
1316                     // fix range [x0; x1[
1317                     // note: if x1=bboxx1, then alpha is written up to bboxx1+1
1318                     // inclusive: alpha[bboxx1] ignored, alpha[bboxx1+1] == 0
1319                     // (normally so never cleared below)
1320                     copyAARow(_alpha, lastY, minX, maxX + 1, useBlkFlags);
1321 
1322                     // speculative for next pixel row (scanline coherence):
1323                     if (_enableBlkFlagsHeuristics) {
1324                         // Use block flags if large pixel span and few crossings:
1325                         // ie mean(distance between crossings) is larger than
1326                         // 1 block size;
1327 
1328                         // fast check width:
1329                         maxX -= minX;
1330 
1331                         // if stroking: numCrossings /= 2
1332                         // =&gt; shift numCrossings by 1
1333                         // condition = (width / (numCrossings - 1)) &gt; blockSize
1334                         useBlkFlags = (maxX &gt; _BLK_SIZE) &amp;&amp; (maxX &gt;
1335                             (((numCrossings &gt;&gt; stroking) - 1) &lt;&lt; _BLK_SIZE_LG));
1336 
1337                         if (DO_STATS) {
1338                             tmp = FloatMath.max(1,
1339                                     ((numCrossings &gt;&gt; stroking) - 1));
1340                             rdrCtx.stats.hist_tile_generator_encoding_dist
1341                                 .add(maxX / tmp);
1342                         }
1343                     }
1344                 } else {
1345                     _cache.clearAARow(lastY);
1346                 }
1347                 minX = _MAX_VALUE;
1348                 maxX = _MIN_VALUE;
1349             }
1350         } // scan line iterator
1351 
1352         // Emit final row
1353         y--;
1354         y &gt;&gt;= _SUBPIXEL_LG_POSITIONS_Y;
1355 
1356         // convert subpixel to pixel coordinate within boundaries:
1357         minX = FloatMath.max(minX, bboxx0) &gt;&gt; _SUBPIXEL_LG_POSITIONS_X;
1358         maxX = FloatMath.min(maxX, bboxx1) &gt;&gt; _SUBPIXEL_LG_POSITIONS_X;
1359 
1360         if (maxX &gt;= minX) {
1361             // note: alpha array will be zeroed by copyAARow()
1362             // +1 because alpha [pix_minX; pix_maxX[
1363             // fix range [x0; x1[
1364             // note: if x1=bboxx1, then alpha is written up to bboxx1+1
1365             // inclusive: alpha[bboxx1] ignored then cleared and
1366             // alpha[bboxx1+1] == 0 (normally so never cleared after)
1367             copyAARow(_alpha, y, minX, maxX + 1, useBlkFlags);
1368         } else if (y != lastY) {
1369             _cache.clearAARow(y);
1370         }
1371 
1372         // update member:
1373         edgeCount = numCrossings;
1374         prevUseBlkFlags = useBlkFlags;
1375 
1376         if (DO_STATS) {
1377             // update max used mark
1378             activeEdgeMaxUsed = _arrayMaxUsed;
1379         }
1380     }
1381 
1382     boolean endRendering() {
1383         if (DO_MONITORS) {
1384             rdrCtx.stats.mon_rdr_endRendering.start();
1385         }
1386         if (edgeMinY == Integer.MAX_VALUE) {
1387             return false; // undefined edges bounds
1388         }
1389 
1390         // bounds as half-open intervals
1391         final int spminX = FloatMath.max(FloatMath.ceil_int(edgeMinX - 0.5d), boundsMinX);
1392         final int spmaxX = FloatMath.min(FloatMath.ceil_int(edgeMaxX - 0.5d), boundsMaxX);
1393 
1394         // edge Min/Max Y are already rounded to subpixels within bounds:
1395         final int spminY = edgeMinY;
1396         final int spmaxY = edgeMaxY;
1397 
1398         buckets_minY = spminY - boundsMinY;
1399         buckets_maxY = spmaxY - boundsMinY;
1400 
1401         if (DO_LOG_BOUNDS) {
1402             MarlinUtils.logInfo("edgesXY = [" + edgeMinX + " ... " + edgeMaxX
1403                                 + "[ [" + edgeMinY + " ... " + edgeMaxY + "[");
1404             MarlinUtils.logInfo("spXY    = [" + spminX + " ... " + spmaxX
1405                                 + "[ [" + spminY + " ... " + spmaxY + "[");
1406         }
1407 
1408         // test clipping for shapes out of bounds
1409         if ((spminX &gt;= spmaxX) || (spminY &gt;= spmaxY)) {
1410             return false;
1411         }
1412 
1413         // half open intervals
1414         // inclusive:
1415         final int pminX =  spminX                    &gt;&gt; SUBPIXEL_LG_POSITIONS_X;
1416         // exclusive:
1417         final int pmaxX = (spmaxX + SUBPIXEL_MASK_X) &gt;&gt; SUBPIXEL_LG_POSITIONS_X;
1418         // inclusive:
1419         final int pminY =  spminY                    &gt;&gt; SUBPIXEL_LG_POSITIONS_Y;
1420         // exclusive:
1421         final int pmaxY = (spmaxY + SUBPIXEL_MASK_Y) &gt;&gt; SUBPIXEL_LG_POSITIONS_Y;
1422 
1423         // store BBox to answer ptg.getBBox():
1424         this.cache.init(pminX, pminY, pmaxX, pmaxY);
1425 
1426         // Heuristics for using block flags:
1427         if (ENABLE_BLOCK_FLAGS) {
1428             enableBlkFlags = this.cache.useRLE;
1429             prevUseBlkFlags = enableBlkFlags &amp;&amp; !ENABLE_BLOCK_FLAGS_HEURISTICS;
1430 
1431             if (enableBlkFlags) {
1432                 // ensure blockFlags array is large enough:
1433                 // note: +2 to ensure enough space left at end
1434                 final int blkLen = ((pmaxX - pminX) &gt;&gt; BLOCK_SIZE_LG) + 2;
1435                 if (blkLen &gt; INITIAL_ARRAY) {
1436                     blkFlags = blkFlags_ref.getArray(blkLen);
1437                 }
1438             }
1439         }
1440 
1441         // memorize the rendering bounding box:
1442         /* note: bbox_spminX and bbox_spmaxX must be pixel boundaries
1443            to have correct coverage computation */
1444         // inclusive:
1445         bbox_spminX = pminX &lt;&lt; SUBPIXEL_LG_POSITIONS_X;
1446         // exclusive:
1447         bbox_spmaxX = pmaxX &lt;&lt; SUBPIXEL_LG_POSITIONS_X;
1448         // inclusive:
1449         bbox_spminY = spminY;
1450         // exclusive:
1451         bbox_spmaxY = spmaxY;
1452 
1453         if (DO_LOG_BOUNDS) {
1454             MarlinUtils.logInfo("pXY       = [" + pminX + " ... " + pmaxX
1455                                 + "[ [" + pminY + " ... " + pmaxY + "[");
1456             MarlinUtils.logInfo("bbox_spXY = [" + bbox_spminX + " ... "
1457                                 + bbox_spmaxX + "[ [" + bbox_spminY + " ... "
1458                                 + bbox_spmaxY + "[");
1459         }
1460 
1461         // Prepare alpha line:
1462         // add 2 to better deal with the last pixel in a pixel row.
1463         final int width = (pmaxX - pminX) + 2;
1464 
1465         // Useful when processing tile line by tile line
1466         if (width &gt; INITIAL_AA_ARRAY) {
1467             if (DO_STATS) {
1468                 rdrCtx.stats.stat_array_renderer_alphaline.add(width);
1469             }
1470             alphaLine = alphaLine_ref.getArray(width);
1471         }
1472 
1473         // process first tile line:
1474         endRendering(pminY);
1475 
1476         return true;
1477     }
1478 
1479     private int bbox_spminX, bbox_spmaxX, bbox_spminY, bbox_spmaxY;
1480 
1481     void endRendering(final int pminY) {
1482         if (DO_MONITORS) {
1483             rdrCtx.stats.mon_rdr_endRendering_Y.start();
1484         }
1485 
1486         final int spminY       = pminY &lt;&lt; SUBPIXEL_LG_POSITIONS_Y;
1487         final int fixed_spminY = FloatMath.max(bbox_spminY, spminY);
1488 
1489         // avoid rendering for last call to nextTile()
1490         if (fixed_spminY &lt; bbox_spmaxY) {
1491             // process a complete tile line ie scanlines for 32 rows
1492             final int spmaxY = FloatMath.min(bbox_spmaxY, spminY + SUBPIXEL_TILE);
1493 
1494             // process tile line [0 - 32]
1495             cache.resetTileLine(pminY);
1496 
1497             // Process only one tile line:
1498             _endRendering(fixed_spminY, spmaxY);
1499         }
1500         if (DO_MONITORS) {
1501             rdrCtx.stats.mon_rdr_endRendering_Y.stop();
1502         }
1503     }
1504 
1505     void copyAARow(final int[] alphaRow,
1506                    final int pix_y, final int pix_from, final int pix_to,
1507                    final boolean useBlockFlags)
1508     {
1509         if (DO_MONITORS) {
1510             rdrCtx.stats.mon_rdr_copyAARow.start();
1511         }
1512         if (useBlockFlags) {
1513             if (DO_STATS) {
1514                 rdrCtx.stats.hist_tile_generator_encoding.add(1);
1515             }
1516             cache.copyAARowRLE_WithBlockFlags(blkFlags, alphaRow, pix_y, pix_from, pix_to);
1517         } else {
1518             if (DO_STATS) {
1519                 rdrCtx.stats.hist_tile_generator_encoding.add(0);
1520             }
1521             cache.copyAARowNoRLE(alphaRow, pix_y, pix_from, pix_to);
1522         }
1523         if (DO_MONITORS) {
1524             rdrCtx.stats.mon_rdr_copyAARow.stop();
1525         }
1526     }
1527 }
</pre></body></html>
