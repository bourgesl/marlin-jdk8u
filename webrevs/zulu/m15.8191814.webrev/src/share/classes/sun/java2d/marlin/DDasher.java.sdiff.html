<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>jdk Sdiff src/share/classes/sun/java2d/marlin </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../../../src/share/classes/sun/java2d/marlin/DCurve.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../src/share/classes/sun/java2d/marlin/DHelpers.java.sdiff.html' target='_top'>next &gt</a></center>
<h2>src/share/classes/sun/java2d/marlin/DDasher.java</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-13694">13694</a> : <a href="https://bugs.openjdk.java.net/browse/JDK-8191814">8191814</a>: Marlin rasterizer spends time computing geometry for stroked segments that do not intersect the clip
Summary: upgrade to Marlin 0.8.2 providing efficient path clipping (Stroker and Filler)
Reviewed-by: prr, serb</pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
 120             sum += d;
 121         }
 122         double cycles = phase / sum;
 123         if (phase &lt; 0.0d) {
 124             if (-cycles &gt;= MAX_CYCLES) {
 125                 phase = 0.0d;
 126             } else {
 127                 int fullcycles = FloatMath.floor_int(-cycles);
 128                 if ((fullcycles &amp; dash.length &amp; 1) != 0) {
 129                     dashOn = !dashOn;
 130                 }
 131                 phase += fullcycles * sum;
 132                 while (phase &lt; 0.0d) {
 133                     if (--sidx &lt; 0) {
 134                         sidx = dash.length - 1;
 135                     }
 136                     phase += dash[sidx];
 137                     dashOn = !dashOn;
 138                 }
 139             }
<span class="changed"> 140         } else if (phase &gt; 0) {</span>
 141             if (cycles &gt;= MAX_CYCLES) {
 142                 phase = 0.0d;
 143             } else {
 144                 int fullcycles = FloatMath.floor_int(cycles);
 145                 if ((fullcycles &amp; dash.length &amp; 1) != 0) {
 146                     dashOn = !dashOn;
 147                 }
 148                 phase -= fullcycles * sum;
 149                 double d;
 150                 while (phase &gt;= (d = dash[sidx])) {
 151                     phase -= d;
 152                     sidx = (sidx + 1) % dash.length;
 153                     dashOn = !dashOn;
 154                 }
 155             }
 156         }
 157 
 158         this.dash = dash;
 159         this.dashLen = dashLen;
<span class="changed"> 160         this.startPhase = this.phase = phase;</span>

 161         this.startDashOn = dashOn;
 162         this.startIdx = sidx;
 163         this.starting = true;
<span class="changed"> 164         needsMoveTo = false;</span>
<span class="changed"> 165         firstSegidx = 0;</span>
 166 
 167         this.recycleDashes = recycleDashes;
 168 
 169         return this; // fluent API
 170     }
 171 
 172     /**
 173      * Disposes this dasher:
 174      * clean up before reusing this instance
 175      */
 176     void dispose() {
 177         if (DO_CLEAN_DIRTY) {
 178             // Force zero-fill dirty arrays:
 179             Arrays.fill(curCurvepts, 0.0d);
 180         }
 181         // Return arrays:
 182         if (recycleDashes) {
 183             dash = dashes_ref.putArray(dash);
 184         }
 185         firstSegmentsBuffer = firstSegmentsBuffer_ref.putArray(firstSegmentsBuffer);
 186     }
 187 
 188     double[] copyDashArray(final float[] dashes) {
 189         final int len = dashes.length;
 190         final double[] newDashes;
 191         if (len &lt;= MarlinConst.INITIAL_ARRAY) {
 192             newDashes = dashes_ref.initial;
 193         } else {
 194             if (DO_STATS) {
 195                 rdrCtx.stats.stat_array_dasher_dasher.add(len);
 196             }
 197             newDashes = dashes_ref.getArray(len);
 198         }
 199         for (int i = 0; i &lt; len; i++) { newDashes[i] = dashes[i]; }
 200         return newDashes;
 201     }
 202 
 203     @Override
<span class="changed"> 204     public void moveTo(double x0, double y0) {</span>
<span class="changed"> 205         if (firstSegidx &gt; 0) {</span>
 206             out.moveTo(sx, sy);
 207             emitFirstSegments();
 208         }
 209         needsMoveTo = true;
 210         this.idx = startIdx;
 211         this.dashOn = this.startDashOn;
 212         this.phase = this.startPhase;
<span class="changed"> 213         this.sx = this.x0 = x0;</span>
<span class="changed"> 214         this.sy = this.y0 = y0;</span>


 215         this.starting = true;
 216     }
 217 
 218     private void emitSeg(double[] buf, int off, int type) {
 219         switch (type) {
 220         case 8:
 221             out.curveTo(buf[off+0], buf[off+1],
 222                         buf[off+2], buf[off+3],
 223                         buf[off+4], buf[off+5]);
 224             return;
 225         case 6:
 226             out.quadTo(buf[off+0], buf[off+1],
 227                        buf[off+2], buf[off+3]);
 228             return;
 229         case 4:
 230             out.lineTo(buf[off], buf[off+1]);
 231             return;
 232         default:
 233         }
 234     }
 235 
 236     private void emitFirstSegments() {
 237         final double[] fSegBuf = firstSegmentsBuffer;
 238 
<span class="changed"> 239         for (int i = 0; i &lt; firstSegidx; ) {</span>
 240             int type = (int)fSegBuf[i];
 241             emitSeg(fSegBuf, i + 1, type);
 242             i += (type - 1);
 243         }
 244         firstSegidx = 0;
 245     }
 246     // We don't emit the first dash right away. If we did, caps would be
 247     // drawn on it, but we need joins to be drawn if there's a closePath()
 248     // So, we store the path elements that make up the first dash in the
 249     // buffer below.
 250     private double[] firstSegmentsBuffer; // dynamic array
 251     private int firstSegidx;
 252 
 253     // precondition: pts must be in relative coordinates (relative to x0,y0)
<span class="changed"> 254     private void goTo(double[] pts, int off, final int type) {</span>
<span class="changed"> 255         double x = pts[off + type - 4];</span>
<span class="changed"> 256         double y = pts[off + type - 3];</span>
<span class="changed"> 257         if (dashOn) {</span>














 258             if (starting) {










 259                 int len = type - 1; // - 2 + 1
 260                 int segIdx = firstSegidx;
 261                 double[] buf = firstSegmentsBuffer;

 262                 if (segIdx + len  &gt; buf.length) {
 263                     if (DO_STATS) {
 264                         rdrCtx.stats.stat_array_dasher_firstSegmentsBuffer
 265                             .add(segIdx + len);
 266                     }
 267                     firstSegmentsBuffer = buf
 268                         = firstSegmentsBuffer_ref.widenArray(buf, segIdx,
 269                                                              segIdx + len);
 270                 }
 271                 buf[segIdx++] = type;
 272                 len--;
 273                 // small arraycopy (2, 4 or 6) but with offset:
 274                 System.arraycopy(pts, off, buf, segIdx, len);
<span class="changed"> 275                 segIdx += len;</span>
<span class="changed"> 276                 firstSegidx = segIdx;</span>
<span class="changed"> 277             } else {</span>
<span class="changed"> 278                 if (needsMoveTo) {</span>
<span class="changed"> 279                     out.moveTo(x0, y0);</span>
<span class="changed"> 280                     needsMoveTo = false;</span>
<span class="changed"> 281                 }</span>
<span class="changed"> 282                 emitSeg(pts, off, type);</span>
<span class="changed"> 283             }</span>
<span class="changed"> 284         } else {</span>
<span class="changed"> 285             starting = false;</span>
<span class="changed"> 286             needsMoveTo = true;</span>
<span class="changed"> 287         }</span>
<span class="changed"> 288         this.x0 = x;</span>
<span class="changed"> 289         this.y0 = y;</span>
 290     }
 291 
 292     @Override
<span class="changed"> 293     public void lineTo(double x1, double y1) {</span>
<span class="changed"> 294         double dx = x1 - x0;</span>
<span class="changed"> 295         double dy = y1 - y0;</span>
 296 
 297         double len = dx*dx + dy*dy;
 298         if (len == 0.0d) {
 299             return;
 300         }
 301         len = Math.sqrt(len);
 302 
 303         // The scaling factors needed to get the dx and dy of the
 304         // transformed dash segments.
 305         final double cx = dx / len;
 306         final double cy = dy / len;
 307 
 308         final double[] _curCurvepts = curCurvepts;
 309         final double[] _dash = dash;





 310 
 311         double leftInThisDashSegment;
<span class="changed"> 312         double dashdx, dashdy, p;</span>
 313 
 314         while (true) {
<span class="changed"> 315             leftInThisDashSegment = _dash[idx] - phase;</span>

 316 
 317             if (len &lt;= leftInThisDashSegment) {
 318                 _curCurvepts[0] = x1;
 319                 _curCurvepts[1] = y1;
<span class="changed"> 320                 goTo(_curCurvepts, 0, 4);</span>

 321 
 322                 // Advance phase within current dash segment
<span class="changed"> 323                 phase += len;</span>

 324                 // TODO: compare double values using epsilon:
 325                 if (len == leftInThisDashSegment) {
<span class="changed"> 326                     phase = 0.0d;</span>
<span class="changed"> 327                     idx = (idx + 1) % dashLen;</span>
<span class="changed"> 328                     dashOn = !dashOn;</span>
 329                 }





 330                 return;
 331             }
 332 
<span class="changed"> 333             dashdx = _dash[idx] * cx;</span>
<span class="changed"> 334             dashdy = _dash[idx] * cy;</span>
 335 
<span class="changed"> 336             if (phase == 0.0d) {</span>
 337                 _curCurvepts[0] = x0 + dashdx;
 338                 _curCurvepts[1] = y0 + dashdy;
 339             } else {
<span class="changed"> 340                 p = leftInThisDashSegment / _dash[idx];</span>
 341                 _curCurvepts[0] = x0 + p * dashdx;
 342                 _curCurvepts[1] = y0 + p * dashdy;
 343             }
 344 
<span class="changed"> 345             goTo(_curCurvepts, 0, 4);</span>
 346 
 347             len -= leftInThisDashSegment;
 348             // Advance to next dash segment
<span class="changed"> 349             idx = (idx + 1) % dashLen;</span>
<span class="changed"> 350             dashOn = !dashOn;</span>
<span class="changed"> 351             phase = 0.0d;</span>
 352         }
 353     }
 354 
 355     // shared instance in DDasher
 356     private final LengthIterator li = new LengthIterator();
 357 
 358     // preconditions: curCurvepts must be an array of length at least 2 * type,
 359     // that contains the curve we want to dash in the first type elements
<span class="changed"> 360     private void somethingTo(int type) {</span>
 361         if (pointCurve(curCurvepts, type)) {
 362             return;
 363         }
<span class="changed"> 364         li.initializeIterationOnCurve(curCurvepts, type);</span>









 365 
 366         // initially the current curve is at curCurvepts[0...type]
 367         int curCurveoff = 0;
 368         double lastSplitT = 0.0d;
 369         double t;
<span class="changed"> 370         double leftInThisDashSegment = dash[idx] - phase;</span>
 371 
<span class="changed"> 372         while ((t = li.next(leftInThisDashSegment)) &lt; 1.0d) {</span>
 373             if (t != 0.0d) {
 374                 DHelpers.subdivideAt((t - lastSplitT) / (1.0d - lastSplitT),
<span class="changed"> 375                                     curCurvepts, curCurveoff,</span>
<span class="changed"> 376                                     curCurvepts, 0,</span>
<span class="changed"> 377                                     curCurvepts, type, type);</span>
 378                 lastSplitT = t;
<span class="changed"> 379                 goTo(curCurvepts, 2, type);</span>
 380                 curCurveoff = type;
 381             }
 382             // Advance to next dash segment
<span class="changed"> 383             idx = (idx + 1) % dashLen;</span>
<span class="changed"> 384             dashOn = !dashOn;</span>
<span class="changed"> 385             phase = 0.0d;</span>
<span class="changed"> 386             leftInThisDashSegment = dash[idx];</span>
<span class="changed"> 387         }</span>
<span class="changed"> 388         goTo(curCurvepts, curCurveoff+2, type);</span>
<span class="changed"> 389         phase += li.lastSegLen();</span>
<span class="changed"> 390         if (phase &gt;= dash[idx]) {</span>
<span class="changed"> 391             phase = 0.0d;</span>
<span class="changed"> 392             idx = (idx + 1) % dashLen;</span>
<span class="changed"> 393             dashOn = !dashOn;</span>
<span class="changed"> 394         }</span>







 395         // reset LengthIterator:
<span class="changed"> 396         li.reset();</span>
 397     }
 398 
 399     private static boolean pointCurve(double[] curve, int type) {
 400         for (int i = 2; i &lt; type; i++) {
 401             if (curve[i] != curve[i-2]) {
 402                 return false;
 403             }
 404         }
 405         return true;
 406     }
 407 
 408     // Objects of this class are used to iterate through curves. They return
 409     // t values where the left side of the curve has a specified length.
 410     // It does this by subdividing the input curve until a certain error
 411     // condition has been met. A recursive subdivision procedure would
 412     // return as many as 1&lt;&lt;limit curves, but this is an iterator and we
 413     // don't need all the curves all at once, so what we carry out a
 414     // lazy inorder traversal of the recursion tree (meaning we only move
 415     // through the tree when we need the next subdivided curve). This saves
 416     // us a lot of memory because at any one time we only need to store
 417     // limit+1 curves - one for each level of the tree + 1.
 418     // NOTE: the way we do things here is not enough to traverse a general
 419     // tree; however, the trees we are interested in have the property that
 420     // every non leaf node has exactly 2 children
 421     static final class LengthIterator {
<span class="changed"> 422         private enum Side {LEFT, RIGHT};</span>
 423         // Holds the curves at various levels of the recursion. The root
 424         // (i.e. the original curve) is at recCurveStack[0] (but then it
 425         // gets subdivided, the left half is put at 1, so most of the time
 426         // only the right half of the original curve is at 0)
 427         private final double[][] recCurveStack; // dirty
 428         // sides[i] indicates whether the node at level i+1 in the path from
 429         // the root to the current leaf is a left or right child of its parent.
 430         private final Side[] sides; // dirty
 431         private int curveType;
 432         // lastT and nextT delimit the current leaf.
 433         private double nextT;
 434         private double lenAtNextT;
 435         private double lastT;
 436         private double lenAtLastT;
 437         private double lenAtLastSplit;
 438         private double lastSegLen;
 439         // the current level in the recursion tree. 0 is the root. limit
 440         // is the deepest possible leaf.
 441         private int recLevel;
 442         private boolean done;

</pre><hr></hr><pre>
 652                 lastT = nextT;
 653                 lenAtLastT = lenAtNextT;
 654                 nextT += (1 &lt;&lt; (REC_LIMIT - recLevel)) * MIN_T_INC;
 655                 lenAtNextT += len;
 656                 // invalidate caches
 657                 flatLeafCoefCache[2] = -1.0d;
 658                 cachedHaveLowAcceleration = -1;
 659             } else {
 660                 DHelpers.subdivide(recCurveStack[recLevel], 0,
 661                                   recCurveStack[recLevel+1], 0,
 662                                   recCurveStack[recLevel], 0, curveType);
 663                 sides[recLevel] = Side.LEFT;
 664                 recLevel++;
 665                 goLeft();
 666             }
 667         }
 668 
 669         // this is a bit of a hack. It returns -1 if we're not on a leaf, and
 670         // the length of the leaf if we are on a leaf.
 671         private double onLeaf() {
<span class="changed"> 672             double[] curve = recCurveStack[recLevel];</span>

 673             double polyLen = 0.0d;
 674 
 675             double x0 = curve[0], y0 = curve[1];
<span class="changed"> 676             for (int i = 2; i &lt; curveType; i += 2) {</span>
 677                 final double x1 = curve[i], y1 = curve[i+1];
 678                 final double len = DHelpers.linelen(x0, y0, x1, y1);
 679                 polyLen += len;
<span class="changed"> 680                 curLeafCtrlPolyLengths[i/2 - 1] = len;</span>
 681                 x0 = x1;
 682                 y0 = y1;
 683             }
 684 
 685             final double lineLen = DHelpers.linelen(curve[0], curve[1],
<span class="changed"> 686                                                   curve[curveType-2],</span>
<span class="changed"> 687                                                   curve[curveType-1]);</span>
 688             if ((polyLen - lineLen) &lt; ERR || recLevel == REC_LIMIT) {
 689                 return (polyLen + lineLen) / 2.0d;
 690             }
 691             return -1.0d;
 692         }
 693     }
 694 
 695     @Override
<span class="changed"> 696     public void curveTo(double x1, double y1,</span>
<span class="changed"> 697                         double x2, double y2,</span>
<span class="changed"> 698                         double x3, double y3)</span>
 699     {
 700         final double[] _curCurvepts = curCurvepts;
 701         _curCurvepts[0] = x0;        _curCurvepts[1] = y0;
 702         _curCurvepts[2] = x1;        _curCurvepts[3] = y1;
 703         _curCurvepts[4] = x2;        _curCurvepts[5] = y2;
 704         _curCurvepts[6] = x3;        _curCurvepts[7] = y3;
 705         somethingTo(8);
 706     }
 707 
 708     @Override
<span class="changed"> 709     public void quadTo(double x1, double y1, double x2, double y2) {</span>


 710         final double[] _curCurvepts = curCurvepts;
 711         _curCurvepts[0] = x0;        _curCurvepts[1] = y0;
 712         _curCurvepts[2] = x1;        _curCurvepts[3] = y1;
 713         _curCurvepts[4] = x2;        _curCurvepts[5] = y2;
 714         somethingTo(6);
 715     }
 716 
 717     @Override
 718     public void closePath() {
 719         lineTo(sx, sy);
<span class="changed"> 720         if (firstSegidx &gt; 0) {</span>
 721             if (!dashOn || needsMoveTo) {
 722                 out.moveTo(sx, sy);
 723             }
 724             emitFirstSegments();
 725         }
 726         moveTo(sx, sy);
 727     }
 728 
 729     @Override
 730     public void pathDone() {
<span class="changed"> 731         if (firstSegidx &gt; 0) {</span>
 732             out.moveTo(sx, sy);
 733             emitFirstSegments();
 734         }
 735         out.pathDone();
 736 
 737         // Dispose this instance:
 738         dispose();
 739     }
 740 
 741     @Override
 742     public long getNativeConsumer() {
 743         throw new InternalError("DDasher does not use a native consumer");
 744     }
 745 }
 746 
</pre></td><td><pre>

</pre><hr></hr><pre>
 120             sum += d;
 121         }
 122         double cycles = phase / sum;
 123         if (phase &lt; 0.0d) {
 124             if (-cycles &gt;= MAX_CYCLES) {
 125                 phase = 0.0d;
 126             } else {
 127                 int fullcycles = FloatMath.floor_int(-cycles);
 128                 if ((fullcycles &amp; dash.length &amp; 1) != 0) {
 129                     dashOn = !dashOn;
 130                 }
 131                 phase += fullcycles * sum;
 132                 while (phase &lt; 0.0d) {
 133                     if (--sidx &lt; 0) {
 134                         sidx = dash.length - 1;
 135                     }
 136                     phase += dash[sidx];
 137                     dashOn = !dashOn;
 138                 }
 139             }
<span class="changed"> 140         } else if (phase &gt; 0.0d) {</span>
 141             if (cycles &gt;= MAX_CYCLES) {
 142                 phase = 0.0d;
 143             } else {
 144                 int fullcycles = FloatMath.floor_int(cycles);
 145                 if ((fullcycles &amp; dash.length &amp; 1) != 0) {
 146                     dashOn = !dashOn;
 147                 }
 148                 phase -= fullcycles * sum;
 149                 double d;
 150                 while (phase &gt;= (d = dash[sidx])) {
 151                     phase -= d;
 152                     sidx = (sidx + 1) % dash.length;
 153                     dashOn = !dashOn;
 154                 }
 155             }
 156         }
 157 
 158         this.dash = dash;
 159         this.dashLen = dashLen;
<span class="changed"> 160         this.phase = phase;</span>
<span class="changed"> 161         this.startPhase = phase;</span>
 162         this.startDashOn = dashOn;
 163         this.startIdx = sidx;
 164         this.starting = true;
<span class="changed"> 165         this.needsMoveTo = false;</span>
<span class="changed"> 166         this.firstSegidx = 0;</span>
 167 
 168         this.recycleDashes = recycleDashes;
 169 
 170         return this; // fluent API
 171     }
 172 
 173     /**
 174      * Disposes this dasher:
 175      * clean up before reusing this instance
 176      */
 177     void dispose() {
 178         if (DO_CLEAN_DIRTY) {
 179             // Force zero-fill dirty arrays:
 180             Arrays.fill(curCurvepts, 0.0d);
 181         }
 182         // Return arrays:
 183         if (recycleDashes) {
 184             dash = dashes_ref.putArray(dash);
 185         }
 186         firstSegmentsBuffer = firstSegmentsBuffer_ref.putArray(firstSegmentsBuffer);
 187     }
 188 
 189     double[] copyDashArray(final float[] dashes) {
 190         final int len = dashes.length;
 191         final double[] newDashes;
 192         if (len &lt;= MarlinConst.INITIAL_ARRAY) {
 193             newDashes = dashes_ref.initial;
 194         } else {
 195             if (DO_STATS) {
 196                 rdrCtx.stats.stat_array_dasher_dasher.add(len);
 197             }
 198             newDashes = dashes_ref.getArray(len);
 199         }
 200         for (int i = 0; i &lt; len; i++) { newDashes[i] = dashes[i]; }
 201         return newDashes;
 202     }
 203 
 204     @Override
<span class="changed"> 205     public void moveTo(final double x0, final double y0) {</span>
<span class="changed"> 206         if (firstSegidx != 0) {</span>
 207             out.moveTo(sx, sy);
 208             emitFirstSegments();
 209         }
 210         needsMoveTo = true;
 211         this.idx = startIdx;
 212         this.dashOn = this.startDashOn;
 213         this.phase = this.startPhase;
<span class="changed"> 214         this.sx = x0;</span>
<span class="changed"> 215         this.sy = y0;</span>
<span class="changed"> 216         this.x0 = x0;</span>
<span class="changed"> 217         this.y0 = y0;</span>
 218         this.starting = true;
 219     }
 220 
 221     private void emitSeg(double[] buf, int off, int type) {
 222         switch (type) {
 223         case 8:
 224             out.curveTo(buf[off+0], buf[off+1],
 225                         buf[off+2], buf[off+3],
 226                         buf[off+4], buf[off+5]);
 227             return;
 228         case 6:
 229             out.quadTo(buf[off+0], buf[off+1],
 230                        buf[off+2], buf[off+3]);
 231             return;
 232         case 4:
 233             out.lineTo(buf[off], buf[off+1]);
 234             return;
 235         default:
 236         }
 237     }
 238 
 239     private void emitFirstSegments() {
 240         final double[] fSegBuf = firstSegmentsBuffer;
 241 
<span class="changed"> 242         for (int i = 0, len = firstSegidx; i &lt; len; ) {</span>
 243             int type = (int)fSegBuf[i];
 244             emitSeg(fSegBuf, i + 1, type);
 245             i += (type - 1);
 246         }
 247         firstSegidx = 0;
 248     }
 249     // We don't emit the first dash right away. If we did, caps would be
 250     // drawn on it, but we need joins to be drawn if there's a closePath()
 251     // So, we store the path elements that make up the first dash in the
 252     // buffer below.
 253     private double[] firstSegmentsBuffer; // dynamic array
 254     private int firstSegidx;
 255 
 256     // precondition: pts must be in relative coordinates (relative to x0,y0)
<span class="changed"> 257     private void goTo(final double[] pts, final int off, final int type,</span>
<span class="changed"> 258                       final boolean on)</span>
<span class="changed"> 259     {</span>
<span class="changed"> 260         final int index = off + type;</span>
<span class="changed"> 261         final double x = pts[index - 4];</span>
<span class="changed"> 262         final double y = pts[index - 3];</span>
<span class="changed"> 263 </span>
<span class="changed"> 264         if (on) {</span>
<span class="changed"> 265             if (starting) {</span>
<span class="changed"> 266                 goTo_starting(pts, off, type);</span>
<span class="changed"> 267             } else {</span>
<span class="changed"> 268                 if (needsMoveTo) {</span>
<span class="changed"> 269                     needsMoveTo = false;</span>
<span class="changed"> 270                     out.moveTo(x0, y0);</span>
<span class="changed"> 271                 }</span>
<span class="changed"> 272                 emitSeg(pts, off, type);</span>
<span class="changed"> 273             }</span>
<span class="changed"> 274         } else {</span>
 275             if (starting) {
<span class="new"> 276                 // low probability test (hotspot)</span>
<span class="new"> 277                 starting = false;</span>
<span class="new"> 278             }</span>
<span class="new"> 279             needsMoveTo = true;</span>
<span class="new"> 280         }</span>
<span class="new"> 281         this.x0 = x;</span>
<span class="new"> 282         this.y0 = y;</span>
<span class="new"> 283     }</span>
<span class="new"> 284 </span>
<span class="new"> 285     private void goTo_starting(final double[] pts, final int off, final int type) {</span>
 286         int len = type - 1; // - 2 + 1
 287         int segIdx = firstSegidx;
 288         double[] buf = firstSegmentsBuffer;
<span class="new"> 289 </span>
 290         if (segIdx + len  &gt; buf.length) {
 291             if (DO_STATS) {
 292                 rdrCtx.stats.stat_array_dasher_firstSegmentsBuffer
 293                     .add(segIdx + len);
 294             }
 295             firstSegmentsBuffer = buf
 296                 = firstSegmentsBuffer_ref.widenArray(buf, segIdx,
 297                                                      segIdx + len);
 298         }
 299         buf[segIdx++] = type;
 300         len--;
 301         // small arraycopy (2, 4 or 6) but with offset:
 302         System.arraycopy(pts, off, buf, segIdx, len);
<span class="changed"> 303         firstSegidx = segIdx + len;</span>














 304     }
 305 
 306     @Override
<span class="changed"> 307     public void lineTo(final double x1, final double y1) {</span>
<span class="changed"> 308         final double dx = x1 - x0;</span>
<span class="changed"> 309         final double dy = y1 - y0;</span>
 310 
 311         double len = dx*dx + dy*dy;
 312         if (len == 0.0d) {
 313             return;
 314         }
 315         len = Math.sqrt(len);
 316 
 317         // The scaling factors needed to get the dx and dy of the
 318         // transformed dash segments.
 319         final double cx = dx / len;
 320         final double cy = dy / len;
 321 
 322         final double[] _curCurvepts = curCurvepts;
 323         final double[] _dash = dash;
<span class="new"> 324         final int _dashLen = this.dashLen;</span>
<span class="new"> 325 </span>
<span class="new"> 326         int _idx = idx;</span>
<span class="new"> 327         boolean _dashOn = dashOn;</span>
<span class="new"> 328         double _phase = phase;</span>
 329 
 330         double leftInThisDashSegment;
<span class="changed"> 331         double d, dashdx, dashdy, p;</span>
 332 
 333         while (true) {
<span class="changed"> 334             d = _dash[_idx];</span>
<span class="changed"> 335             leftInThisDashSegment = d - _phase;</span>
 336 
 337             if (len &lt;= leftInThisDashSegment) {
 338                 _curCurvepts[0] = x1;
 339                 _curCurvepts[1] = y1;
<span class="changed"> 340 </span>
<span class="changed"> 341                 goTo(_curCurvepts, 0, 4, _dashOn);</span>
 342 
 343                 // Advance phase within current dash segment
<span class="changed"> 344                 _phase += len;</span>
<span class="changed"> 345 </span>
 346                 // TODO: compare double values using epsilon:
 347                 if (len == leftInThisDashSegment) {
<span class="changed"> 348                     _phase = 0.0d;</span>
<span class="changed"> 349                     _idx = (_idx + 1) % _dashLen;</span>
<span class="changed"> 350                     _dashOn = !_dashOn;</span>
 351                 }
<span class="new"> 352 </span>
<span class="new"> 353                 // Save local state:</span>
<span class="new"> 354                 idx = _idx;</span>
<span class="new"> 355                 dashOn = _dashOn;</span>
<span class="new"> 356                 phase = _phase;</span>
 357                 return;
 358             }
 359 
<span class="changed"> 360             dashdx = d * cx;</span>
<span class="changed"> 361             dashdy = d * cy;</span>
 362 
<span class="changed"> 363             if (_phase == 0.0d) {</span>
 364                 _curCurvepts[0] = x0 + dashdx;
 365                 _curCurvepts[1] = y0 + dashdy;
 366             } else {
<span class="changed"> 367                 p = leftInThisDashSegment / d;</span>
 368                 _curCurvepts[0] = x0 + p * dashdx;
 369                 _curCurvepts[1] = y0 + p * dashdy;
 370             }
 371 
<span class="changed"> 372             goTo(_curCurvepts, 0, 4, _dashOn);</span>
 373 
 374             len -= leftInThisDashSegment;
 375             // Advance to next dash segment
<span class="changed"> 376             _idx = (_idx + 1) % _dashLen;</span>
<span class="changed"> 377             _dashOn = !_dashOn;</span>
<span class="changed"> 378             _phase = 0.0d;</span>
 379         }
 380     }
 381 
 382     // shared instance in DDasher
 383     private final LengthIterator li = new LengthIterator();
 384 
 385     // preconditions: curCurvepts must be an array of length at least 2 * type,
 386     // that contains the curve we want to dash in the first type elements
<span class="changed"> 387     private void somethingTo(final int type) {</span>
 388         if (pointCurve(curCurvepts, type)) {
 389             return;
 390         }
<span class="changed"> 391         final LengthIterator _li = li;</span>
<span class="changed"> 392         final double[] _curCurvepts = curCurvepts;</span>
<span class="changed"> 393         final double[] _dash = dash;</span>
<span class="changed"> 394         final int _dashLen = this.dashLen;</span>
<span class="changed"> 395 </span>
<span class="changed"> 396         _li.initializeIterationOnCurve(_curCurvepts, type);</span>
<span class="changed"> 397 </span>
<span class="changed"> 398         int _idx = idx;</span>
<span class="changed"> 399         boolean _dashOn = dashOn;</span>
<span class="changed"> 400         double _phase = phase;</span>
 401 
 402         // initially the current curve is at curCurvepts[0...type]
 403         int curCurveoff = 0;
 404         double lastSplitT = 0.0d;
 405         double t;
<span class="changed"> 406         double leftInThisDashSegment = _dash[_idx] - _phase;</span>
 407 
<span class="changed"> 408         while ((t = _li.next(leftInThisDashSegment)) &lt; 1.0d) {</span>
 409             if (t != 0.0d) {
 410                 DHelpers.subdivideAt((t - lastSplitT) / (1.0d - lastSplitT),
<span class="changed"> 411                                     _curCurvepts, curCurveoff,</span>
<span class="changed"> 412                                     _curCurvepts, 0,</span>
<span class="changed"> 413                                     _curCurvepts, type, type);</span>
 414                 lastSplitT = t;
<span class="changed"> 415                 goTo(_curCurvepts, 2, type, _dashOn);</span>
 416                 curCurveoff = type;
 417             }
 418             // Advance to next dash segment
<span class="changed"> 419             _idx = (_idx + 1) % _dashLen;</span>
<span class="changed"> 420             _dashOn = !_dashOn;</span>
<span class="changed"> 421             _phase = 0.0d;</span>
<span class="changed"> 422             leftInThisDashSegment = _dash[_idx];</span>
<span class="changed"> 423         }</span>
<span class="changed"> 424 </span>
<span class="changed"> 425         goTo(_curCurvepts, curCurveoff + 2, type, _dashOn);</span>
<span class="changed"> 426 </span>
<span class="changed"> 427         _phase += _li.lastSegLen();</span>
<span class="changed"> 428         if (_phase &gt;= _dash[_idx]) {</span>
<span class="changed"> 429             _phase = 0.0d;</span>
<span class="changed"> 430             _idx = (_idx + 1) % _dashLen;</span>
<span class="changed"> 431             _dashOn = !_dashOn;</span>
<span class="changed"> 432         }</span>
<span class="changed"> 433         // Save local state:</span>
<span class="changed"> 434         idx = _idx;</span>
<span class="changed"> 435         dashOn = _dashOn;</span>
<span class="changed"> 436         phase = _phase;</span>
<span class="changed"> 437 </span>
 438         // reset LengthIterator:
<span class="changed"> 439         _li.reset();</span>
 440     }
 441 
 442     private static boolean pointCurve(double[] curve, int type) {
 443         for (int i = 2; i &lt; type; i++) {
 444             if (curve[i] != curve[i-2]) {
 445                 return false;
 446             }
 447         }
 448         return true;
 449     }
 450 
 451     // Objects of this class are used to iterate through curves. They return
 452     // t values where the left side of the curve has a specified length.
 453     // It does this by subdividing the input curve until a certain error
 454     // condition has been met. A recursive subdivision procedure would
 455     // return as many as 1&lt;&lt;limit curves, but this is an iterator and we
 456     // don't need all the curves all at once, so what we carry out a
 457     // lazy inorder traversal of the recursion tree (meaning we only move
 458     // through the tree when we need the next subdivided curve). This saves
 459     // us a lot of memory because at any one time we only need to store
 460     // limit+1 curves - one for each level of the tree + 1.
 461     // NOTE: the way we do things here is not enough to traverse a general
 462     // tree; however, the trees we are interested in have the property that
 463     // every non leaf node has exactly 2 children
 464     static final class LengthIterator {
<span class="changed"> 465         private enum Side {LEFT, RIGHT}</span>
 466         // Holds the curves at various levels of the recursion. The root
 467         // (i.e. the original curve) is at recCurveStack[0] (but then it
 468         // gets subdivided, the left half is put at 1, so most of the time
 469         // only the right half of the original curve is at 0)
 470         private final double[][] recCurveStack; // dirty
 471         // sides[i] indicates whether the node at level i+1 in the path from
 472         // the root to the current leaf is a left or right child of its parent.
 473         private final Side[] sides; // dirty
 474         private int curveType;
 475         // lastT and nextT delimit the current leaf.
 476         private double nextT;
 477         private double lenAtNextT;
 478         private double lastT;
 479         private double lenAtLastT;
 480         private double lenAtLastSplit;
 481         private double lastSegLen;
 482         // the current level in the recursion tree. 0 is the root. limit
 483         // is the deepest possible leaf.
 484         private int recLevel;
 485         private boolean done;

</pre><hr></hr><pre>
 695                 lastT = nextT;
 696                 lenAtLastT = lenAtNextT;
 697                 nextT += (1 &lt;&lt; (REC_LIMIT - recLevel)) * MIN_T_INC;
 698                 lenAtNextT += len;
 699                 // invalidate caches
 700                 flatLeafCoefCache[2] = -1.0d;
 701                 cachedHaveLowAcceleration = -1;
 702             } else {
 703                 DHelpers.subdivide(recCurveStack[recLevel], 0,
 704                                   recCurveStack[recLevel+1], 0,
 705                                   recCurveStack[recLevel], 0, curveType);
 706                 sides[recLevel] = Side.LEFT;
 707                 recLevel++;
 708                 goLeft();
 709             }
 710         }
 711 
 712         // this is a bit of a hack. It returns -1 if we're not on a leaf, and
 713         // the length of the leaf if we are on a leaf.
 714         private double onLeaf() {
<span class="changed"> 715             final double[] curve = recCurveStack[recLevel];</span>
<span class="changed"> 716             final int _curveType = curveType;</span>
 717             double polyLen = 0.0d;
 718 
 719             double x0 = curve[0], y0 = curve[1];
<span class="changed"> 720             for (int i = 2; i &lt; _curveType; i += 2) {</span>
 721                 final double x1 = curve[i], y1 = curve[i+1];
 722                 final double len = DHelpers.linelen(x0, y0, x1, y1);
 723                 polyLen += len;
<span class="changed"> 724                 curLeafCtrlPolyLengths[(i &gt;&gt; 1) - 1] = len;</span>
 725                 x0 = x1;
 726                 y0 = y1;
 727             }
 728 
 729             final double lineLen = DHelpers.linelen(curve[0], curve[1],
<span class="changed"> 730                                                     curve[_curveType-2],</span>
<span class="changed"> 731                                                     curve[_curveType-1]);</span>
 732             if ((polyLen - lineLen) &lt; ERR || recLevel == REC_LIMIT) {
 733                 return (polyLen + lineLen) / 2.0d;
 734             }
 735             return -1.0d;
 736         }
 737     }
 738 
 739     @Override
<span class="changed"> 740     public void curveTo(final double x1, final double y1,</span>
<span class="changed"> 741                         final double x2, final double y2,</span>
<span class="changed"> 742                         final double x3, final double y3)</span>
 743     {
 744         final double[] _curCurvepts = curCurvepts;
 745         _curCurvepts[0] = x0;        _curCurvepts[1] = y0;
 746         _curCurvepts[2] = x1;        _curCurvepts[3] = y1;
 747         _curCurvepts[4] = x2;        _curCurvepts[5] = y2;
 748         _curCurvepts[6] = x3;        _curCurvepts[7] = y3;
 749         somethingTo(8);
 750     }
 751 
 752     @Override
<span class="changed"> 753     public void quadTo(final double x1, final double y1,</span>
<span class="changed"> 754                        final double x2, final double y2)</span>
<span class="changed"> 755     {</span>
 756         final double[] _curCurvepts = curCurvepts;
 757         _curCurvepts[0] = x0;        _curCurvepts[1] = y0;
 758         _curCurvepts[2] = x1;        _curCurvepts[3] = y1;
 759         _curCurvepts[4] = x2;        _curCurvepts[5] = y2;
 760         somethingTo(6);
 761     }
 762 
 763     @Override
 764     public void closePath() {
 765         lineTo(sx, sy);
<span class="changed"> 766         if (firstSegidx != 0) {</span>
 767             if (!dashOn || needsMoveTo) {
 768                 out.moveTo(sx, sy);
 769             }
 770             emitFirstSegments();
 771         }
 772         moveTo(sx, sy);
 773     }
 774 
 775     @Override
 776     public void pathDone() {
<span class="changed"> 777         if (firstSegidx != 0) {</span>
 778             out.moveTo(sx, sy);
 779             emitFirstSegments();
 780         }
 781         out.pathDone();
 782 
 783         // Dispose this instance:
 784         dispose();
 785     }
 786 
 787     @Override
 788     public long getNativeConsumer() {
 789         throw new InternalError("DDasher does not use a native consumer");
 790     }
 791 }
 792 
</pre></td>
</tr></table>
<center><a href='../../../../../../src/share/classes/sun/java2d/marlin/DCurve.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../src/share/classes/sun/java2d/marlin/DHelpers.java.sdiff.html' target='_top'>next &gt</a></center>
</body></html>
