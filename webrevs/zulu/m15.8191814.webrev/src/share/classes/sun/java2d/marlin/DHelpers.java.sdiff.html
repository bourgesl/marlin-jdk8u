<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>jdk Sdiff src/share/classes/sun/java2d/marlin </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../../../src/share/classes/sun/java2d/marlin/DDasher.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../src/share/classes/sun/java2d/marlin/DMarlinRenderingEngine.java.sdiff.html' target='_top'>next &gt</a></center>
<h2>src/share/classes/sun/java2d/marlin/DHelpers.java</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-13694">13694</a> : <a href="https://bugs.openjdk.java.net/browse/JDK-8191814">8191814</a>: Marlin rasterizer spends time computing geometry for stroked segments that do not intersect the clip
Summary: upgrade to Marlin 0.8.2 providing efficient path clipping (Stroker and Filler)
Reviewed-by: prr, serb</pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.java2d.marlin;
  27 
  28 import static java.lang.Math.PI;
<span class="changed">  29 import static java.lang.Math.cos;</span>
<span class="changed">  30 import static java.lang.Math.sqrt;</span>
<span class="changed">  31 import static java.lang.Math.cbrt;</span>
<span class="changed">  32 import static java.lang.Math.acos;</span>
  33 
  34 final class DHelpers implements MarlinConst {
  35 
  36     private DHelpers() {
  37         throw new Error("This is a non instantiable class");
  38     }
  39 
  40     static boolean within(final double x, final double y, final double err) {
  41         final double d = y - x;
  42         return (d &lt;= err &amp;&amp; d &gt;= -err);
  43     }
  44 
  45     static int quadraticRoots(final double a, final double b,
  46                               final double c, double[] zeroes, final int off)
  47     {
  48         int ret = off;
  49         double t;
  50         if (a != 0.0d) {
  51             final double dis = b*b - 4*a*c;
  52             if (dis &gt; 0.0d) {

</pre><hr></hr><pre>
  98         //  substitute x = y - A/3 to eliminate quadratic term:
  99         //     x^3 +Px + Q = 0
 100         //
 101         // Since we actually need P/3 and Q/2 for all of the
 102         // calculations that follow, we will calculate
 103         // p = P/3
 104         // q = Q/2
 105         // instead and use those values for simplicity of the code.
 106         double sq_A = a * a;
 107         double p = (1.0d/3.0d) * ((-1.0d/3.0d) * sq_A + b);
 108         double q = (1.0d/2.0d) * ((2.0d/27.0d) * a * sq_A - (1.0d/3.0d) * a * b + c);
 109 
 110         // use Cardano's formula
 111 
 112         double cb_p = p * p * p;
 113         double D = q * q + cb_p;
 114 
 115         int num;
 116         if (D &lt; 0.0d) {
 117             // see: http://en.wikipedia.org/wiki/Cubic_function#Trigonometric_.28and_hyperbolic.29_method
<span class="changed"> 118             final double phi = (1.0d/3.0d) * acos(-q / sqrt(-cb_p));</span>
<span class="changed"> 119             final double t = 2.0d * sqrt(-p);</span>
 120 
<span class="changed"> 121             pts[ off+0 ] = ( t * cos(phi));</span>
<span class="changed"> 122             pts[ off+1 ] = (-t * cos(phi + (PI / 3.0d)));</span>
<span class="changed"> 123             pts[ off+2 ] = (-t * cos(phi - (PI / 3.0d)));</span>
 124             num = 3;
 125         } else {
<span class="changed"> 126             final double sqrt_D = sqrt(D);</span>
<span class="changed"> 127             final double u = cbrt(sqrt_D - q);</span>
<span class="changed"> 128             final double v = - cbrt(sqrt_D + q);</span>
 129 
 130             pts[ off ] = (u + v);
 131             num = 1;
 132 
 133             if (within(D, 0.0d, 1e-8d)) {
 134                 pts[off+1] = -(pts[off] / 2.0d);
 135                 num = 2;
 136             }
 137         }
 138 
 139         final double sub = (1.0d/3.0d) * a;
 140 
 141         for (int i = 0; i &lt; num; ++i) {
 142             pts[ off+i ] -= sub;
 143         }
 144 
 145         return filterOutNotInAB(pts, off, num, A, B) - off;
 146     }
 147 
 148     static double evalCubic(final double a, final double b,

</pre><hr></hr><pre>
 154 
 155     static double evalQuad(final double a, final double b,
 156                           final double c, final double t)
 157     {
 158         return t * (t * a + b) + c;
 159     }
 160 
 161     // returns the index 1 past the last valid element remaining after filtering
 162     static int filterOutNotInAB(double[] nums, final int off, final int len,
 163                                 final double a, final double b)
 164     {
 165         int ret = off;
 166         for (int i = off, end = off + len; i &lt; end; i++) {
 167             if (nums[i] &gt;= a &amp;&amp; nums[i] &lt; b) {
 168                 nums[ret++] = nums[i];
 169             }
 170         }
 171         return ret;
 172     }
 173 
<span class="removed"> 174     static double polyLineLength(double[] poly, final int off, final int nCoords) {</span>
<span class="removed"> 175         assert nCoords % 2 == 0 &amp;&amp; poly.length &gt;= off + nCoords : "";</span>
<span class="removed"> 176         double acc = 0.0d;</span>
<span class="removed"> 177         for (int i = off + 2; i &lt; off + nCoords; i += 2) {</span>
<span class="removed"> 178             acc += linelen(poly[i], poly[i+1], poly[i-2], poly[i-1]);</span>
<span class="removed"> 179         }</span>
<span class="removed"> 180         return acc;</span>
<span class="removed"> 181     }</span>
<span class="removed"> 182 </span>
 183     static double linelen(double x1, double y1, double x2, double y2) {
 184         final double dx = x2 - x1;
 185         final double dy = y2 - y1;
 186         return Math.sqrt(dx*dx + dy*dy);
 187     }
 188 
 189     static void subdivide(double[] src, int srcoff, double[] left, int leftoff,
 190                           double[] right, int rightoff, int type)
 191     {
 192         switch(type) {
 193         case 6:
 194             DHelpers.subdivideQuad(src, srcoff, left, leftoff, right, rightoff);
 195             return;
 196         case 8:
 197             DHelpers.subdivideCubic(src, srcoff, left, leftoff, right, rightoff);
 198             return;
 199         default:
 200             throw new InternalError("Unsupported curve type");
 201         }
 202     }

</pre><hr></hr><pre>
 416             right[rightoff + 0] = ctrlx;
 417             right[rightoff + 1] = ctrly;
 418             right[rightoff + 2] = x2;
 419             right[rightoff + 3] = y2;
 420         }
 421     }
 422 
 423     static void subdivideAt(double t, double[] src, int srcoff,
 424                             double[] left, int leftoff,
 425                             double[] right, int rightoff, int size)
 426     {
 427         switch(size) {
 428         case 8:
 429             subdivideCubicAt(t, src, srcoff, left, leftoff, right, rightoff);
 430             return;
 431         case 6:
 432             subdivideQuadAt(t, src, srcoff, left, leftoff, right, rightoff);
 433             return;
 434         }
 435     }
































































































































































































































































































































































































 436 }
</pre></td><td><pre>

</pre><hr></hr><pre>
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.java2d.marlin;
  27 
  28 import static java.lang.Math.PI;
<span class="changed">  29 import java.util.Arrays;</span>
<span class="changed">  30 import sun.java2d.marlin.stats.Histogram;</span>
<span class="changed">  31 import sun.java2d.marlin.stats.StatLong;</span>

  32 
  33 final class DHelpers implements MarlinConst {
  34 
  35     private DHelpers() {
  36         throw new Error("This is a non instantiable class");
  37     }
  38 
  39     static boolean within(final double x, final double y, final double err) {
  40         final double d = y - x;
  41         return (d &lt;= err &amp;&amp; d &gt;= -err);
  42     }
  43 
  44     static int quadraticRoots(final double a, final double b,
  45                               final double c, double[] zeroes, final int off)
  46     {
  47         int ret = off;
  48         double t;
  49         if (a != 0.0d) {
  50             final double dis = b*b - 4*a*c;
  51             if (dis &gt; 0.0d) {

</pre><hr></hr><pre>
  97         //  substitute x = y - A/3 to eliminate quadratic term:
  98         //     x^3 +Px + Q = 0
  99         //
 100         // Since we actually need P/3 and Q/2 for all of the
 101         // calculations that follow, we will calculate
 102         // p = P/3
 103         // q = Q/2
 104         // instead and use those values for simplicity of the code.
 105         double sq_A = a * a;
 106         double p = (1.0d/3.0d) * ((-1.0d/3.0d) * sq_A + b);
 107         double q = (1.0d/2.0d) * ((2.0d/27.0d) * a * sq_A - (1.0d/3.0d) * a * b + c);
 108 
 109         // use Cardano's formula
 110 
 111         double cb_p = p * p * p;
 112         double D = q * q + cb_p;
 113 
 114         int num;
 115         if (D &lt; 0.0d) {
 116             // see: http://en.wikipedia.org/wiki/Cubic_function#Trigonometric_.28and_hyperbolic.29_method
<span class="changed"> 117             final double phi = (1.0d/3.0d) * Math.acos(-q / Math.sqrt(-cb_p));</span>
<span class="changed"> 118             final double t = 2.0d * Math.sqrt(-p);</span>
 119 
<span class="changed"> 120             pts[ off+0 ] = ( t * Math.cos(phi));</span>
<span class="changed"> 121             pts[ off+1 ] = (-t * Math.cos(phi + (PI / 3.0d)));</span>
<span class="changed"> 122             pts[ off+2 ] = (-t * Math.cos(phi - (PI / 3.0d)));</span>
 123             num = 3;
 124         } else {
<span class="changed"> 125             final double sqrt_D = Math.sqrt(D);</span>
<span class="changed"> 126             final double u =   Math.cbrt(sqrt_D - q);</span>
<span class="changed"> 127             final double v = - Math.cbrt(sqrt_D + q);</span>
 128 
 129             pts[ off ] = (u + v);
 130             num = 1;
 131 
 132             if (within(D, 0.0d, 1e-8d)) {
 133                 pts[off+1] = -(pts[off] / 2.0d);
 134                 num = 2;
 135             }
 136         }
 137 
 138         final double sub = (1.0d/3.0d) * a;
 139 
 140         for (int i = 0; i &lt; num; ++i) {
 141             pts[ off+i ] -= sub;
 142         }
 143 
 144         return filterOutNotInAB(pts, off, num, A, B) - off;
 145     }
 146 
 147     static double evalCubic(final double a, final double b,

</pre><hr></hr><pre>
 153 
 154     static double evalQuad(final double a, final double b,
 155                           final double c, final double t)
 156     {
 157         return t * (t * a + b) + c;
 158     }
 159 
 160     // returns the index 1 past the last valid element remaining after filtering
 161     static int filterOutNotInAB(double[] nums, final int off, final int len,
 162                                 final double a, final double b)
 163     {
 164         int ret = off;
 165         for (int i = off, end = off + len; i &lt; end; i++) {
 166             if (nums[i] &gt;= a &amp;&amp; nums[i] &lt; b) {
 167                 nums[ret++] = nums[i];
 168             }
 169         }
 170         return ret;
 171     }
 172 









 173     static double linelen(double x1, double y1, double x2, double y2) {
 174         final double dx = x2 - x1;
 175         final double dy = y2 - y1;
 176         return Math.sqrt(dx*dx + dy*dy);
 177     }
 178 
 179     static void subdivide(double[] src, int srcoff, double[] left, int leftoff,
 180                           double[] right, int rightoff, int type)
 181     {
 182         switch(type) {
 183         case 6:
 184             DHelpers.subdivideQuad(src, srcoff, left, leftoff, right, rightoff);
 185             return;
 186         case 8:
 187             DHelpers.subdivideCubic(src, srcoff, left, leftoff, right, rightoff);
 188             return;
 189         default:
 190             throw new InternalError("Unsupported curve type");
 191         }
 192     }

</pre><hr></hr><pre>
 406             right[rightoff + 0] = ctrlx;
 407             right[rightoff + 1] = ctrly;
 408             right[rightoff + 2] = x2;
 409             right[rightoff + 3] = y2;
 410         }
 411     }
 412 
 413     static void subdivideAt(double t, double[] src, int srcoff,
 414                             double[] left, int leftoff,
 415                             double[] right, int rightoff, int size)
 416     {
 417         switch(size) {
 418         case 8:
 419             subdivideCubicAt(t, src, srcoff, left, leftoff, right, rightoff);
 420             return;
 421         case 6:
 422             subdivideQuadAt(t, src, srcoff, left, leftoff, right, rightoff);
 423             return;
 424         }
 425     }
<span class="new"> 426 </span>
<span class="new"> 427     // From sun.java2d.loops.GeneralRenderer:</span>
<span class="new"> 428 </span>
<span class="new"> 429     static int outcode(final double x, final double y,</span>
<span class="new"> 430                        final double[] clipRect)</span>
<span class="new"> 431     {</span>
<span class="new"> 432         int code;</span>
<span class="new"> 433         if (y &lt; clipRect[0]) {</span>
<span class="new"> 434             code = OUTCODE_TOP;</span>
<span class="new"> 435         } else if (y &gt;= clipRect[1]) {</span>
<span class="new"> 436             code = OUTCODE_BOTTOM;</span>
<span class="new"> 437         } else {</span>
<span class="new"> 438             code = 0;</span>
<span class="new"> 439         }</span>
<span class="new"> 440         if (x &lt; clipRect[2]) {</span>
<span class="new"> 441             code |= OUTCODE_LEFT;</span>
<span class="new"> 442         } else if (x &gt;= clipRect[3]) {</span>
<span class="new"> 443             code |= OUTCODE_RIGHT;</span>
<span class="new"> 444         }</span>
<span class="new"> 445         return code;</span>
<span class="new"> 446     }</span>
<span class="new"> 447 </span>
<span class="new"> 448     // a stack of polynomial curves where each curve shares endpoints with</span>
<span class="new"> 449     // adjacent ones.</span>
<span class="new"> 450     static final class PolyStack {</span>
<span class="new"> 451         private static final byte TYPE_LINETO  = (byte) 0;</span>
<span class="new"> 452         private static final byte TYPE_QUADTO  = (byte) 1;</span>
<span class="new"> 453         private static final byte TYPE_CUBICTO = (byte) 2;</span>
<span class="new"> 454 </span>
<span class="new"> 455         // curves capacity = edges count (8192) = edges x 2 (coords)</span>
<span class="new"> 456         private static final int INITIAL_CURVES_COUNT = INITIAL_EDGES_COUNT &lt;&lt; 1;</span>
<span class="new"> 457 </span>
<span class="new"> 458         // types capacity = edges count (4096)</span>
<span class="new"> 459         private static final int INITIAL_TYPES_COUNT = INITIAL_EDGES_COUNT;</span>
<span class="new"> 460 </span>
<span class="new"> 461         double[] curves;</span>
<span class="new"> 462         int end;</span>
<span class="new"> 463         byte[] curveTypes;</span>
<span class="new"> 464         int numCurves;</span>
<span class="new"> 465 </span>
<span class="new"> 466         // curves ref (dirty)</span>
<span class="new"> 467         final DoubleArrayCache.Reference curves_ref;</span>
<span class="new"> 468         // curveTypes ref (dirty)</span>
<span class="new"> 469         final ByteArrayCache.Reference curveTypes_ref;</span>
<span class="new"> 470 </span>
<span class="new"> 471         // used marks (stats only)</span>
<span class="new"> 472         int curveTypesUseMark;</span>
<span class="new"> 473         int curvesUseMark;</span>
<span class="new"> 474 </span>
<span class="new"> 475         private final StatLong stat_polystack_types;</span>
<span class="new"> 476         private final StatLong stat_polystack_curves;</span>
<span class="new"> 477         private final Histogram hist_polystack_curves;</span>
<span class="new"> 478         private final StatLong stat_array_polystack_curves;</span>
<span class="new"> 479         private final StatLong stat_array_polystack_curveTypes;</span>
<span class="new"> 480 </span>
<span class="new"> 481         PolyStack(final DRendererContext rdrCtx) {</span>
<span class="new"> 482             this(rdrCtx, null, null, null, null, null);</span>
<span class="new"> 483         }</span>
<span class="new"> 484 </span>
<span class="new"> 485         PolyStack(final DRendererContext rdrCtx,</span>
<span class="new"> 486                   final StatLong stat_polystack_types,</span>
<span class="new"> 487                   final StatLong stat_polystack_curves,</span>
<span class="new"> 488                   final Histogram hist_polystack_curves,</span>
<span class="new"> 489                   final StatLong stat_array_polystack_curves,</span>
<span class="new"> 490                   final StatLong stat_array_polystack_curveTypes)</span>
<span class="new"> 491         {</span>
<span class="new"> 492             curves_ref = rdrCtx.newDirtyDoubleArrayRef(INITIAL_CURVES_COUNT); // 32K</span>
<span class="new"> 493             curves     = curves_ref.initial;</span>
<span class="new"> 494 </span>
<span class="new"> 495             curveTypes_ref = rdrCtx.newDirtyByteArrayRef(INITIAL_TYPES_COUNT); // 4K</span>
<span class="new"> 496             curveTypes     = curveTypes_ref.initial;</span>
<span class="new"> 497             numCurves = 0;</span>
<span class="new"> 498             end = 0;</span>
<span class="new"> 499 </span>
<span class="new"> 500             if (DO_STATS) {</span>
<span class="new"> 501                 curveTypesUseMark = 0;</span>
<span class="new"> 502                 curvesUseMark = 0;</span>
<span class="new"> 503             }</span>
<span class="new"> 504             this.stat_polystack_types = stat_polystack_types;</span>
<span class="new"> 505             this.stat_polystack_curves = stat_polystack_curves;</span>
<span class="new"> 506             this.hist_polystack_curves = hist_polystack_curves;</span>
<span class="new"> 507             this.stat_array_polystack_curves = stat_array_polystack_curves;</span>
<span class="new"> 508             this.stat_array_polystack_curveTypes = stat_array_polystack_curveTypes;</span>
<span class="new"> 509         }</span>
<span class="new"> 510 </span>
<span class="new"> 511         /**</span>
<span class="new"> 512          * Disposes this PolyStack:</span>
<span class="new"> 513          * clean up before reusing this instance</span>
<span class="new"> 514          */</span>
<span class="new"> 515         void dispose() {</span>
<span class="new"> 516             end = 0;</span>
<span class="new"> 517             numCurves = 0;</span>
<span class="new"> 518 </span>
<span class="new"> 519             if (DO_STATS) {</span>
<span class="new"> 520                 stat_polystack_types.add(curveTypesUseMark);</span>
<span class="new"> 521                 stat_polystack_curves.add(curvesUseMark);</span>
<span class="new"> 522                 hist_polystack_curves.add(curvesUseMark);</span>
<span class="new"> 523 </span>
<span class="new"> 524                 // reset marks</span>
<span class="new"> 525                 curveTypesUseMark = 0;</span>
<span class="new"> 526                 curvesUseMark = 0;</span>
<span class="new"> 527             }</span>
<span class="new"> 528 </span>
<span class="new"> 529             // Return arrays:</span>
<span class="new"> 530             // curves and curveTypes are kept dirty</span>
<span class="new"> 531             curves     = curves_ref.putArray(curves);</span>
<span class="new"> 532             curveTypes = curveTypes_ref.putArray(curveTypes);</span>
<span class="new"> 533         }</span>
<span class="new"> 534 </span>
<span class="new"> 535         private void ensureSpace(final int n) {</span>
<span class="new"> 536             // use substraction to avoid integer overflow:</span>
<span class="new"> 537             if (curves.length - end &lt; n) {</span>
<span class="new"> 538                 if (DO_STATS) {</span>
<span class="new"> 539                     stat_array_polystack_curves.add(end + n);</span>
<span class="new"> 540                 }</span>
<span class="new"> 541                 curves = curves_ref.widenArray(curves, end, end + n);</span>
<span class="new"> 542             }</span>
<span class="new"> 543             if (curveTypes.length &lt;= numCurves) {</span>
<span class="new"> 544                 if (DO_STATS) {</span>
<span class="new"> 545                     stat_array_polystack_curveTypes.add(numCurves + 1);</span>
<span class="new"> 546                 }</span>
<span class="new"> 547                 curveTypes = curveTypes_ref.widenArray(curveTypes,</span>
<span class="new"> 548                                                        numCurves,</span>
<span class="new"> 549                                                        numCurves + 1);</span>
<span class="new"> 550             }</span>
<span class="new"> 551         }</span>
<span class="new"> 552 </span>
<span class="new"> 553         void pushCubic(double x0, double y0,</span>
<span class="new"> 554                        double x1, double y1,</span>
<span class="new"> 555                        double x2, double y2)</span>
<span class="new"> 556         {</span>
<span class="new"> 557             ensureSpace(6);</span>
<span class="new"> 558             curveTypes[numCurves++] = TYPE_CUBICTO;</span>
<span class="new"> 559             // we reverse the coordinate order to make popping easier</span>
<span class="new"> 560             final double[] _curves = curves;</span>
<span class="new"> 561             int e = end;</span>
<span class="new"> 562             _curves[e++] = x2;    _curves[e++] = y2;</span>
<span class="new"> 563             _curves[e++] = x1;    _curves[e++] = y1;</span>
<span class="new"> 564             _curves[e++] = x0;    _curves[e++] = y0;</span>
<span class="new"> 565             end = e;</span>
<span class="new"> 566         }</span>
<span class="new"> 567 </span>
<span class="new"> 568         void pushQuad(double x0, double y0,</span>
<span class="new"> 569                       double x1, double y1)</span>
<span class="new"> 570         {</span>
<span class="new"> 571             ensureSpace(4);</span>
<span class="new"> 572             curveTypes[numCurves++] = TYPE_QUADTO;</span>
<span class="new"> 573             final double[] _curves = curves;</span>
<span class="new"> 574             int e = end;</span>
<span class="new"> 575             _curves[e++] = x1;    _curves[e++] = y1;</span>
<span class="new"> 576             _curves[e++] = x0;    _curves[e++] = y0;</span>
<span class="new"> 577             end = e;</span>
<span class="new"> 578         }</span>
<span class="new"> 579 </span>
<span class="new"> 580         void pushLine(double x, double y) {</span>
<span class="new"> 581             ensureSpace(2);</span>
<span class="new"> 582             curveTypes[numCurves++] = TYPE_LINETO;</span>
<span class="new"> 583             curves[end++] = x;    curves[end++] = y;</span>
<span class="new"> 584         }</span>
<span class="new"> 585 </span>
<span class="new"> 586         void pullAll(final DPathConsumer2D io) {</span>
<span class="new"> 587             final int nc = numCurves;</span>
<span class="new"> 588             if (nc == 0) {</span>
<span class="new"> 589                 return;</span>
<span class="new"> 590             }</span>
<span class="new"> 591             if (DO_STATS) {</span>
<span class="new"> 592                 // update used marks:</span>
<span class="new"> 593                 if (numCurves &gt; curveTypesUseMark) {</span>
<span class="new"> 594                     curveTypesUseMark = numCurves;</span>
<span class="new"> 595                 }</span>
<span class="new"> 596                 if (end &gt; curvesUseMark) {</span>
<span class="new"> 597                     curvesUseMark = end;</span>
<span class="new"> 598                 }</span>
<span class="new"> 599             }</span>
<span class="new"> 600             final byte[]  _curveTypes = curveTypes;</span>
<span class="new"> 601             final double[] _curves = curves;</span>
<span class="new"> 602             int e = 0;</span>
<span class="new"> 603 </span>
<span class="new"> 604             for (int i = 0; i &lt; nc; i++) {</span>
<span class="new"> 605                 switch(_curveTypes[i]) {</span>
<span class="new"> 606                 case TYPE_LINETO:</span>
<span class="new"> 607                     io.lineTo(_curves[e], _curves[e+1]);</span>
<span class="new"> 608                     e += 2;</span>
<span class="new"> 609                     continue;</span>
<span class="new"> 610                 case TYPE_QUADTO:</span>
<span class="new"> 611                     io.quadTo(_curves[e+0], _curves[e+1],</span>
<span class="new"> 612                               _curves[e+2], _curves[e+3]);</span>
<span class="new"> 613                     e += 4;</span>
<span class="new"> 614                     continue;</span>
<span class="new"> 615                 case TYPE_CUBICTO:</span>
<span class="new"> 616                     io.curveTo(_curves[e+0], _curves[e+1],</span>
<span class="new"> 617                                _curves[e+2], _curves[e+3],</span>
<span class="new"> 618                                _curves[e+4], _curves[e+5]);</span>
<span class="new"> 619                     e += 6;</span>
<span class="new"> 620                     continue;</span>
<span class="new"> 621                 default:</span>
<span class="new"> 622                 }</span>
<span class="new"> 623             }</span>
<span class="new"> 624             numCurves = 0;</span>
<span class="new"> 625             end = 0;</span>
<span class="new"> 626         }</span>
<span class="new"> 627 </span>
<span class="new"> 628         void popAll(final DPathConsumer2D io) {</span>
<span class="new"> 629             int nc = numCurves;</span>
<span class="new"> 630             if (nc == 0) {</span>
<span class="new"> 631                 return;</span>
<span class="new"> 632             }</span>
<span class="new"> 633             if (DO_STATS) {</span>
<span class="new"> 634                 // update used marks:</span>
<span class="new"> 635                 if (numCurves &gt; curveTypesUseMark) {</span>
<span class="new"> 636                     curveTypesUseMark = numCurves;</span>
<span class="new"> 637                 }</span>
<span class="new"> 638                 if (end &gt; curvesUseMark) {</span>
<span class="new"> 639                     curvesUseMark = end;</span>
<span class="new"> 640                 }</span>
<span class="new"> 641             }</span>
<span class="new"> 642             final byte[]  _curveTypes = curveTypes;</span>
<span class="new"> 643             final double[] _curves = curves;</span>
<span class="new"> 644             int e  = end;</span>
<span class="new"> 645 </span>
<span class="new"> 646             while (nc != 0) {</span>
<span class="new"> 647                 switch(_curveTypes[--nc]) {</span>
<span class="new"> 648                 case TYPE_LINETO:</span>
<span class="new"> 649                     e -= 2;</span>
<span class="new"> 650                     io.lineTo(_curves[e], _curves[e+1]);</span>
<span class="new"> 651                     continue;</span>
<span class="new"> 652                 case TYPE_QUADTO:</span>
<span class="new"> 653                     e -= 4;</span>
<span class="new"> 654                     io.quadTo(_curves[e+0], _curves[e+1],</span>
<span class="new"> 655                               _curves[e+2], _curves[e+3]);</span>
<span class="new"> 656                     continue;</span>
<span class="new"> 657                 case TYPE_CUBICTO:</span>
<span class="new"> 658                     e -= 6;</span>
<span class="new"> 659                     io.curveTo(_curves[e+0], _curves[e+1],</span>
<span class="new"> 660                                _curves[e+2], _curves[e+3],</span>
<span class="new"> 661                                _curves[e+4], _curves[e+5]);</span>
<span class="new"> 662                     continue;</span>
<span class="new"> 663                 default:</span>
<span class="new"> 664                 }</span>
<span class="new"> 665             }</span>
<span class="new"> 666             numCurves = 0;</span>
<span class="new"> 667             end = 0;</span>
<span class="new"> 668         }</span>
<span class="new"> 669 </span>
<span class="new"> 670         @Override</span>
<span class="new"> 671         public String toString() {</span>
<span class="new"> 672             String ret = "";</span>
<span class="new"> 673             int nc = numCurves;</span>
<span class="new"> 674             int last = end;</span>
<span class="new"> 675             int len;</span>
<span class="new"> 676             while (nc != 0) {</span>
<span class="new"> 677                 switch(curveTypes[--nc]) {</span>
<span class="new"> 678                 case TYPE_LINETO:</span>
<span class="new"> 679                     len = 2;</span>
<span class="new"> 680                     ret += "line: ";</span>
<span class="new"> 681                     break;</span>
<span class="new"> 682                 case TYPE_QUADTO:</span>
<span class="new"> 683                     len = 4;</span>
<span class="new"> 684                     ret += "quad: ";</span>
<span class="new"> 685                     break;</span>
<span class="new"> 686                 case TYPE_CUBICTO:</span>
<span class="new"> 687                     len = 6;</span>
<span class="new"> 688                     ret += "cubic: ";</span>
<span class="new"> 689                     break;</span>
<span class="new"> 690                 default:</span>
<span class="new"> 691                     len = 0;</span>
<span class="new"> 692                 }</span>
<span class="new"> 693                 last -= len;</span>
<span class="new"> 694                 ret += Arrays.toString(Arrays.copyOfRange(curves, last, last+len))</span>
<span class="new"> 695                                        + "\n";</span>
<span class="new"> 696             }</span>
<span class="new"> 697             return ret;</span>
<span class="new"> 698         }</span>
<span class="new"> 699     }</span>
<span class="new"> 700 </span>
<span class="new"> 701     // a stack of integer indices</span>
<span class="new"> 702     static final class IndexStack {</span>
<span class="new"> 703 </span>
<span class="new"> 704         // integer capacity = edges count / 4 ~ 1024</span>
<span class="new"> 705         private static final int INITIAL_COUNT = INITIAL_EDGES_COUNT &gt;&gt; 2;</span>
<span class="new"> 706 </span>
<span class="new"> 707         private int end;</span>
<span class="new"> 708         private int[] indices;</span>
<span class="new"> 709 </span>
<span class="new"> 710         // indices ref (dirty)</span>
<span class="new"> 711         private final IntArrayCache.Reference indices_ref;</span>
<span class="new"> 712 </span>
<span class="new"> 713         // used marks (stats only)</span>
<span class="new"> 714         private int indicesUseMark;</span>
<span class="new"> 715 </span>
<span class="new"> 716         private final StatLong stat_idxstack_indices;</span>
<span class="new"> 717         private final Histogram hist_idxstack_indices;</span>
<span class="new"> 718         private final StatLong stat_array_idxstack_indices;</span>
<span class="new"> 719 </span>
<span class="new"> 720         IndexStack(final DRendererContext rdrCtx) {</span>
<span class="new"> 721             this(rdrCtx, null, null, null);</span>
<span class="new"> 722         }</span>
<span class="new"> 723 </span>
<span class="new"> 724         IndexStack(final DRendererContext rdrCtx,</span>
<span class="new"> 725                    final StatLong stat_idxstack_indices,</span>
<span class="new"> 726                    final Histogram hist_idxstack_indices,</span>
<span class="new"> 727                    final StatLong stat_array_idxstack_indices)</span>
<span class="new"> 728         {</span>
<span class="new"> 729             indices_ref = rdrCtx.newDirtyIntArrayRef(INITIAL_COUNT); // 4K</span>
<span class="new"> 730             indices     = indices_ref.initial;</span>
<span class="new"> 731             end = 0;</span>
<span class="new"> 732 </span>
<span class="new"> 733             if (DO_STATS) {</span>
<span class="new"> 734                 indicesUseMark = 0;</span>
<span class="new"> 735             }</span>
<span class="new"> 736             this.stat_idxstack_indices = stat_idxstack_indices;</span>
<span class="new"> 737             this.hist_idxstack_indices = hist_idxstack_indices;</span>
<span class="new"> 738             this.stat_array_idxstack_indices = stat_array_idxstack_indices;</span>
<span class="new"> 739         }</span>
<span class="new"> 740 </span>
<span class="new"> 741         /**</span>
<span class="new"> 742          * Disposes this PolyStack:</span>
<span class="new"> 743          * clean up before reusing this instance</span>
<span class="new"> 744          */</span>
<span class="new"> 745         void dispose() {</span>
<span class="new"> 746             end = 0;</span>
<span class="new"> 747 </span>
<span class="new"> 748             if (DO_STATS) {</span>
<span class="new"> 749                 stat_idxstack_indices.add(indicesUseMark);</span>
<span class="new"> 750                 hist_idxstack_indices.add(indicesUseMark);</span>
<span class="new"> 751 </span>
<span class="new"> 752                 // reset marks</span>
<span class="new"> 753                 indicesUseMark = 0;</span>
<span class="new"> 754             }</span>
<span class="new"> 755 </span>
<span class="new"> 756             // Return arrays:</span>
<span class="new"> 757             // values is kept dirty</span>
<span class="new"> 758             indices = indices_ref.putArray(indices);</span>
<span class="new"> 759         }</span>
<span class="new"> 760 </span>
<span class="new"> 761         boolean isEmpty() {</span>
<span class="new"> 762             return (end == 0);</span>
<span class="new"> 763         }</span>
<span class="new"> 764 </span>
<span class="new"> 765         void reset() {</span>
<span class="new"> 766             end = 0;</span>
<span class="new"> 767         }</span>
<span class="new"> 768 </span>
<span class="new"> 769         void push(final int v) {</span>
<span class="new"> 770             // remove redundant values (reverse order):</span>
<span class="new"> 771             int[] _values = indices;</span>
<span class="new"> 772             final int nc = end;</span>
<span class="new"> 773             if (nc != 0) {</span>
<span class="new"> 774                 if (_values[nc - 1] == v) {</span>
<span class="new"> 775                     // remove both duplicated values:</span>
<span class="new"> 776                     end--;</span>
<span class="new"> 777                     return;</span>
<span class="new"> 778                 }</span>
<span class="new"> 779             }</span>
<span class="new"> 780             if (_values.length &lt;= nc) {</span>
<span class="new"> 781                 if (DO_STATS) {</span>
<span class="new"> 782                     stat_array_idxstack_indices.add(nc + 1);</span>
<span class="new"> 783                 }</span>
<span class="new"> 784                 indices = _values = indices_ref.widenArray(_values, nc, nc + 1);</span>
<span class="new"> 785             }</span>
<span class="new"> 786             _values[end++] = v;</span>
<span class="new"> 787 </span>
<span class="new"> 788             if (DO_STATS) {</span>
<span class="new"> 789                 // update used marks:</span>
<span class="new"> 790                 if (end &gt; indicesUseMark) {</span>
<span class="new"> 791                     indicesUseMark = end;</span>
<span class="new"> 792                 }</span>
<span class="new"> 793             }</span>
<span class="new"> 794         }</span>
<span class="new"> 795 </span>
<span class="new"> 796         void pullAll(final double[] points, final DPathConsumer2D io) {</span>
<span class="new"> 797             final int nc = end;</span>
<span class="new"> 798             if (nc == 0) {</span>
<span class="new"> 799                 return;</span>
<span class="new"> 800             }</span>
<span class="new"> 801             final int[] _values = indices;</span>
<span class="new"> 802 </span>
<span class="new"> 803             for (int i = 0, j; i &lt; nc; i++) {</span>
<span class="new"> 804                 j = _values[i] &lt;&lt; 1;</span>
<span class="new"> 805                 io.lineTo(points[j], points[j + 1]);</span>
<span class="new"> 806             }</span>
<span class="new"> 807             end = 0;</span>
<span class="new"> 808         }</span>
<span class="new"> 809     }</span>
 810 }
</pre></td>
</tr></table>
<center><a href='../../../../../../src/share/classes/sun/java2d/marlin/DDasher.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../src/share/classes/sun/java2d/marlin/DMarlinRenderingEngine.java.sdiff.html' target='_top'>next &gt</a></center>
</body></html>
