<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>jdk Udiff src/share/classes/sun/java2d/marlin/Stroker.java</title>

<style type="text/css" media="screen">
span.new {
    color: blue;
    font-weight: normal;
}
</style>

</head>
<body id="SUNWwebrev">
<center><a href='../../../../../../src/share/classes/sun/java2d/marlin/RendererStats.java.udiff.html' target='_top'>&lt prev</a> <a href='../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../src/share/classes/sun/java2d/marlin/TransformingPathConsumer2D.java.udiff.html' target='_top'>next &gt</a></center>
<h2>src/share/classes/sun/java2d/marlin/Stroker.java</h2>
        <a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-13694">13694</a> : <a href="https://bugs.openjdk.java.net/browse/JDK-8191814">8191814</a>: Marlin rasterizer spends time computing geometry for stroked segments that do not intersect the clip
Summary: upgrade to Marlin 0.8.2 providing efficient path clipping (Stroker and Filler)
Reviewed-by: prr, serb</pre>
        <pre>
</pre><hr /><pre>
<span class="newmarker">@@ -26,56 +26,31 @@</span>
 package sun.java2d.marlin;
 
 import java.util.Arrays;
 
 import sun.awt.geom.PathConsumer2D;
<span class="new">+import sun.java2d.marlin.Helpers.PolyStack;</span>
 
 // TODO: some of the arithmetic here is too verbose and prone to hard to
 // debug typos. We should consider making a small Point/Vector class that
 // has methods like plus(Point), minus(Point), dot(Point), cross(Point)and such
 final class Stroker implements PathConsumer2D, MarlinConst {
 
     private static final int MOVE_TO = 0;
     private static final int DRAWING_OP_TO = 1; // ie. curve, line, or quad
     private static final int CLOSE = 2;
 
<span class="removed">-    /**</span>
<span class="removed">-     * Constant value for join style.</span>
<span class="removed">-     */</span>
<span class="removed">-    public static final int JOIN_MITER = 0;</span>
<span class="removed">-</span>
<span class="removed">-    /**</span>
<span class="removed">-     * Constant value for join style.</span>
<span class="removed">-     */</span>
<span class="removed">-    public static final int JOIN_ROUND = 1;</span>
<span class="removed">-</span>
<span class="removed">-    /**</span>
<span class="removed">-     * Constant value for join style.</span>
<span class="removed">-     */</span>
<span class="removed">-    public static final int JOIN_BEVEL = 2;</span>
<span class="removed">-</span>
<span class="removed">-    /**</span>
<span class="removed">-     * Constant value for end cap style.</span>
<span class="removed">-     */</span>
<span class="removed">-    public static final int CAP_BUTT = 0;</span>
<span class="removed">-</span>
<span class="removed">-    /**</span>
<span class="removed">-     * Constant value for end cap style.</span>
<span class="removed">-     */</span>
<span class="removed">-    public static final int CAP_ROUND = 1;</span>
<span class="removed">-</span>
<span class="removed">-    /**</span>
<span class="removed">-     * Constant value for end cap style.</span>
<span class="removed">-     */</span>
<span class="removed">-    public static final int CAP_SQUARE = 2;</span>
<span class="removed">-</span>
     // pisces used to use fixed point arithmetic with 16 decimal digits. I
     // didn't want to change the values of the constant below when I converted
     // it to floating point, so that's why the divisions by 2^16 are there.
     private static final float ROUND_JOIN_THRESHOLD = 1000.0f/65536.0f;
 
<span class="removed">-    private static final float C = 0.5522847498307933f;</span>
<span class="new">+    // kappa = (4/3) * (SQRT(2) - 1)</span>
<span class="new">+    private static final float C = (float)(4.0d * (Math.sqrt(2.0d) - 1.0d) / 3.0d);</span>
<span class="new">+</span>
<span class="new">+    // SQRT(2)</span>
<span class="new">+    private static final float SQRT_2 = (float)Math.sqrt(2.0d);</span>
 
     private static final int MAX_N_CURVES = 11;
 
     private PathConsumer2D out;
 
</pre><hr /><pre>
<span class="newmarker">@@ -118,18 +93,40 @@</span>
     final RendererContext rdrCtx;
 
     // dirty curve
     final Curve curve;
 
<span class="new">+    // Bounds of the drawing region, at pixel precision.</span>
<span class="new">+    private float[] clipRect;</span>
<span class="new">+</span>
<span class="new">+    // the outcode of the current point</span>
<span class="new">+    private int cOutCode = 0;</span>
<span class="new">+</span>
<span class="new">+    // the outcode of the starting point</span>
<span class="new">+    private int sOutCode = 0;</span>
<span class="new">+</span>
<span class="new">+    // flag indicating if the path is opened (clipped)</span>
<span class="new">+    private boolean opened = false;</span>
<span class="new">+    // flag indicating if the starting point's cap is done</span>
<span class="new">+    private boolean capStart = false;</span>
<span class="new">+</span>
     /**
      * Constructs a &lt;code&gt;Stroker&lt;/code&gt;.
      * @param rdrCtx per-thread renderer context
      */
     Stroker(final RendererContext rdrCtx) {
         this.rdrCtx = rdrCtx;
 
<span class="removed">-        this.reverse = new PolyStack(rdrCtx);</span>
<span class="new">+        this.reverse = (rdrCtx.stats != null) ?</span>
<span class="new">+            new PolyStack(rdrCtx,</span>
<span class="new">+                    rdrCtx.stats.stat_str_polystack_types,</span>
<span class="new">+                    rdrCtx.stats.stat_str_polystack_curves,</span>
<span class="new">+                    rdrCtx.stats.hist_str_polystack_curves,</span>
<span class="new">+                    rdrCtx.stats.stat_array_str_polystack_curves,</span>
<span class="new">+                    rdrCtx.stats.stat_array_str_polystack_types)</span>
<span class="new">+            : new PolyStack(rdrCtx);</span>
<span class="new">+</span>
         this.curve = rdrCtx.curve;
     }
 
     /**
      * Inits the &lt;code&gt;Stroker&lt;/code&gt;.
</pre><hr /><pre>
<span class="newmarker">@@ -141,42 +138,79 @@</span>
      * &lt;code&gt;CAP_SQUARE&lt;/code&gt;.
      * @param joinStyle the desired line join style, one of
      * &lt;code&gt;JOIN_MITER&lt;/code&gt;, &lt;code&gt;JOIN_ROUND&lt;/code&gt; or
      * &lt;code&gt;JOIN_BEVEL&lt;/code&gt;.
      * @param miterLimit the desired miter limit
<span class="new">+     * @param scale scaling factor applied to clip boundaries</span>
      * @return this instance
      */
<span class="removed">-    Stroker init(PathConsumer2D pc2d,</span>
<span class="removed">-              float lineWidth,</span>
<span class="removed">-              int capStyle,</span>
<span class="removed">-              int joinStyle,</span>
<span class="removed">-              float miterLimit)</span>
<span class="new">+    Stroker init(final PathConsumer2D pc2d,</span>
<span class="new">+                 final float lineWidth,</span>
<span class="new">+                 final int capStyle,</span>
<span class="new">+                 final int joinStyle,</span>
<span class="new">+                 final float miterLimit,</span>
<span class="new">+                 final float scale)</span>
     {
         this.out = pc2d;
 
         this.lineWidth2 = lineWidth / 2.0f;
         this.invHalfLineWidth2Sq = 1.0f / (2.0f * lineWidth2 * lineWidth2);
         this.capStyle = capStyle;
         this.joinStyle = joinStyle;
 
<span class="removed">-        float limit = miterLimit * lineWidth2;</span>
<span class="new">+        final float limit = miterLimit * lineWidth2;</span>
         this.miterLimitSq = limit * limit;
 
         this.prev = CLOSE;
 
         rdrCtx.stroking = 1;
 
<span class="new">+        if (rdrCtx.doClip) {</span>
<span class="new">+            // Adjust the clipping rectangle with the stroker margin (miter limit, width)</span>
<span class="new">+            float rdrOffX = 0.0f, rdrOffY = 0.0f;</span>
<span class="new">+            float margin = lineWidth2;</span>
<span class="new">+</span>
<span class="new">+            if (capStyle == CAP_SQUARE) {</span>
<span class="new">+                margin *= SQRT_2;</span>
<span class="new">+            }</span>
<span class="new">+            if ((joinStyle == JOIN_MITER) &amp;&amp; (margin &lt; limit)) {</span>
<span class="new">+                margin = limit;</span>
<span class="new">+            }</span>
<span class="new">+            if (scale != 1.0f) {</span>
<span class="new">+                margin *= scale;</span>
<span class="new">+                rdrOffX = scale * Renderer.RDR_OFFSET_X;</span>
<span class="new">+                rdrOffY = scale * Renderer.RDR_OFFSET_Y;</span>
<span class="new">+            }</span>
<span class="new">+            // add a small rounding error:</span>
<span class="new">+            margin += 1e-3f;</span>
<span class="new">+</span>
<span class="new">+            // bounds as half-open intervals: minX &lt;= x &lt; maxX and minY &lt;= y &lt; maxY</span>
<span class="new">+            // adjust clip rectangle (ymin, ymax, xmin, xmax):</span>
<span class="new">+            final float[] _clipRect = rdrCtx.clipRect;</span>
<span class="new">+            _clipRect[0] -= margin - rdrOffY;</span>
<span class="new">+            _clipRect[1] += margin + rdrOffY;</span>
<span class="new">+            _clipRect[2] -= margin - rdrOffX;</span>
<span class="new">+            _clipRect[3] += margin + rdrOffX;</span>
<span class="new">+            this.clipRect = _clipRect;</span>
<span class="new">+        } else {</span>
<span class="new">+            this.clipRect = null;</span>
<span class="new">+            this.cOutCode = 0;</span>
<span class="new">+            this.sOutCode = 0;</span>
<span class="new">+        }</span>
         return this; // fluent API
     }
 
     /**
      * Disposes this stroker:
      * clean up before reusing this instance
      */
     void dispose() {
         reverse.dispose();
 
<span class="new">+        opened   = false;</span>
<span class="new">+        capStart = false;</span>
<span class="new">+</span>
         if (DO_CLEAN_DIRTY) {
             // Force zero-fill dirty arrays:
             Arrays.fill(offset0, 0.0f);
             Arrays.fill(offset1, 0.0f);
             Arrays.fill(offset2, 0.0f);
</pre><hr /><pre>
<span class="newmarker">@@ -443,87 +477,152 @@</span>
             emitLineTo(miterX, miterY, rev);
         }
     }
 
     @Override
<span class="removed">-    public void moveTo(float x0, float y0) {</span>
<span class="new">+    public void moveTo(final float x0, final float y0) {</span>
<span class="new">+        moveTo(x0, y0, cOutCode);</span>
<span class="new">+        // update starting point:</span>
<span class="new">+        this.sx0 = x0;</span>
<span class="new">+        this.sy0 = y0;</span>
<span class="new">+        this.sdx = 1.0f;</span>
<span class="new">+        this.sdy = 0.0f;</span>
<span class="new">+        this.opened   = false;</span>
<span class="new">+        this.capStart = false;</span>
<span class="new">+</span>
<span class="new">+        if (clipRect != null) {</span>
<span class="new">+            final int outcode = Helpers.outcode(x0, y0, clipRect);</span>
<span class="new">+            this.cOutCode = outcode;</span>
<span class="new">+            this.sOutCode = outcode;</span>
<span class="new">+        }</span>
<span class="new">+    }</span>
<span class="new">+</span>
<span class="new">+    private void moveTo(final float x0, final float y0,</span>
<span class="new">+                        final int outcode)</span>
<span class="new">+    {</span>
<span class="new">+        if (prev == MOVE_TO) {</span>
<span class="new">+            this.cx0 = x0;</span>
<span class="new">+            this.cy0 = y0;</span>
<span class="new">+        } else {</span>
         if (prev == DRAWING_OP_TO) {
<span class="removed">-            finish();</span>
<span class="new">+                finish(outcode);</span>
         }
<span class="removed">-        this.sx0 = this.cx0 = x0;</span>
<span class="removed">-        this.sy0 = this.cy0 = y0;</span>
<span class="removed">-        this.cdx = this.sdx = 1.0f;</span>
<span class="removed">-        this.cdy = this.sdy = 0.0f;</span>
         this.prev = MOVE_TO;
<span class="new">+            this.cx0 = x0;</span>
<span class="new">+            this.cy0 = y0;</span>
<span class="new">+            this.cdx = 1.0f;</span>
<span class="new">+            this.cdy = 0.0f;</span>
<span class="new">+        }</span>
     }
 
     @Override
<span class="removed">-    public void lineTo(float x1, float y1) {</span>
<span class="new">+    public void lineTo(final float x1, final float y1) {</span>
<span class="new">+        lineTo(x1, y1, false);</span>
<span class="new">+    }</span>
<span class="new">+</span>
<span class="new">+    private void lineTo(final float x1, final float y1,</span>
<span class="new">+                        final boolean force)</span>
<span class="new">+    {</span>
<span class="new">+        final int outcode0 = this.cOutCode;</span>
<span class="new">+        if (!force &amp;&amp; clipRect != null) {</span>
<span class="new">+            final int outcode1 = Helpers.outcode(x1, y1, clipRect);</span>
<span class="new">+            this.cOutCode = outcode1;</span>
<span class="new">+</span>
<span class="new">+            // basic rejection criteria</span>
<span class="new">+            if ((outcode0 &amp; outcode1) != 0) {</span>
<span class="new">+                moveTo(x1, y1, outcode0);</span>
<span class="new">+                opened = true;</span>
<span class="new">+                return;</span>
<span class="new">+            }</span>
<span class="new">+        }</span>
<span class="new">+</span>
         float dx = x1 - cx0;
         float dy = y1 - cy0;
         if (dx == 0.0f &amp;&amp; dy == 0.0f) {
             dx = 1.0f;
         }
         computeOffset(dx, dy, lineWidth2, offset0);
         final float mx = offset0[0];
         final float my = offset0[1];
 
<span class="removed">-        drawJoin(cdx, cdy, cx0, cy0, dx, dy, cmx, cmy, mx, my);</span>
<span class="new">+        drawJoin(cdx, cdy, cx0, cy0, dx, dy, cmx, cmy, mx, my, outcode0);</span>
 
         emitLineTo(cx0 + mx, cy0 + my);
         emitLineTo( x1 + mx,  y1 + my);
 
         emitLineToRev(cx0 - mx, cy0 - my);
         emitLineToRev( x1 - mx,  y1 - my);
 
<span class="removed">-        this.cmx = mx;</span>
<span class="removed">-        this.cmy = my;</span>
<span class="removed">-        this.cdx = dx;</span>
<span class="removed">-        this.cdy = dy;</span>
<span class="new">+        this.prev = DRAWING_OP_TO;</span>
         this.cx0 = x1;
         this.cy0 = y1;
<span class="removed">-        this.prev = DRAWING_OP_TO;</span>
<span class="new">+        this.cdx = dx;</span>
<span class="new">+        this.cdy = dy;</span>
<span class="new">+        this.cmx = mx;</span>
<span class="new">+        this.cmy = my;</span>
     }
 
     @Override
     public void closePath() {
<span class="removed">-        if (prev != DRAWING_OP_TO) {</span>
<span class="new">+        // distinguish empty path at all vs opened path ?</span>
<span class="new">+        if (prev != DRAWING_OP_TO &amp;&amp; !opened) {</span>
             if (prev == CLOSE) {
                 return;
             }
             emitMoveTo(cx0, cy0 - lineWidth2);
<span class="removed">-            this.cmx = this.smx = 0.0f;</span>
<span class="removed">-            this.cmy = this.smy = -lineWidth2;</span>
<span class="removed">-            this.cdx = this.sdx = 1.0f;</span>
<span class="removed">-            this.cdy = this.sdy = 0.0f;</span>
<span class="removed">-            finish();</span>
<span class="new">+</span>
<span class="new">+            this.sdx = 1.0f;</span>
<span class="new">+            this.sdy = 0.0f;</span>
<span class="new">+            this.cdx = 1.0f;</span>
<span class="new">+            this.cdy = 0.0f;</span>
<span class="new">+</span>
<span class="new">+            this.smx = 0.0f;</span>
<span class="new">+            this.smy = -lineWidth2;</span>
<span class="new">+            this.cmx = 0.0f;</span>
<span class="new">+            this.cmy = -lineWidth2;</span>
<span class="new">+</span>
<span class="new">+            finish(cOutCode);</span>
             return;
         }
 
<span class="new">+        // basic acceptance criteria</span>
<span class="new">+        if ((sOutCode &amp; cOutCode) == 0) {</span>
         if (cx0 != sx0 || cy0 != sy0) {
<span class="removed">-            lineTo(sx0, sy0);</span>
<span class="new">+                lineTo(sx0, sy0, true);</span>
         }
 
<span class="removed">-        drawJoin(cdx, cdy, cx0, cy0, sdx, sdy, cmx, cmy, smx, smy);</span>
<span class="new">+            drawJoin(cdx, cdy, cx0, cy0, sdx, sdy, cmx, cmy, smx, smy, sOutCode);</span>
 
         emitLineTo(sx0 + smx, sy0 + smy);
 
<span class="new">+            if (opened) {</span>
<span class="new">+                emitLineTo(sx0 - smx, sy0 - smy);</span>
<span class="new">+            } else {</span>
         emitMoveTo(sx0 - smx, sy0 - smy);
<span class="new">+            }</span>
<span class="new">+        }</span>
<span class="new">+        // Ignore caps like finish(false)</span>
         emitReverse();
 
         this.prev = CLOSE;
<span class="new">+</span>
<span class="new">+        if (opened) {</span>
<span class="new">+            // do not emit close</span>
<span class="new">+            opened = false;</span>
<span class="new">+        } else {</span>
         emitClose();
     }
<span class="new">+    }</span>
 
     private void emitReverse() {
         reverse.popAll(out);
     }
 
     @Override
     public void pathDone() {
         if (prev == DRAWING_OP_TO) {
<span class="removed">-            finish();</span>
<span class="new">+            finish(cOutCode);</span>
         }
 
         out.pathDone();
 
         // this shouldn't matter since this object won't be used
</pre><hr /><pre>
<span class="newmarker">@@ -532,27 +631,43 @@</span>
 
         // Dispose this instance:
         dispose();
     }
 
<span class="removed">-    private void finish() {</span>
<span class="new">+    private void finish(final int outcode) {</span>
<span class="new">+        // Problem: impossible to guess if the path will be closed in advance</span>
<span class="new">+        //          i.e. if caps must be drawn or not ?</span>
<span class="new">+        // Solution: use the ClosedPathDetector before Stroker to determine</span>
<span class="new">+        // if the path is a closed path or not</span>
<span class="new">+        if (!rdrCtx.closedPath) {</span>
<span class="new">+            if (outcode == 0) {</span>
<span class="new">+                // current point = end's cap:</span>
         if (capStyle == CAP_ROUND) {
             drawRoundCap(cx0, cy0, cmx, cmy);
         } else if (capStyle == CAP_SQUARE) {
             emitLineTo(cx0 - cmy + cmx, cy0 + cmx + cmy);
             emitLineTo(cx0 - cmy - cmx, cy0 + cmx - cmy);
         }
<span class="removed">-</span>
<span class="new">+            }</span>
         emitReverse();
 
<span class="new">+            if (!capStart) {</span>
<span class="new">+                capStart = true;</span>
<span class="new">+</span>
<span class="new">+                if (sOutCode == 0) {</span>
<span class="new">+                    // starting point = initial cap:</span>
         if (capStyle == CAP_ROUND) {
             drawRoundCap(sx0, sy0, -smx, -smy);
         } else if (capStyle == CAP_SQUARE) {
             emitLineTo(sx0 + smy - smx, sy0 - smx - smy);
             emitLineTo(sx0 + smy + smx, sy0 - smx + smy);
         }
<span class="removed">-</span>
<span class="new">+                }</span>
<span class="new">+            }</span>
<span class="new">+        } else {</span>
<span class="new">+            emitReverse();</span>
<span class="new">+        }</span>
         emitClose();
     }
 
     private void emitMoveTo(final float x0, final float y0) {
         out.moveTo(x0, y0);
</pre><hr /><pre>
<span class="newmarker">@@ -620,28 +735,33 @@</span>
 
     private void drawJoin(float pdx, float pdy,
                           float x0, float y0,
                           float dx, float dy,
                           float omx, float omy,
<span class="removed">-                          float mx, float my)</span>
<span class="new">+                          float mx, float my,</span>
<span class="new">+                          final int outcode)</span>
     {
         if (prev != DRAWING_OP_TO) {
             emitMoveTo(x0 + mx, y0 + my);
<span class="new">+            if (!opened) {</span>
             this.sdx = dx;
             this.sdy = dy;
             this.smx = mx;
             this.smy = my;
<span class="new">+            }</span>
         } else {
<span class="removed">-            boolean cw = isCW(pdx, pdy, dx, dy);</span>
<span class="new">+            final boolean cw = isCW(pdx, pdy, dx, dy);</span>
<span class="new">+            if (outcode == 0) {</span>
             if (joinStyle == JOIN_MITER) {
                 drawMiter(pdx, pdy, x0, y0, dx, dy, omx, omy, mx, my, cw);
             } else if (joinStyle == JOIN_ROUND) {
                 drawRoundJoin(x0, y0,
                               omx, omy,
                               mx, my, cw,
                               ROUND_JOIN_THRESHOLD);
             }
<span class="new">+            }</span>
             emitLineTo(x0, y0, !cw);
         }
         prev = DRAWING_OP_TO;
     }
 
</pre><hr /><pre>
<span class="newmarker">@@ -941,23 +1061,42 @@</span>
         ret = Helpers.filterOutNotInAB(ts, 0, ret, 0.0001f, 0.9999f);
         Helpers.isort(ts, 0, ret);
         return ret;
     }
 
<span class="removed">-    @Override public void curveTo(float x1, float y1,</span>
<span class="removed">-                                  float x2, float y2,</span>
<span class="removed">-                                  float x3, float y3)</span>
<span class="new">+    @Override</span>
<span class="new">+    public void curveTo(final float x1, final float y1,</span>
<span class="new">+                        final float x2, final float y2,</span>
<span class="new">+                        final float x3, final float y3)</span>
     {
<span class="new">+        final int outcode0 = this.cOutCode;</span>
<span class="new">+        if (clipRect != null) {</span>
<span class="new">+            final int outcode3 = Helpers.outcode(x3, y3, clipRect);</span>
<span class="new">+            this.cOutCode = outcode3;</span>
<span class="new">+</span>
<span class="new">+            if ((outcode0 &amp; outcode3) != 0) {</span>
<span class="new">+                final int outcode1 = Helpers.outcode(x1, y1, clipRect);</span>
<span class="new">+                final int outcode2 = Helpers.outcode(x2, y2, clipRect);</span>
<span class="new">+</span>
<span class="new">+                // basic rejection criteria</span>
<span class="new">+                if ((outcode0 &amp; outcode1 &amp; outcode2 &amp; outcode3) != 0) {</span>
<span class="new">+                    moveTo(x3, y3, outcode0);</span>
<span class="new">+                    opened = true;</span>
<span class="new">+                    return;</span>
<span class="new">+                }</span>
<span class="new">+            }</span>
<span class="new">+        }</span>
<span class="new">+</span>
         final float[] mid = middle;
 
         mid[0] = cx0; mid[1] = cy0;
         mid[2] = x1;  mid[3] = y1;
         mid[4] = x2;  mid[5] = y2;
         mid[6] = x3;  mid[7] = y3;
 
         // need these so we can update the state at the end of this method
<span class="removed">-        final float xf = mid[6], yf = mid[7];</span>
<span class="new">+        final float xf = x3, yf = y3;</span>
         float dxs = mid[2] - mid[0];
         float dys = mid[3] - mid[1];
         float dxf = mid[6] - mid[4];
         float dyf = mid[7] - mid[5];
 
</pre><hr /><pre>
<span class="newmarker">@@ -979,10 +1118,14 @@</span>
                 dyf = mid[7] - mid[1];
             }
         }
         if (dxs == 0.0f &amp;&amp; dys == 0.0f) {
             // this happens if the "curve" is just a point
<span class="new">+            // fix outcode0 for lineTo() call:</span>
<span class="new">+            if (clipRect != null) {</span>
<span class="new">+                this.cOutCode = outcode0;</span>
<span class="new">+            }</span>
             lineTo(mid[0], mid[1]);
             return;
         }
 
         // if these vectors are too small, normalize them, to avoid future
</pre><hr /><pre>
<span class="newmarker">@@ -997,11 +1140,11 @@</span>
             dxf /= len;
             dyf /= len;
         }
 
         computeOffset(dxs, dys, lineWidth2, offset0);
<span class="removed">-        drawJoin(cdx, cdy, cx0, cy0, dxs, dys, cmx, cmy, offset0[0], offset0[1]);</span>
<span class="new">+        drawJoin(cdx, cdy, cx0, cy0, dxs, dys, cmx, cmy, offset0[0], offset0[1], outcode0);</span>
 
         final int nSplits = findSubdivPoints(curve, mid, subdivTs, 8, lineWidth2);
 
         float prevT = 0.0f;
         for (int i = 0, off = 0; i &lt; nSplits; i++, off += 6) {
</pre><hr /><pre>
<span class="newmarker">@@ -1032,38 +1175,62 @@</span>
             default:
             }
             emitLineToRev(r[kind - 2], r[kind - 1]);
         }
 
<span class="removed">-        this.cmx = (l[kind - 2] - r[kind - 2]) / 2.0f;</span>
<span class="removed">-        this.cmy = (l[kind - 1] - r[kind - 1]) / 2.0f;</span>
<span class="removed">-        this.cdx = dxf;</span>
<span class="removed">-        this.cdy = dyf;</span>
<span class="new">+        this.prev = DRAWING_OP_TO;</span>
         this.cx0 = xf;
         this.cy0 = yf;
<span class="removed">-        this.prev = DRAWING_OP_TO;</span>
<span class="new">+        this.cdx = dxf;</span>
<span class="new">+        this.cdy = dyf;</span>
<span class="new">+        this.cmx = (l[kind - 2] - r[kind - 2]) / 2.0f;</span>
<span class="new">+        this.cmy = (l[kind - 1] - r[kind - 1]) / 2.0f;</span>
<span class="new">+    }</span>
<span class="new">+</span>
<span class="new">+    @Override</span>
<span class="new">+    public void quadTo(final float x1, final float y1,</span>
<span class="new">+                       final float x2, final float y2)</span>
<span class="new">+    {</span>
<span class="new">+        final int outcode0 = this.cOutCode;</span>
<span class="new">+        if (clipRect != null) {</span>
<span class="new">+            final int outcode2 = Helpers.outcode(x2, y2, clipRect);</span>
<span class="new">+            this.cOutCode = outcode2;</span>
<span class="new">+</span>
<span class="new">+            if ((outcode0 &amp; outcode2) != 0) {</span>
<span class="new">+                final int outcode1 = Helpers.outcode(x1, y1, clipRect);</span>
<span class="new">+</span>
<span class="new">+                // basic rejection criteria</span>
<span class="new">+                if ((outcode0 &amp; outcode1 &amp; outcode2) != 0) {</span>
<span class="new">+                    moveTo(x2, y2, outcode0);</span>
<span class="new">+                    opened = true;</span>
<span class="new">+                    return;</span>
<span class="new">+                }</span>
<span class="new">+            }</span>
     }
 
<span class="removed">-    @Override public void quadTo(float x1, float y1, float x2, float y2) {</span>
         final float[] mid = middle;
 
         mid[0] = cx0; mid[1] = cy0;
         mid[2] = x1;  mid[3] = y1;
         mid[4] = x2;  mid[5] = y2;
 
         // need these so we can update the state at the end of this method
<span class="removed">-        final float xf = mid[4], yf = mid[5];</span>
<span class="new">+        final float xf = x2, yf = y2;</span>
         float dxs = mid[2] - mid[0];
         float dys = mid[3] - mid[1];
         float dxf = mid[4] - mid[2];
         float dyf = mid[5] - mid[3];
         if ((dxs == 0.0f &amp;&amp; dys == 0.0f) || (dxf == 0.0f &amp;&amp; dyf == 0.0f)) {
             dxs = dxf = mid[4] - mid[0];
             dys = dyf = mid[5] - mid[1];
         }
         if (dxs == 0.0f &amp;&amp; dys == 0.0f) {
             // this happens if the "curve" is just a point
<span class="new">+            // fix outcode0 for lineTo() call:</span>
<span class="new">+            if (clipRect != null) {</span>
<span class="new">+                this.cOutCode = outcode0;</span>
<span class="new">+            }</span>
             lineTo(mid[0], mid[1]);
             return;
         }
         // if these vectors are too small, normalize them, to avoid future
         // precision problems.
</pre><hr /><pre>
<span class="newmarker">@@ -1077,11 +1244,11 @@</span>
             dxf /= len;
             dyf /= len;
         }
 
         computeOffset(dxs, dys, lineWidth2, offset0);
<span class="removed">-        drawJoin(cdx, cdy, cx0, cy0, dxs, dys, cmx, cmy, offset0[0], offset0[1]);</span>
<span class="new">+        drawJoin(cdx, cdy, cx0, cy0, dxs, dys, cmx, cmy, offset0[0], offset0[1], outcode0);</span>
 
         int nSplits = findSubdivPoints(curve, mid, subdivTs, 6, lineWidth2);
 
         float prevt = 0.0f;
         for (int i = 0, off = 0; i &lt; nSplits; i++, off += 4) {
</pre><hr /><pre>
<span class="newmarker">@@ -1112,216 +1279,18 @@</span>
             default:
             }
             emitLineToRev(r[kind - 2], r[kind - 1]);
         }
 
<span class="removed">-        this.cmx = (l[kind - 2] - r[kind - 2]) / 2.0f;</span>
<span class="removed">-        this.cmy = (l[kind - 1] - r[kind - 1]) / 2.0f;</span>
<span class="removed">-        this.cdx = dxf;</span>
<span class="removed">-        this.cdy = dyf;</span>
<span class="new">+        this.prev = DRAWING_OP_TO;</span>
         this.cx0 = xf;
         this.cy0 = yf;
<span class="removed">-        this.prev = DRAWING_OP_TO;</span>
<span class="new">+        this.cdx = dxf;</span>
<span class="new">+        this.cdy = dyf;</span>
<span class="new">+        this.cmx = (l[kind - 2] - r[kind - 2]) / 2.0f;</span>
<span class="new">+        this.cmy = (l[kind - 1] - r[kind - 1]) / 2.0f;</span>
     }
 
     @Override public long getNativeConsumer() {
         throw new InternalError("Stroker doesn't use a native consumer");
     }
<span class="removed">-</span>
<span class="removed">-    // a stack of polynomial curves where each curve shares endpoints with</span>
<span class="removed">-    // adjacent ones.</span>
<span class="removed">-    static final class PolyStack {</span>
<span class="removed">-        private static final byte TYPE_LINETO  = (byte) 0;</span>
<span class="removed">-        private static final byte TYPE_QUADTO  = (byte) 1;</span>
<span class="removed">-        private static final byte TYPE_CUBICTO = (byte) 2;</span>
<span class="removed">-</span>
<span class="removed">-        // curves capacity = edges count (8192) = edges x 2 (coords)</span>
<span class="removed">-        private static final int INITIAL_CURVES_COUNT = INITIAL_EDGES_COUNT &lt;&lt; 1;</span>
<span class="removed">-</span>
<span class="removed">-        // types capacity = edges count (4096)</span>
<span class="removed">-        private static final int INITIAL_TYPES_COUNT = INITIAL_EDGES_COUNT;</span>
<span class="removed">-</span>
<span class="removed">-        float[] curves;</span>
<span class="removed">-        int end;</span>
<span class="removed">-        byte[] curveTypes;</span>
<span class="removed">-        int numCurves;</span>
<span class="removed">-</span>
<span class="removed">-        // per-thread renderer context</span>
<span class="removed">-        final RendererContext rdrCtx;</span>
<span class="removed">-</span>
<span class="removed">-        // curves ref (dirty)</span>
<span class="removed">-        final FloatArrayCache.Reference curves_ref;</span>
<span class="removed">-        // curveTypes ref (dirty)</span>
<span class="removed">-        final ByteArrayCache.Reference curveTypes_ref;</span>
<span class="removed">-</span>
<span class="removed">-        // used marks (stats only)</span>
<span class="removed">-        int curveTypesUseMark;</span>
<span class="removed">-        int curvesUseMark;</span>
<span class="removed">-</span>
<span class="removed">-        /**</span>
<span class="removed">-         * Constructor</span>
<span class="removed">-         * @param rdrCtx per-thread renderer context</span>
<span class="removed">-         */</span>
<span class="removed">-        PolyStack(final RendererContext rdrCtx) {</span>
<span class="removed">-            this.rdrCtx = rdrCtx;</span>
<span class="removed">-</span>
<span class="removed">-            curves_ref = rdrCtx.newDirtyFloatArrayRef(INITIAL_CURVES_COUNT); // 32K</span>
<span class="removed">-            curves     = curves_ref.initial;</span>
<span class="removed">-</span>
<span class="removed">-            curveTypes_ref = rdrCtx.newDirtyByteArrayRef(INITIAL_TYPES_COUNT); // 4K</span>
<span class="removed">-            curveTypes     = curveTypes_ref.initial;</span>
<span class="removed">-            numCurves = 0;</span>
<span class="removed">-            end = 0;</span>
<span class="removed">-</span>
<span class="removed">-            if (DO_STATS) {</span>
<span class="removed">-                curveTypesUseMark = 0;</span>
<span class="removed">-                curvesUseMark = 0;</span>
<span class="removed">-            }</span>
<span class="removed">-        }</span>
<span class="removed">-</span>
<span class="removed">-        /**</span>
<span class="removed">-         * Disposes this PolyStack:</span>
<span class="removed">-         * clean up before reusing this instance</span>
<span class="removed">-         */</span>
<span class="removed">-        void dispose() {</span>
<span class="removed">-            end = 0;</span>
<span class="removed">-            numCurves = 0;</span>
<span class="removed">-</span>
<span class="removed">-            if (DO_STATS) {</span>
<span class="removed">-                rdrCtx.stats.stat_rdr_poly_stack_types.add(curveTypesUseMark);</span>
<span class="removed">-                rdrCtx.stats.stat_rdr_poly_stack_curves.add(curvesUseMark);</span>
<span class="removed">-                rdrCtx.stats.hist_rdr_poly_stack_curves.add(curvesUseMark);</span>
<span class="removed">-</span>
<span class="removed">-                // reset marks</span>
<span class="removed">-                curveTypesUseMark = 0;</span>
<span class="removed">-                curvesUseMark = 0;</span>
<span class="removed">-            }</span>
<span class="removed">-</span>
<span class="removed">-            // Return arrays:</span>
<span class="removed">-            // curves and curveTypes are kept dirty</span>
<span class="removed">-            curves     = curves_ref.putArray(curves);</span>
<span class="removed">-            curveTypes = curveTypes_ref.putArray(curveTypes);</span>
<span class="removed">-        }</span>
<span class="removed">-</span>
<span class="removed">-        private void ensureSpace(final int n) {</span>
<span class="removed">-            // use substraction to avoid integer overflow:</span>
<span class="removed">-            if (curves.length - end &lt; n) {</span>
<span class="removed">-                if (DO_STATS) {</span>
<span class="removed">-                    rdrCtx.stats.stat_array_stroker_polystack_curves</span>
<span class="removed">-                        .add(end + n);</span>
<span class="removed">-                }</span>
<span class="removed">-                curves = curves_ref.widenArray(curves, end, end + n);</span>
<span class="removed">-            }</span>
<span class="removed">-            if (curveTypes.length &lt;= numCurves) {</span>
<span class="removed">-                if (DO_STATS) {</span>
<span class="removed">-                    rdrCtx.stats.stat_array_stroker_polystack_curveTypes</span>
<span class="removed">-                        .add(numCurves + 1);</span>
<span class="removed">-                }</span>
<span class="removed">-                curveTypes = curveTypes_ref.widenArray(curveTypes,</span>
<span class="removed">-                                                       numCurves,</span>
<span class="removed">-                                                       numCurves + 1);</span>
<span class="removed">-            }</span>
<span class="removed">-        }</span>
<span class="removed">-</span>
<span class="removed">-        void pushCubic(float x0, float y0,</span>
<span class="removed">-                       float x1, float y1,</span>
<span class="removed">-                       float x2, float y2)</span>
<span class="removed">-        {</span>
<span class="removed">-            ensureSpace(6);</span>
<span class="removed">-            curveTypes[numCurves++] = TYPE_CUBICTO;</span>
<span class="removed">-            // we reverse the coordinate order to make popping easier</span>
<span class="removed">-            final float[] _curves = curves;</span>
<span class="removed">-            int e = end;</span>
<span class="removed">-            _curves[e++] = x2;    _curves[e++] = y2;</span>
<span class="removed">-            _curves[e++] = x1;    _curves[e++] = y1;</span>
<span class="removed">-            _curves[e++] = x0;    _curves[e++] = y0;</span>
<span class="removed">-            end = e;</span>
<span class="removed">-        }</span>
<span class="removed">-</span>
<span class="removed">-        void pushQuad(float x0, float y0,</span>
<span class="removed">-                      float x1, float y1)</span>
<span class="removed">-        {</span>
<span class="removed">-            ensureSpace(4);</span>
<span class="removed">-            curveTypes[numCurves++] = TYPE_QUADTO;</span>
<span class="removed">-            final float[] _curves = curves;</span>
<span class="removed">-            int e = end;</span>
<span class="removed">-            _curves[e++] = x1;    _curves[e++] = y1;</span>
<span class="removed">-            _curves[e++] = x0;    _curves[e++] = y0;</span>
<span class="removed">-            end = e;</span>
<span class="removed">-        }</span>
<span class="removed">-</span>
<span class="removed">-        void pushLine(float x, float y) {</span>
<span class="removed">-            ensureSpace(2);</span>
<span class="removed">-            curveTypes[numCurves++] = TYPE_LINETO;</span>
<span class="removed">-            curves[end++] = x;    curves[end++] = y;</span>
<span class="removed">-        }</span>
<span class="removed">-</span>
<span class="removed">-        void popAll(PathConsumer2D io) {</span>
<span class="removed">-            if (DO_STATS) {</span>
<span class="removed">-                // update used marks:</span>
<span class="removed">-                if (numCurves &gt; curveTypesUseMark) {</span>
<span class="removed">-                    curveTypesUseMark = numCurves;</span>
<span class="removed">-                }</span>
<span class="removed">-                if (end &gt; curvesUseMark) {</span>
<span class="removed">-                    curvesUseMark = end;</span>
<span class="removed">-                }</span>
<span class="removed">-            }</span>
<span class="removed">-            final byte[]  _curveTypes = curveTypes;</span>
<span class="removed">-            final float[] _curves = curves;</span>
<span class="removed">-            int nc = numCurves;</span>
<span class="removed">-            int e  = end;</span>
<span class="removed">-</span>
<span class="removed">-            while (nc != 0) {</span>
<span class="removed">-                switch(_curveTypes[--nc]) {</span>
<span class="removed">-                case TYPE_LINETO:</span>
<span class="removed">-                    e -= 2;</span>
<span class="removed">-                    io.lineTo(_curves[e], _curves[e+1]);</span>
<span class="removed">-                    continue;</span>
<span class="removed">-                case TYPE_QUADTO:</span>
<span class="removed">-                    e -= 4;</span>
<span class="removed">-                    io.quadTo(_curves[e+0], _curves[e+1],</span>
<span class="removed">-                              _curves[e+2], _curves[e+3]);</span>
<span class="removed">-                    continue;</span>
<span class="removed">-                case TYPE_CUBICTO:</span>
<span class="removed">-                    e -= 6;</span>
<span class="removed">-                    io.curveTo(_curves[e+0], _curves[e+1],</span>
<span class="removed">-                               _curves[e+2], _curves[e+3],</span>
<span class="removed">-                               _curves[e+4], _curves[e+5]);</span>
<span class="removed">-                    continue;</span>
<span class="removed">-                default:</span>
<span class="removed">-                }</span>
<span class="removed">-            }</span>
<span class="removed">-            numCurves = 0;</span>
<span class="removed">-            end = 0;</span>
<span class="removed">-        }</span>
<span class="removed">-</span>
<span class="removed">-        @Override</span>
<span class="removed">-        public String toString() {</span>
<span class="removed">-            String ret = "";</span>
<span class="removed">-            int nc = numCurves;</span>
<span class="removed">-            int last = end;</span>
<span class="removed">-            int len;</span>
<span class="removed">-            while (nc != 0) {</span>
<span class="removed">-                switch(curveTypes[--nc]) {</span>
<span class="removed">-                case TYPE_LINETO:</span>
<span class="removed">-                    len = 2;</span>
<span class="removed">-                    ret += "line: ";</span>
<span class="removed">-                    break;</span>
<span class="removed">-                case TYPE_QUADTO:</span>
<span class="removed">-                    len = 4;</span>
<span class="removed">-                    ret += "quad: ";</span>
<span class="removed">-                    break;</span>
<span class="removed">-                case TYPE_CUBICTO:</span>
<span class="removed">-                    len = 6;</span>
<span class="removed">-                    ret += "cubic: ";</span>
<span class="removed">-                    break;</span>
<span class="removed">-                default:</span>
<span class="removed">-                    len = 0;</span>
<span class="removed">-                }</span>
<span class="removed">-                last -= len;</span>
<span class="removed">-                ret += Arrays.toString(Arrays.copyOfRange(curves, last, last+len))</span>
<span class="removed">-                                       + "\n";</span>
<span class="removed">-            }</span>
<span class="removed">-            return ret;</span>
<span class="removed">-        }</span>
<span class="removed">-    }</span>
 }
</pre>
<center><a href='../../../../../../src/share/classes/sun/java2d/marlin/RendererStats.java.udiff.html' target='_top'>&lt prev</a> <a href='../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../src/share/classes/sun/java2d/marlin/TransformingPathConsumer2D.java.udiff.html' target='_top'>next &gt</a></center>
</body></html>

