<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>jdk Sdiff src/share/classes/sun/java2d/marlin </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../../../src/share/classes/sun/java2d/marlin/DRendererContext.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../src/share/classes/sun/java2d/marlin/DTransformingPathConsumer2D.java.sdiff.html' target='_top'>next &gt</a></center>
<h2>src/share/classes/sun/java2d/marlin/DStroker.java</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-13694">13694</a> : <a href="https://bugs.openjdk.java.net/browse/JDK-8191814">8191814</a>: Marlin rasterizer spends time computing geometry for stroked segments that do not intersect the clip
Summary: upgrade to Marlin 0.8.2 providing efficient path clipping (Stroker and Filler)
Reviewed-by: prr, serb</pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.java2d.marlin;
  27 
  28 import java.util.Arrays;

  29 
  30 // TODO: some of the arithmetic here is too verbose and prone to hard to
  31 // debug typos. We should consider making a small Point/Vector class that
  32 // has methods like plus(Point), minus(Point), dot(Point), cross(Point)and such
  33 final class DStroker implements DPathConsumer2D, MarlinConst {
  34 
  35     private static final int MOVE_TO = 0;
  36     private static final int DRAWING_OP_TO = 1; // ie. curve, line, or quad
  37     private static final int CLOSE = 2;
  38 
<span class="removed">  39     /**</span>
<span class="removed">  40      * Constant value for join style.</span>
<span class="removed">  41      */</span>
<span class="removed">  42     public static final int JOIN_MITER = 0;</span>
<span class="removed">  43 </span>
<span class="removed">  44     /**</span>
<span class="removed">  45      * Constant value for join style.</span>
<span class="removed">  46      */</span>
<span class="removed">  47     public static final int JOIN_ROUND = 1;</span>
<span class="removed">  48 </span>
<span class="removed">  49     /**</span>
<span class="removed">  50      * Constant value for join style.</span>
<span class="removed">  51      */</span>
<span class="removed">  52     public static final int JOIN_BEVEL = 2;</span>
<span class="removed">  53 </span>
<span class="removed">  54     /**</span>
<span class="removed">  55      * Constant value for end cap style.</span>
<span class="removed">  56      */</span>
<span class="removed">  57     public static final int CAP_BUTT = 0;</span>
<span class="removed">  58 </span>
<span class="removed">  59     /**</span>
<span class="removed">  60      * Constant value for end cap style.</span>
<span class="removed">  61      */</span>
<span class="removed">  62     public static final int CAP_ROUND = 1;</span>
<span class="removed">  63 </span>
<span class="removed">  64     /**</span>
<span class="removed">  65      * Constant value for end cap style.</span>
<span class="removed">  66      */</span>
<span class="removed">  67     public static final int CAP_SQUARE = 2;</span>
<span class="removed">  68 </span>
  69     // pisces used to use fixed point arithmetic with 16 decimal digits. I
  70     // didn't want to change the values of the constant below when I converted
  71     // it to floating point, so that's why the divisions by 2^16 are there.
  72     private static final double ROUND_JOIN_THRESHOLD = 1000.0d/65536.0d;
  73 
<span class="changed">  74     private static final double C = 0.5522847498307933d;</span>




  75 
  76     private static final int MAX_N_CURVES = 11;
  77 
  78     private DPathConsumer2D out;
  79 
  80     private int capStyle;
  81     private int joinStyle;
  82 
  83     private double lineWidth2;
  84     private double invHalfLineWidth2Sq;
  85 
  86     private final double[] offset0 = new double[2];
  87     private final double[] offset1 = new double[2];
  88     private final double[] offset2 = new double[2];
  89     private final double[] miter = new double[2];
  90     private double miterLimitSq;
  91 
  92     private int prev;
  93 
  94     // The starting point of the path, and the slope there.

</pre><hr></hr><pre>
 101     // original path (thought they may have different directions), so these
 102     // could be computed from sdx,sdy and cdx,cdy (and vice versa), but that
 103     // would be error prone and hard to read, so we keep these anyway.
 104     private double smx, smy, cmx, cmy;
 105 
 106     private final PolyStack reverse;
 107 
 108     // This is where the curve to be processed is put. We give it
 109     // enough room to store all curves.
 110     private final double[] middle = new double[MAX_N_CURVES * 6 + 2];
 111     private final double[] lp = new double[8];
 112     private final double[] rp = new double[8];
 113     private final double[] subdivTs = new double[MAX_N_CURVES - 1];
 114 
 115     // per-thread renderer context
 116     final DRendererContext rdrCtx;
 117 
 118     // dirty curve
 119     final DCurve curve;
 120 














 121     /**
 122      * Constructs a &lt;code&gt;DStroker&lt;/code&gt;.
 123      * @param rdrCtx per-thread renderer context
 124      */
 125     DStroker(final DRendererContext rdrCtx) {
 126         this.rdrCtx = rdrCtx;
 127 
<span class="changed"> 128         this.reverse = new PolyStack(rdrCtx);</span>








 129         this.curve = rdrCtx.curve;
 130     }
 131 
 132     /**
 133      * Inits the &lt;code&gt;DStroker&lt;/code&gt;.
 134      *
 135      * @param pc2d an output &lt;code&gt;DPathConsumer2D&lt;/code&gt;.
 136      * @param lineWidth the desired line width in pixels
 137      * @param capStyle the desired end cap style, one of
 138      * &lt;code&gt;CAP_BUTT&lt;/code&gt;, &lt;code&gt;CAP_ROUND&lt;/code&gt; or
 139      * &lt;code&gt;CAP_SQUARE&lt;/code&gt;.
 140      * @param joinStyle the desired line join style, one of
 141      * &lt;code&gt;JOIN_MITER&lt;/code&gt;, &lt;code&gt;JOIN_ROUND&lt;/code&gt; or
 142      * &lt;code&gt;JOIN_BEVEL&lt;/code&gt;.
 143      * @param miterLimit the desired miter limit

 144      * @return this instance
 145      */
<span class="changed"> 146     DStroker init(DPathConsumer2D pc2d,</span>
<span class="changed"> 147               double lineWidth,</span>
<span class="changed"> 148               int capStyle,</span>
<span class="changed"> 149               int joinStyle,</span>
<span class="changed"> 150               double miterLimit)</span>

 151     {
 152         this.out = pc2d;
 153 
 154         this.lineWidth2 = lineWidth / 2.0d;
 155         this.invHalfLineWidth2Sq = 1.0d / (2.0d * lineWidth2 * lineWidth2);
 156         this.capStyle = capStyle;
 157         this.joinStyle = joinStyle;
 158 
<span class="changed"> 159         double limit = miterLimit * lineWidth2;</span>
 160         this.miterLimitSq = limit * limit;
 161 
 162         this.prev = CLOSE;
 163 
 164         rdrCtx.stroking = 1;
 165 
































 166         return this; // fluent API
 167     }
 168 
 169     /**
 170      * Disposes this stroker:
 171      * clean up before reusing this instance
 172      */
 173     void dispose() {
 174         reverse.dispose();
 175 



 176         if (DO_CLEAN_DIRTY) {
 177             // Force zero-fill dirty arrays:
 178             Arrays.fill(offset0, 0.0d);
 179             Arrays.fill(offset1, 0.0d);
 180             Arrays.fill(offset2, 0.0d);
 181             Arrays.fill(miter, 0.0d);
 182             Arrays.fill(middle, 0.0d);
 183             Arrays.fill(lp, 0.0d);
 184             Arrays.fill(rp, 0.0d);
 185             Arrays.fill(subdivTs, 0.0d);
 186         }
 187     }
 188 
 189     private static void computeOffset(final double lx, final double ly,
 190                                       final double w, final double[] m)
 191     {
 192         double len = lx*lx + ly*ly;
 193         if (len == 0.0d) {
 194             m[0] = 0.0d;
 195             m[1] = 0.0d;

</pre><hr></hr><pre>
 426 
 427         computeMiter((x0 - pdx) + omx, (y0 - pdy) + omy, x0 + omx, y0 + omy,
 428                      (dx + x0) + mx, (dy + y0) + my, x0 + mx, y0 + my,
 429                      miter, 0);
 430 
 431         final double miterX = miter[0];
 432         final double miterY = miter[1];
 433         double lenSq = (miterX-x0)*(miterX-x0) + (miterY-y0)*(miterY-y0);
 434 
 435         // If the lines are parallel, lenSq will be either NaN or +inf
 436         // (actually, I'm not sure if the latter is possible. The important
 437         // thing is that -inf is not possible, because lenSq is a square).
 438         // For both of those values, the comparison below will fail and
 439         // no miter will be drawn, which is correct.
 440         if (lenSq &lt; miterLimitSq) {
 441             emitLineTo(miterX, miterY, rev);
 442         }
 443     }
 444 
 445     @Override
<span class="changed"> 446     public void moveTo(double x0, double y0) {</span>























 447         if (prev == DRAWING_OP_TO) {
<span class="changed"> 448             finish();</span>
 449         }
<span class="removed"> 450         this.sx0 = this.cx0 = x0;</span>
<span class="removed"> 451         this.sy0 = this.cy0 = y0;</span>
<span class="removed"> 452         this.cdx = this.sdx = 1.0d;</span>
<span class="removed"> 453         this.cdy = this.sdy = 0.0d;</span>
 454         this.prev = MOVE_TO;





 455     }
 456 
 457     @Override
<span class="changed"> 458     public void lineTo(double x1, double y1) {</span>



















 459         double dx = x1 - cx0;
 460         double dy = y1 - cy0;
 461         if (dx == 0.0d &amp;&amp; dy == 0.0d) {
 462             dx = 1.0d;
 463         }
 464         computeOffset(dx, dy, lineWidth2, offset0);
 465         final double mx = offset0[0];
 466         final double my = offset0[1];
 467 
<span class="changed"> 468         drawJoin(cdx, cdy, cx0, cy0, dx, dy, cmx, cmy, mx, my);</span>
 469 
 470         emitLineTo(cx0 + mx, cy0 + my);
 471         emitLineTo( x1 + mx,  y1 + my);
 472 
 473         emitLineToRev(cx0 - mx, cy0 - my);
 474         emitLineToRev( x1 - mx,  y1 - my);
 475 
<span class="changed"> 476         this.cmx = mx;</span>
<span class="changed"> 477         this.cmy = my;</span>
<span class="changed"> 478         this.cdx = dx;</span>
<span class="changed"> 479         this.cdy = dy;</span>
 480         this.cx0 = x1;
 481         this.cy0 = y1;
<span class="changed"> 482         this.prev = DRAWING_OP_TO;</span>



 483     }
 484 
 485     @Override
 486     public void closePath() {
<span class="changed"> 487         if (prev != DRAWING_OP_TO) {</span>

 488             if (prev == CLOSE) {
 489                 return;
 490             }
 491             emitMoveTo(cx0, cy0 - lineWidth2);
<span class="changed"> 492             this.cmx = this.smx = 0.0d;</span>
<span class="changed"> 493             this.cmy = this.smy = -lineWidth2;</span>
<span class="changed"> 494             this.cdx = this.sdx = 1.0d;</span>
<span class="changed"> 495             this.cdy = this.sdy = 0.0d;</span>
<span class="changed"> 496             finish();</span>







 497             return;
 498         }
 499 


 500         if (cx0 != sx0 || cy0 != sy0) {
<span class="changed"> 501             lineTo(sx0, sy0);</span>
 502         }
 503 
<span class="changed"> 504         drawJoin(cdx, cdy, cx0, cy0, sdx, sdy, cmx, cmy, smx, smy);</span>
 505 
 506         emitLineTo(sx0 + smx, sy0 + smy);
 507 



 508         emitMoveTo(sx0 - smx, sy0 - smy);



 509         emitReverse();
 510 
 511         this.prev = CLOSE;





 512         emitClose();
 513     }

 514 
 515     private void emitReverse() {
 516         reverse.popAll(out);
 517     }
 518 
 519     @Override
 520     public void pathDone() {
 521         if (prev == DRAWING_OP_TO) {
<span class="changed"> 522             finish();</span>
 523         }
 524 
 525         out.pathDone();
 526 
 527         // this shouldn't matter since this object won't be used
 528         // after the call to this method.
 529         this.prev = CLOSE;
 530 
 531         // Dispose this instance:
 532         dispose();
 533     }
 534 
<span class="changed"> 535     private void finish() {</span>







 536         if (capStyle == CAP_ROUND) {
 537             drawRoundCap(cx0, cy0, cmx, cmy);
 538         } else if (capStyle == CAP_SQUARE) {
 539             emitLineTo(cx0 - cmy + cmx, cy0 + cmx + cmy);
 540             emitLineTo(cx0 - cmy - cmx, cy0 + cmx - cmy);
 541         }
<span class="changed"> 542 </span>
 543         emitReverse();
 544 





 545         if (capStyle == CAP_ROUND) {
 546             drawRoundCap(sx0, sy0, -smx, -smy);
 547         } else if (capStyle == CAP_SQUARE) {
 548             emitLineTo(sx0 + smy - smx, sy0 - smx - smy);
 549             emitLineTo(sx0 + smy + smx, sy0 - smx + smy);
 550         }
<span class="changed"> 551 </span>




 552         emitClose();
 553     }
 554 
 555     private void emitMoveTo(final double x0, final double y0) {
 556         out.moveTo(x0, y0);
 557     }
 558 
 559     private void emitLineTo(final double x1, final double y1) {
 560         out.lineTo(x1, y1);
 561     }
 562 
 563     private void emitLineToRev(final double x1, final double y1) {
 564         reverse.pushLine(x1, y1);
 565     }
 566 
 567     private void emitLineTo(final double x1, final double y1,
 568                             final boolean rev)
 569     {
 570         if (rev) {
 571             emitLineToRev(x1, y1);

</pre><hr></hr><pre>
 603     private void emitCurveTo(final double x0, final double y0,
 604                              final double x1, final double y1,
 605                              final double x2, final double y2,
 606                              final double x3, final double y3, final boolean rev)
 607     {
 608         if (rev) {
 609             reverse.pushCubic(x0, y0, x1, y1, x2, y2);
 610         } else {
 611             out.curveTo(x1, y1, x2, y2, x3, y3);
 612         }
 613     }
 614 
 615     private void emitClose() {
 616         out.closePath();
 617     }
 618 
 619     private void drawJoin(double pdx, double pdy,
 620                           double x0, double y0,
 621                           double dx, double dy,
 622                           double omx, double omy,
<span class="changed"> 623                           double mx, double my)</span>

 624     {
 625         if (prev != DRAWING_OP_TO) {
 626             emitMoveTo(x0 + mx, y0 + my);

 627             this.sdx = dx;
 628             this.sdy = dy;
 629             this.smx = mx;
 630             this.smy = my;

 631         } else {
<span class="changed"> 632             boolean cw = isCW(pdx, pdy, dx, dy);</span>

 633             if (joinStyle == JOIN_MITER) {
 634                 drawMiter(pdx, pdy, x0, y0, dx, dy, omx, omy, mx, my, cw);
 635             } else if (joinStyle == JOIN_ROUND) {
 636                 drawRoundJoin(x0, y0,
 637                               omx, omy,
 638                               mx, my, cw,
 639                               ROUND_JOIN_THRESHOLD);
 640             }

 641             emitLineTo(x0, y0, !cw);
 642         }
 643         prev = DRAWING_OP_TO;
 644     }
 645 
 646     private static boolean within(final double x1, final double y1,
 647                                   final double x2, final double y2,
 648                                   final double ERR)
 649     {
 650         assert ERR &gt; 0 : "";
 651         // compare taxicab distance. ERR will always be small, so using
 652         // true distance won't give much benefit
 653         return (DHelpers.within(x1, x2, ERR) &amp;&amp;  // we want to avoid calling Math.abs
 654                 DHelpers.within(y1, y2, ERR)); // this is just as good.
 655     }
 656 
 657     private void getLineOffsets(double x1, double y1,
 658                                 double x2, double y2,
 659                                 double[] left, double[] right) {
 660         computeOffset(x2 - x1, y2 - y1, lineWidth2, offset0);

</pre><hr></hr><pre>
 924         int ret = 0;
 925         // we subdivide at values of t such that the remaining rotated
 926         // curves are monotonic in x and y.
 927         ret += c.dxRoots(ts, ret);
 928         ret += c.dyRoots(ts, ret);
 929         // subdivide at inflection points.
 930         if (type == 8) {
 931             // quadratic curves can't have inflection points
 932             ret += c.infPoints(ts, ret);
 933         }
 934 
 935         // now we must subdivide at points where one of the offset curves will have
 936         // a cusp. This happens at ts where the radius of curvature is equal to w.
 937         ret += c.rootsOfROCMinusW(ts, ret, w, 0.0001d);
 938 
 939         ret = DHelpers.filterOutNotInAB(ts, 0, ret, 0.0001d, 0.9999d);
 940         DHelpers.isort(ts, 0, ret);
 941         return ret;
 942     }
 943 
<span class="changed"> 944     @Override public void curveTo(double x1, double y1,</span>
<span class="changed"> 945                                   double x2, double y2,</span>
<span class="changed"> 946                                   double x3, double y3)</span>

 947     {


















 948         final double[] mid = middle;
 949 
 950         mid[0] = cx0; mid[1] = cy0;
 951         mid[2] = x1;  mid[3] = y1;
 952         mid[4] = x2;  mid[5] = y2;
 953         mid[6] = x3;  mid[7] = y3;
 954 
 955         // need these so we can update the state at the end of this method
<span class="changed"> 956         final double xf = mid[6], yf = mid[7];</span>
 957         double dxs = mid[2] - mid[0];
 958         double dys = mid[3] - mid[1];
 959         double dxf = mid[6] - mid[4];
 960         double dyf = mid[7] - mid[5];
 961 
 962         boolean p1eqp2 = (dxs == 0.0d &amp;&amp; dys == 0.0d);
 963         boolean p3eqp4 = (dxf == 0.0d &amp;&amp; dyf == 0.0d);
 964         if (p1eqp2) {
 965             dxs = mid[4] - mid[0];
 966             dys = mid[5] - mid[1];
 967             if (dxs == 0.0d &amp;&amp; dys == 0.0d) {
 968                 dxs = mid[6] - mid[0];
 969                 dys = mid[7] - mid[1];
 970             }
 971         }
 972         if (p3eqp4) {
 973             dxf = mid[6] - mid[2];
 974             dyf = mid[7] - mid[3];
 975             if (dxf == 0.0d &amp;&amp; dyf == 0.0d) {
 976                 dxf = mid[6] - mid[0];
 977                 dyf = mid[7] - mid[1];
 978             }
 979         }
 980         if (dxs == 0.0d &amp;&amp; dys == 0.0d) {
 981             // this happens if the "curve" is just a point




 982             lineTo(mid[0], mid[1]);
 983             return;
 984         }
 985 
 986         // if these vectors are too small, normalize them, to avoid future
 987         // precision problems.
 988         if (Math.abs(dxs) &lt; 0.1d &amp;&amp; Math.abs(dys) &lt; 0.1d) {
 989             double len = Math.sqrt(dxs*dxs + dys*dys);
 990             dxs /= len;
 991             dys /= len;
 992         }
 993         if (Math.abs(dxf) &lt; 0.1d &amp;&amp; Math.abs(dyf) &lt; 0.1d) {
 994             double len = Math.sqrt(dxf*dxf + dyf*dyf);
 995             dxf /= len;
 996             dyf /= len;
 997         }
 998 
 999         computeOffset(dxs, dys, lineWidth2, offset0);
<span class="changed">1000         drawJoin(cdx, cdy, cx0, cy0, dxs, dys, cmx, cmy, offset0[0], offset0[1]);</span>
1001 
1002         final int nSplits = findSubdivPoints(curve, mid, subdivTs, 8, lineWidth2);
1003 
1004         double prevT = 0.0d;
1005         for (int i = 0, off = 0; i &lt; nSplits; i++, off += 6) {
1006             final double t = subdivTs[i];
1007             DHelpers.subdivideCubicAt((t - prevT) / (1.0d - prevT),
1008                                      mid, off, mid, off, mid, off + 6);
1009             prevT = t;
1010         }
1011 
1012         final double[] l = lp;
1013         final double[] r = rp;
1014 
1015         int kind = 0;
1016         for (int i = 0, off = 0; i &lt;= nSplits; i++, off += 6) {
1017             kind = computeOffsetCubic(mid, off, l, r);
1018 
1019             emitLineTo(l[0], l[1]);
1020 
1021             switch(kind) {
1022             case 8:
1023                 emitCurveTo(l[2], l[3], l[4], l[5], l[6], l[7]);
1024                 emitCurveToRev(r[0], r[1], r[2], r[3], r[4], r[5]);
1025                 break;
1026             case 4:
1027                 emitLineTo(l[2], l[3]);
1028                 emitLineToRev(r[0], r[1]);
1029                 break;
1030             default:
1031             }
1032             emitLineToRev(r[kind - 2], r[kind - 1]);
1033         }
1034 
<span class="changed">1035         this.cmx = (l[kind - 2] - r[kind - 2]) / 2.0d;</span>
<span class="changed">1036         this.cmy = (l[kind - 1] - r[kind - 1]) / 2.0d;</span>
<span class="changed">1037         this.cdx = dxf;</span>
<span class="changed">1038         this.cdy = dyf;</span>
1039         this.cx0 = xf;
1040         this.cy0 = yf;
<span class="changed">1041         this.prev = DRAWING_OP_TO;</span>
























1042     }
1043 
<span class="removed">1044     @Override public void quadTo(double x1, double y1, double x2, double y2) {</span>
1045         final double[] mid = middle;
1046 
1047         mid[0] = cx0; mid[1] = cy0;
1048         mid[2] = x1;  mid[3] = y1;
1049         mid[4] = x2;  mid[5] = y2;
1050 
1051         // need these so we can update the state at the end of this method
<span class="changed">1052         final double xf = mid[4], yf = mid[5];</span>
1053         double dxs = mid[2] - mid[0];
1054         double dys = mid[3] - mid[1];
1055         double dxf = mid[4] - mid[2];
1056         double dyf = mid[5] - mid[3];
1057         if ((dxs == 0.0d &amp;&amp; dys == 0.0d) || (dxf == 0.0d &amp;&amp; dyf == 0.0d)) {
1058             dxs = dxf = mid[4] - mid[0];
1059             dys = dyf = mid[5] - mid[1];
1060         }
1061         if (dxs == 0.0d &amp;&amp; dys == 0.0d) {
1062             // this happens if the "curve" is just a point




1063             lineTo(mid[0], mid[1]);
1064             return;
1065         }
1066         // if these vectors are too small, normalize them, to avoid future
1067         // precision problems.
1068         if (Math.abs(dxs) &lt; 0.1d &amp;&amp; Math.abs(dys) &lt; 0.1d) {
1069             double len = Math.sqrt(dxs*dxs + dys*dys);
1070             dxs /= len;
1071             dys /= len;
1072         }
1073         if (Math.abs(dxf) &lt; 0.1d &amp;&amp; Math.abs(dyf) &lt; 0.1d) {
1074             double len = Math.sqrt(dxf*dxf + dyf*dyf);
1075             dxf /= len;
1076             dyf /= len;
1077         }
1078 
1079         computeOffset(dxs, dys, lineWidth2, offset0);
<span class="changed">1080         drawJoin(cdx, cdy, cx0, cy0, dxs, dys, cmx, cmy, offset0[0], offset0[1]);</span>
1081 
1082         int nSplits = findSubdivPoints(curve, mid, subdivTs, 6, lineWidth2);
1083 
1084         double prevt = 0.0d;
1085         for (int i = 0, off = 0; i &lt; nSplits; i++, off += 4) {
1086             final double t = subdivTs[i];
1087             DHelpers.subdivideQuadAt((t - prevt) / (1.0d - prevt),
1088                                     mid, off, mid, off, mid, off + 4);
1089             prevt = t;
1090         }
1091 
1092         final double[] l = lp;
1093         final double[] r = rp;
1094 
1095         int kind = 0;
1096         for (int i = 0, off = 0; i &lt;= nSplits; i++, off += 4) {
1097             kind = computeOffsetQuad(mid, off, l, r);
1098 
1099             emitLineTo(l[0], l[1]);
1100 
1101             switch(kind) {
1102             case 6:
1103                 emitQuadTo(l[2], l[3], l[4], l[5]);
1104                 emitQuadToRev(r[0], r[1], r[2], r[3]);
1105                 break;
1106             case 4:
1107                 emitLineTo(l[2], l[3]);
1108                 emitLineToRev(r[0], r[1]);
1109                 break;
1110             default:
1111             }
1112             emitLineToRev(r[kind - 2], r[kind - 1]);
1113         }
1114 
<span class="changed">1115         this.cmx = (l[kind - 2] - r[kind - 2]) / 2.0d;</span>
<span class="changed">1116         this.cmy = (l[kind - 1] - r[kind - 1]) / 2.0d;</span>
<span class="changed">1117         this.cdx = dxf;</span>
<span class="changed">1118         this.cdy = dyf;</span>
1119         this.cx0 = xf;
1120         this.cy0 = yf;
<span class="changed">1121         this.prev = DRAWING_OP_TO;</span>



1122     }
1123 
1124     @Override public long getNativeConsumer() {
1125         throw new InternalError("Stroker doesn't use a native consumer");
1126     }
<span class="removed">1127 </span>
<span class="removed">1128     // a stack of polynomial curves where each curve shares endpoints with</span>
<span class="removed">1129     // adjacent ones.</span>
<span class="removed">1130     static final class PolyStack {</span>
<span class="removed">1131         private static final byte TYPE_LINETO  = (byte) 0;</span>
<span class="removed">1132         private static final byte TYPE_QUADTO  = (byte) 1;</span>
<span class="removed">1133         private static final byte TYPE_CUBICTO = (byte) 2;</span>
<span class="removed">1134 </span>
<span class="removed">1135         // curves capacity = edges count (8192) = edges x 2 (coords)</span>
<span class="removed">1136         private static final int INITIAL_CURVES_COUNT = INITIAL_EDGES_COUNT &lt;&lt; 1;</span>
<span class="removed">1137 </span>
<span class="removed">1138         // types capacity = edges count (4096)</span>
<span class="removed">1139         private static final int INITIAL_TYPES_COUNT = INITIAL_EDGES_COUNT;</span>
<span class="removed">1140 </span>
<span class="removed">1141         double[] curves;</span>
<span class="removed">1142         int end;</span>
<span class="removed">1143         byte[] curveTypes;</span>
<span class="removed">1144         int numCurves;</span>
<span class="removed">1145 </span>
<span class="removed">1146         // per-thread renderer context</span>
<span class="removed">1147         final DRendererContext rdrCtx;</span>
<span class="removed">1148 </span>
<span class="removed">1149         // curves ref (dirty)</span>
<span class="removed">1150         final DoubleArrayCache.Reference curves_ref;</span>
<span class="removed">1151         // curveTypes ref (dirty)</span>
<span class="removed">1152         final ByteArrayCache.Reference curveTypes_ref;</span>
<span class="removed">1153 </span>
<span class="removed">1154         // used marks (stats only)</span>
<span class="removed">1155         int curveTypesUseMark;</span>
<span class="removed">1156         int curvesUseMark;</span>
<span class="removed">1157 </span>
<span class="removed">1158         /**</span>
<span class="removed">1159          * Constructor</span>
<span class="removed">1160          * @param rdrCtx per-thread renderer context</span>
<span class="removed">1161          */</span>
<span class="removed">1162         PolyStack(final DRendererContext rdrCtx) {</span>
<span class="removed">1163             this.rdrCtx = rdrCtx;</span>
<span class="removed">1164 </span>
<span class="removed">1165             curves_ref = rdrCtx.newDirtyDoubleArrayRef(INITIAL_CURVES_COUNT); // 32K</span>
<span class="removed">1166             curves     = curves_ref.initial;</span>
<span class="removed">1167 </span>
<span class="removed">1168             curveTypes_ref = rdrCtx.newDirtyByteArrayRef(INITIAL_TYPES_COUNT); // 4K</span>
<span class="removed">1169             curveTypes     = curveTypes_ref.initial;</span>
<span class="removed">1170             numCurves = 0;</span>
<span class="removed">1171             end = 0;</span>
<span class="removed">1172 </span>
<span class="removed">1173             if (DO_STATS) {</span>
<span class="removed">1174                 curveTypesUseMark = 0;</span>
<span class="removed">1175                 curvesUseMark = 0;</span>
<span class="removed">1176             }</span>
<span class="removed">1177         }</span>
<span class="removed">1178 </span>
<span class="removed">1179         /**</span>
<span class="removed">1180          * Disposes this PolyStack:</span>
<span class="removed">1181          * clean up before reusing this instance</span>
<span class="removed">1182          */</span>
<span class="removed">1183         void dispose() {</span>
<span class="removed">1184             end = 0;</span>
<span class="removed">1185             numCurves = 0;</span>
<span class="removed">1186 </span>
<span class="removed">1187             if (DO_STATS) {</span>
<span class="removed">1188                 rdrCtx.stats.stat_rdr_poly_stack_types.add(curveTypesUseMark);</span>
<span class="removed">1189                 rdrCtx.stats.stat_rdr_poly_stack_curves.add(curvesUseMark);</span>
<span class="removed">1190                 rdrCtx.stats.hist_rdr_poly_stack_curves.add(curvesUseMark);</span>
<span class="removed">1191 </span>
<span class="removed">1192                 // reset marks</span>
<span class="removed">1193                 curveTypesUseMark = 0;</span>
<span class="removed">1194                 curvesUseMark = 0;</span>
<span class="removed">1195             }</span>
<span class="removed">1196 </span>
<span class="removed">1197             // Return arrays:</span>
<span class="removed">1198             // curves and curveTypes are kept dirty</span>
<span class="removed">1199             curves     = curves_ref.putArray(curves);</span>
<span class="removed">1200             curveTypes = curveTypes_ref.putArray(curveTypes);</span>
<span class="removed">1201         }</span>
<span class="removed">1202 </span>
<span class="removed">1203         private void ensureSpace(final int n) {</span>
<span class="removed">1204             // use substraction to avoid integer overflow:</span>
<span class="removed">1205             if (curves.length - end &lt; n) {</span>
<span class="removed">1206                 if (DO_STATS) {</span>
<span class="removed">1207                     rdrCtx.stats.stat_array_stroker_polystack_curves</span>
<span class="removed">1208                         .add(end + n);</span>
<span class="removed">1209                 }</span>
<span class="removed">1210                 curves = curves_ref.widenArray(curves, end, end + n);</span>
<span class="removed">1211             }</span>
<span class="removed">1212             if (curveTypes.length &lt;= numCurves) {</span>
<span class="removed">1213                 if (DO_STATS) {</span>
<span class="removed">1214                     rdrCtx.stats.stat_array_stroker_polystack_curveTypes</span>
<span class="removed">1215                         .add(numCurves + 1);</span>
<span class="removed">1216                 }</span>
<span class="removed">1217                 curveTypes = curveTypes_ref.widenArray(curveTypes,</span>
<span class="removed">1218                                                        numCurves,</span>
<span class="removed">1219                                                        numCurves + 1);</span>
<span class="removed">1220             }</span>
<span class="removed">1221         }</span>
<span class="removed">1222 </span>
<span class="removed">1223         void pushCubic(double x0, double y0,</span>
<span class="removed">1224                        double x1, double y1,</span>
<span class="removed">1225                        double x2, double y2)</span>
<span class="removed">1226         {</span>
<span class="removed">1227             ensureSpace(6);</span>
<span class="removed">1228             curveTypes[numCurves++] = TYPE_CUBICTO;</span>
<span class="removed">1229             // we reverse the coordinate order to make popping easier</span>
<span class="removed">1230             final double[] _curves = curves;</span>
<span class="removed">1231             int e = end;</span>
<span class="removed">1232             _curves[e++] = x2;    _curves[e++] = y2;</span>
<span class="removed">1233             _curves[e++] = x1;    _curves[e++] = y1;</span>
<span class="removed">1234             _curves[e++] = x0;    _curves[e++] = y0;</span>
<span class="removed">1235             end = e;</span>
<span class="removed">1236         }</span>
<span class="removed">1237 </span>
<span class="removed">1238         void pushQuad(double x0, double y0,</span>
<span class="removed">1239                       double x1, double y1)</span>
<span class="removed">1240         {</span>
<span class="removed">1241             ensureSpace(4);</span>
<span class="removed">1242             curveTypes[numCurves++] = TYPE_QUADTO;</span>
<span class="removed">1243             final double[] _curves = curves;</span>
<span class="removed">1244             int e = end;</span>
<span class="removed">1245             _curves[e++] = x1;    _curves[e++] = y1;</span>
<span class="removed">1246             _curves[e++] = x0;    _curves[e++] = y0;</span>
<span class="removed">1247             end = e;</span>
<span class="removed">1248         }</span>
<span class="removed">1249 </span>
<span class="removed">1250         void pushLine(double x, double y) {</span>
<span class="removed">1251             ensureSpace(2);</span>
<span class="removed">1252             curveTypes[numCurves++] = TYPE_LINETO;</span>
<span class="removed">1253             curves[end++] = x;    curves[end++] = y;</span>
<span class="removed">1254         }</span>
<span class="removed">1255 </span>
<span class="removed">1256         void popAll(DPathConsumer2D io) {</span>
<span class="removed">1257             if (DO_STATS) {</span>
<span class="removed">1258                 // update used marks:</span>
<span class="removed">1259                 if (numCurves &gt; curveTypesUseMark) {</span>
<span class="removed">1260                     curveTypesUseMark = numCurves;</span>
<span class="removed">1261                 }</span>
<span class="removed">1262                 if (end &gt; curvesUseMark) {</span>
<span class="removed">1263                     curvesUseMark = end;</span>
<span class="removed">1264                 }</span>
<span class="removed">1265             }</span>
<span class="removed">1266             final byte[]  _curveTypes = curveTypes;</span>
<span class="removed">1267             final double[] _curves = curves;</span>
<span class="removed">1268             int nc = numCurves;</span>
<span class="removed">1269             int e  = end;</span>
<span class="removed">1270 </span>
<span class="removed">1271             while (nc != 0) {</span>
<span class="removed">1272                 switch(_curveTypes[--nc]) {</span>
<span class="removed">1273                 case TYPE_LINETO:</span>
<span class="removed">1274                     e -= 2;</span>
<span class="removed">1275                     io.lineTo(_curves[e], _curves[e+1]);</span>
<span class="removed">1276                     continue;</span>
<span class="removed">1277                 case TYPE_QUADTO:</span>
<span class="removed">1278                     e -= 4;</span>
<span class="removed">1279                     io.quadTo(_curves[e+0], _curves[e+1],</span>
<span class="removed">1280                               _curves[e+2], _curves[e+3]);</span>
<span class="removed">1281                     continue;</span>
<span class="removed">1282                 case TYPE_CUBICTO:</span>
<span class="removed">1283                     e -= 6;</span>
<span class="removed">1284                     io.curveTo(_curves[e+0], _curves[e+1],</span>
<span class="removed">1285                                _curves[e+2], _curves[e+3],</span>
<span class="removed">1286                                _curves[e+4], _curves[e+5]);</span>
<span class="removed">1287                     continue;</span>
<span class="removed">1288                 default:</span>
<span class="removed">1289                 }</span>
<span class="removed">1290             }</span>
<span class="removed">1291             numCurves = 0;</span>
<span class="removed">1292             end = 0;</span>
<span class="removed">1293         }</span>
<span class="removed">1294 </span>
<span class="removed">1295         @Override</span>
<span class="removed">1296         public String toString() {</span>
<span class="removed">1297             String ret = "";</span>
<span class="removed">1298             int nc = numCurves;</span>
<span class="removed">1299             int last = end;</span>
<span class="removed">1300             int len;</span>
<span class="removed">1301             while (nc != 0) {</span>
<span class="removed">1302                 switch(curveTypes[--nc]) {</span>
<span class="removed">1303                 case TYPE_LINETO:</span>
<span class="removed">1304                     len = 2;</span>
<span class="removed">1305                     ret += "line: ";</span>
<span class="removed">1306                     break;</span>
<span class="removed">1307                 case TYPE_QUADTO:</span>
<span class="removed">1308                     len = 4;</span>
<span class="removed">1309                     ret += "quad: ";</span>
<span class="removed">1310                     break;</span>
<span class="removed">1311                 case TYPE_CUBICTO:</span>
<span class="removed">1312                     len = 6;</span>
<span class="removed">1313                     ret += "cubic: ";</span>
<span class="removed">1314                     break;</span>
<span class="removed">1315                 default:</span>
<span class="removed">1316                     len = 0;</span>
<span class="removed">1317                 }</span>
<span class="removed">1318                 last -= len;</span>
<span class="removed">1319                 ret += Arrays.toString(Arrays.copyOfRange(curves, last, last+len))</span>
<span class="removed">1320                                        + "\n";</span>
<span class="removed">1321             }</span>
<span class="removed">1322             return ret;</span>
<span class="removed">1323         }</span>
<span class="removed">1324     }</span>
1325 }
</pre></td><td><pre>

</pre><hr></hr><pre>
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.java2d.marlin;
  27 
  28 import java.util.Arrays;
<span class="new">  29 import sun.java2d.marlin.DHelpers.PolyStack;</span>
  30 
  31 // TODO: some of the arithmetic here is too verbose and prone to hard to
  32 // debug typos. We should consider making a small Point/Vector class that
  33 // has methods like plus(Point), minus(Point), dot(Point), cross(Point)and such
  34 final class DStroker implements DPathConsumer2D, MarlinConst {
  35 
  36     private static final int MOVE_TO = 0;
  37     private static final int DRAWING_OP_TO = 1; // ie. curve, line, or quad
  38     private static final int CLOSE = 2;
  39 






























  40     // pisces used to use fixed point arithmetic with 16 decimal digits. I
  41     // didn't want to change the values of the constant below when I converted
  42     // it to floating point, so that's why the divisions by 2^16 are there.
  43     private static final double ROUND_JOIN_THRESHOLD = 1000.0d/65536.0d;
  44 
<span class="changed">  45     // kappa = (4/3) * (SQRT(2) - 1)</span>
<span class="changed">  46     private static final double C = (4.0d * (Math.sqrt(2.0d) - 1.0d) / 3.0d);</span>
<span class="changed">  47 </span>
<span class="changed">  48     // SQRT(2)</span>
<span class="changed">  49     private static final double SQRT_2 = Math.sqrt(2.0d);</span>
  50 
  51     private static final int MAX_N_CURVES = 11;
  52 
  53     private DPathConsumer2D out;
  54 
  55     private int capStyle;
  56     private int joinStyle;
  57 
  58     private double lineWidth2;
  59     private double invHalfLineWidth2Sq;
  60 
  61     private final double[] offset0 = new double[2];
  62     private final double[] offset1 = new double[2];
  63     private final double[] offset2 = new double[2];
  64     private final double[] miter = new double[2];
  65     private double miterLimitSq;
  66 
  67     private int prev;
  68 
  69     // The starting point of the path, and the slope there.

</pre><hr></hr><pre>
  76     // original path (thought they may have different directions), so these
  77     // could be computed from sdx,sdy and cdx,cdy (and vice versa), but that
  78     // would be error prone and hard to read, so we keep these anyway.
  79     private double smx, smy, cmx, cmy;
  80 
  81     private final PolyStack reverse;
  82 
  83     // This is where the curve to be processed is put. We give it
  84     // enough room to store all curves.
  85     private final double[] middle = new double[MAX_N_CURVES * 6 + 2];
  86     private final double[] lp = new double[8];
  87     private final double[] rp = new double[8];
  88     private final double[] subdivTs = new double[MAX_N_CURVES - 1];
  89 
  90     // per-thread renderer context
  91     final DRendererContext rdrCtx;
  92 
  93     // dirty curve
  94     final DCurve curve;
  95 
<span class="new">  96     // Bounds of the drawing region, at pixel precision.</span>
<span class="new">  97     private double[] clipRect;</span>
<span class="new">  98 </span>
<span class="new">  99     // the outcode of the current point</span>
<span class="new"> 100     private int cOutCode = 0;</span>
<span class="new"> 101 </span>
<span class="new"> 102     // the outcode of the starting point</span>
<span class="new"> 103     private int sOutCode = 0;</span>
<span class="new"> 104 </span>
<span class="new"> 105     // flag indicating if the path is opened (clipped)</span>
<span class="new"> 106     private boolean opened = false;</span>
<span class="new"> 107     // flag indicating if the starting point's cap is done</span>
<span class="new"> 108     private boolean capStart = false;</span>
<span class="new"> 109 </span>
 110     /**
 111      * Constructs a &lt;code&gt;DStroker&lt;/code&gt;.
 112      * @param rdrCtx per-thread renderer context
 113      */
 114     DStroker(final DRendererContext rdrCtx) {
 115         this.rdrCtx = rdrCtx;
 116 
<span class="changed"> 117         this.reverse = (rdrCtx.stats != null) ?</span>
<span class="changed"> 118             new PolyStack(rdrCtx,</span>
<span class="changed"> 119                     rdrCtx.stats.stat_str_polystack_types,</span>
<span class="changed"> 120                     rdrCtx.stats.stat_str_polystack_curves,</span>
<span class="changed"> 121                     rdrCtx.stats.hist_str_polystack_curves,</span>
<span class="changed"> 122                     rdrCtx.stats.stat_array_str_polystack_curves,</span>
<span class="changed"> 123                     rdrCtx.stats.stat_array_str_polystack_types)</span>
<span class="changed"> 124             : new PolyStack(rdrCtx);</span>
<span class="changed"> 125 </span>
 126         this.curve = rdrCtx.curve;
 127     }
 128 
 129     /**
 130      * Inits the &lt;code&gt;DStroker&lt;/code&gt;.
 131      *
 132      * @param pc2d an output &lt;code&gt;DPathConsumer2D&lt;/code&gt;.
 133      * @param lineWidth the desired line width in pixels
 134      * @param capStyle the desired end cap style, one of
 135      * &lt;code&gt;CAP_BUTT&lt;/code&gt;, &lt;code&gt;CAP_ROUND&lt;/code&gt; or
 136      * &lt;code&gt;CAP_SQUARE&lt;/code&gt;.
 137      * @param joinStyle the desired line join style, one of
 138      * &lt;code&gt;JOIN_MITER&lt;/code&gt;, &lt;code&gt;JOIN_ROUND&lt;/code&gt; or
 139      * &lt;code&gt;JOIN_BEVEL&lt;/code&gt;.
 140      * @param miterLimit the desired miter limit
<span class="new"> 141      * @param scale scaling factor applied to clip boundaries</span>
 142      * @return this instance
 143      */
<span class="changed"> 144     DStroker init(final DPathConsumer2D pc2d,</span>
<span class="changed"> 145                   final double lineWidth,</span>
<span class="changed"> 146                   final int capStyle,</span>
<span class="changed"> 147                   final int joinStyle,</span>
<span class="changed"> 148                   final double miterLimit,</span>
<span class="changed"> 149                   final double scale)</span>
 150     {
 151         this.out = pc2d;
 152 
 153         this.lineWidth2 = lineWidth / 2.0d;
 154         this.invHalfLineWidth2Sq = 1.0d / (2.0d * lineWidth2 * lineWidth2);
 155         this.capStyle = capStyle;
 156         this.joinStyle = joinStyle;
 157 
<span class="changed"> 158         final double limit = miterLimit * lineWidth2;</span>
 159         this.miterLimitSq = limit * limit;
 160 
 161         this.prev = CLOSE;
 162 
 163         rdrCtx.stroking = 1;
 164 
<span class="new"> 165         if (rdrCtx.doClip) {</span>
<span class="new"> 166             // Adjust the clipping rectangle with the stroker margin (miter limit, width)</span>
<span class="new"> 167             double rdrOffX = 0.0d, rdrOffY = 0.0d;</span>
<span class="new"> 168             double margin = lineWidth2;</span>
<span class="new"> 169 </span>
<span class="new"> 170             if (capStyle == CAP_SQUARE) {</span>
<span class="new"> 171                 margin *= SQRT_2;</span>
<span class="new"> 172             }</span>
<span class="new"> 173             if ((joinStyle == JOIN_MITER) &amp;&amp; (margin &lt; limit)) {</span>
<span class="new"> 174                 margin = limit;</span>
<span class="new"> 175             }</span>
<span class="new"> 176             if (scale != 1.0d) {</span>
<span class="new"> 177                 margin *= scale;</span>
<span class="new"> 178                 rdrOffX = scale * DRenderer.RDR_OFFSET_X;</span>
<span class="new"> 179                 rdrOffY = scale * DRenderer.RDR_OFFSET_Y;</span>
<span class="new"> 180             }</span>
<span class="new"> 181             // add a small rounding error:</span>
<span class="new"> 182             margin += 1e-3d;</span>
<span class="new"> 183 </span>
<span class="new"> 184             // bounds as half-open intervals: minX &lt;= x &lt; maxX and minY &lt;= y &lt; maxY</span>
<span class="new"> 185             // adjust clip rectangle (ymin, ymax, xmin, xmax):</span>
<span class="new"> 186             final double[] _clipRect = rdrCtx.clipRect;</span>
<span class="new"> 187             _clipRect[0] -= margin - rdrOffY;</span>
<span class="new"> 188             _clipRect[1] += margin + rdrOffY;</span>
<span class="new"> 189             _clipRect[2] -= margin - rdrOffX;</span>
<span class="new"> 190             _clipRect[3] += margin + rdrOffX;</span>
<span class="new"> 191             this.clipRect = _clipRect;</span>
<span class="new"> 192         } else {</span>
<span class="new"> 193             this.clipRect = null;</span>
<span class="new"> 194             this.cOutCode = 0;</span>
<span class="new"> 195             this.sOutCode = 0;</span>
<span class="new"> 196         }</span>
 197         return this; // fluent API
 198     }
 199 
 200     /**
 201      * Disposes this stroker:
 202      * clean up before reusing this instance
 203      */
 204     void dispose() {
 205         reverse.dispose();
 206 
<span class="new"> 207         opened   = false;</span>
<span class="new"> 208         capStart = false;</span>
<span class="new"> 209 </span>
 210         if (DO_CLEAN_DIRTY) {
 211             // Force zero-fill dirty arrays:
 212             Arrays.fill(offset0, 0.0d);
 213             Arrays.fill(offset1, 0.0d);
 214             Arrays.fill(offset2, 0.0d);
 215             Arrays.fill(miter, 0.0d);
 216             Arrays.fill(middle, 0.0d);
 217             Arrays.fill(lp, 0.0d);
 218             Arrays.fill(rp, 0.0d);
 219             Arrays.fill(subdivTs, 0.0d);
 220         }
 221     }
 222 
 223     private static void computeOffset(final double lx, final double ly,
 224                                       final double w, final double[] m)
 225     {
 226         double len = lx*lx + ly*ly;
 227         if (len == 0.0d) {
 228             m[0] = 0.0d;
 229             m[1] = 0.0d;

</pre><hr></hr><pre>
 460 
 461         computeMiter((x0 - pdx) + omx, (y0 - pdy) + omy, x0 + omx, y0 + omy,
 462                      (dx + x0) + mx, (dy + y0) + my, x0 + mx, y0 + my,
 463                      miter, 0);
 464 
 465         final double miterX = miter[0];
 466         final double miterY = miter[1];
 467         double lenSq = (miterX-x0)*(miterX-x0) + (miterY-y0)*(miterY-y0);
 468 
 469         // If the lines are parallel, lenSq will be either NaN or +inf
 470         // (actually, I'm not sure if the latter is possible. The important
 471         // thing is that -inf is not possible, because lenSq is a square).
 472         // For both of those values, the comparison below will fail and
 473         // no miter will be drawn, which is correct.
 474         if (lenSq &lt; miterLimitSq) {
 475             emitLineTo(miterX, miterY, rev);
 476         }
 477     }
 478 
 479     @Override
<span class="changed"> 480     public void moveTo(final double x0, final double y0) {</span>
<span class="changed"> 481         moveTo(x0, y0, cOutCode);</span>
<span class="changed"> 482         // update starting point:</span>
<span class="changed"> 483         this.sx0 = x0;</span>
<span class="changed"> 484         this.sy0 = y0;</span>
<span class="changed"> 485         this.sdx = 1.0d;</span>
<span class="changed"> 486         this.sdy = 0.0d;</span>
<span class="changed"> 487         this.opened   = false;</span>
<span class="changed"> 488         this.capStart = false;</span>
<span class="changed"> 489 </span>
<span class="changed"> 490         if (clipRect != null) {</span>
<span class="changed"> 491             final int outcode = DHelpers.outcode(x0, y0, clipRect);</span>
<span class="changed"> 492             this.cOutCode = outcode;</span>
<span class="changed"> 493             this.sOutCode = outcode;</span>
<span class="changed"> 494         }</span>
<span class="changed"> 495     }</span>
<span class="changed"> 496 </span>
<span class="changed"> 497     private void moveTo(final double x0, final double y0,</span>
<span class="changed"> 498                         final int outcode)</span>
<span class="changed"> 499     {</span>
<span class="changed"> 500         if (prev == MOVE_TO) {</span>
<span class="changed"> 501             this.cx0 = x0;</span>
<span class="changed"> 502             this.cy0 = y0;</span>
<span class="changed"> 503         } else {</span>
 504             if (prev == DRAWING_OP_TO) {
<span class="changed"> 505                 finish(outcode);</span>
 506             }




 507             this.prev = MOVE_TO;
<span class="new"> 508             this.cx0 = x0;</span>
<span class="new"> 509             this.cy0 = y0;</span>
<span class="new"> 510             this.cdx = 1.0d;</span>
<span class="new"> 511             this.cdy = 0.0d;</span>
<span class="new"> 512         }</span>
 513     }
 514 
 515     @Override
<span class="changed"> 516     public void lineTo(final double x1, final double y1) {</span>
<span class="changed"> 517         lineTo(x1, y1, false);</span>
<span class="changed"> 518     }</span>
<span class="changed"> 519 </span>
<span class="changed"> 520     private void lineTo(final double x1, final double y1,</span>
<span class="changed"> 521                         final boolean force)</span>
<span class="changed"> 522     {</span>
<span class="changed"> 523         final int outcode0 = this.cOutCode;</span>
<span class="changed"> 524         if (!force &amp;&amp; clipRect != null) {</span>
<span class="changed"> 525             final int outcode1 = DHelpers.outcode(x1, y1, clipRect);</span>
<span class="changed"> 526             this.cOutCode = outcode1;</span>
<span class="changed"> 527 </span>
<span class="changed"> 528             // basic rejection criteria</span>
<span class="changed"> 529             if ((outcode0 &amp; outcode1) != 0) {</span>
<span class="changed"> 530                 moveTo(x1, y1, outcode0);</span>
<span class="changed"> 531                 opened = true;</span>
<span class="changed"> 532                 return;</span>
<span class="changed"> 533             }</span>
<span class="changed"> 534         }</span>
<span class="changed"> 535 </span>
 536         double dx = x1 - cx0;
 537         double dy = y1 - cy0;
 538         if (dx == 0.0d &amp;&amp; dy == 0.0d) {
 539             dx = 1.0d;
 540         }
 541         computeOffset(dx, dy, lineWidth2, offset0);
 542         final double mx = offset0[0];
 543         final double my = offset0[1];
 544 
<span class="changed"> 545         drawJoin(cdx, cdy, cx0, cy0, dx, dy, cmx, cmy, mx, my, outcode0);</span>
 546 
 547         emitLineTo(cx0 + mx, cy0 + my);
 548         emitLineTo( x1 + mx,  y1 + my);
 549 
 550         emitLineToRev(cx0 - mx, cy0 - my);
 551         emitLineToRev( x1 - mx,  y1 - my);
 552 
<span class="changed"> 553         this.prev = DRAWING_OP_TO;</span>



 554         this.cx0 = x1;
 555         this.cy0 = y1;
<span class="changed"> 556         this.cdx = dx;</span>
<span class="changed"> 557         this.cdy = dy;</span>
<span class="changed"> 558         this.cmx = mx;</span>
<span class="changed"> 559         this.cmy = my;</span>
 560     }
 561 
 562     @Override
 563     public void closePath() {
<span class="changed"> 564         // distinguish empty path at all vs opened path ?</span>
<span class="changed"> 565         if (prev != DRAWING_OP_TO &amp;&amp; !opened) {</span>
 566             if (prev == CLOSE) {
 567                 return;
 568             }
 569             emitMoveTo(cx0, cy0 - lineWidth2);
<span class="changed"> 570 </span>
<span class="changed"> 571             this.sdx = 1.0d;</span>
<span class="changed"> 572             this.sdy = 0.0d;</span>
<span class="changed"> 573             this.cdx = 1.0d;</span>
<span class="changed"> 574             this.cdy = 0.0d;</span>
<span class="changed"> 575 </span>
<span class="changed"> 576             this.smx = 0.0d;</span>
<span class="changed"> 577             this.smy = -lineWidth2;</span>
<span class="changed"> 578             this.cmx = 0.0d;</span>
<span class="changed"> 579             this.cmy = -lineWidth2;</span>
<span class="changed"> 580 </span>
<span class="changed"> 581             finish(cOutCode);</span>
 582             return;
 583         }
 584 
<span class="new"> 585         // basic acceptance criteria</span>
<span class="new"> 586         if ((sOutCode &amp; cOutCode) == 0) {</span>
 587             if (cx0 != sx0 || cy0 != sy0) {
<span class="changed"> 588                 lineTo(sx0, sy0, true);</span>
 589             }
 590 
<span class="changed"> 591             drawJoin(cdx, cdy, cx0, cy0, sdx, sdy, cmx, cmy, smx, smy, sOutCode);</span>
 592 
 593             emitLineTo(sx0 + smx, sy0 + smy);
 594 
<span class="new"> 595             if (opened) {</span>
<span class="new"> 596                 emitLineTo(sx0 - smx, sy0 - smy);</span>
<span class="new"> 597             } else {</span>
 598                 emitMoveTo(sx0 - smx, sy0 - smy);
<span class="new"> 599             }</span>
<span class="new"> 600         }</span>
<span class="new"> 601         // Ignore caps like finish(false)</span>
 602         emitReverse();
 603 
 604         this.prev = CLOSE;
<span class="new"> 605 </span>
<span class="new"> 606         if (opened) {</span>
<span class="new"> 607             // do not emit close</span>
<span class="new"> 608             opened = false;</span>
<span class="new"> 609         } else {</span>
 610             emitClose();
 611         }
<span class="new"> 612     }</span>
 613 
 614     private void emitReverse() {
 615         reverse.popAll(out);
 616     }
 617 
 618     @Override
 619     public void pathDone() {
 620         if (prev == DRAWING_OP_TO) {
<span class="changed"> 621             finish(cOutCode);</span>
 622         }
 623 
 624         out.pathDone();
 625 
 626         // this shouldn't matter since this object won't be used
 627         // after the call to this method.
 628         this.prev = CLOSE;
 629 
 630         // Dispose this instance:
 631         dispose();
 632     }
 633 
<span class="changed"> 634     private void finish(final int outcode) {</span>
<span class="changed"> 635         // Problem: impossible to guess if the path will be closed in advance</span>
<span class="changed"> 636         //          i.e. if caps must be drawn or not ?</span>
<span class="changed"> 637         // Solution: use the ClosedPathDetector before Stroker to determine</span>
<span class="changed"> 638         // if the path is a closed path or not</span>
<span class="changed"> 639         if (!rdrCtx.closedPath) {</span>
<span class="changed"> 640             if (outcode == 0) {</span>
<span class="changed"> 641                 // current point = end's cap:</span>
 642                 if (capStyle == CAP_ROUND) {
 643                     drawRoundCap(cx0, cy0, cmx, cmy);
 644                 } else if (capStyle == CAP_SQUARE) {
 645                     emitLineTo(cx0 - cmy + cmx, cy0 + cmx + cmy);
 646                     emitLineTo(cx0 - cmy - cmx, cy0 + cmx - cmy);
 647                 }
<span class="changed"> 648             }</span>
 649             emitReverse();
 650 
<span class="new"> 651             if (!capStart) {</span>
<span class="new"> 652                 capStart = true;</span>
<span class="new"> 653 </span>
<span class="new"> 654                 if (sOutCode == 0) {</span>
<span class="new"> 655                     // starting point = initial cap:</span>
 656                     if (capStyle == CAP_ROUND) {
 657                         drawRoundCap(sx0, sy0, -smx, -smy);
 658                     } else if (capStyle == CAP_SQUARE) {
 659                         emitLineTo(sx0 + smy - smx, sy0 - smx - smy);
 660                         emitLineTo(sx0 + smy + smx, sy0 - smx + smy);
 661                     }
<span class="changed"> 662                 }</span>
<span class="changed"> 663             }</span>
<span class="changed"> 664         } else {</span>
<span class="changed"> 665             emitReverse();</span>
<span class="changed"> 666         }</span>
 667         emitClose();
 668     }
 669 
 670     private void emitMoveTo(final double x0, final double y0) {
 671         out.moveTo(x0, y0);
 672     }
 673 
 674     private void emitLineTo(final double x1, final double y1) {
 675         out.lineTo(x1, y1);
 676     }
 677 
 678     private void emitLineToRev(final double x1, final double y1) {
 679         reverse.pushLine(x1, y1);
 680     }
 681 
 682     private void emitLineTo(final double x1, final double y1,
 683                             final boolean rev)
 684     {
 685         if (rev) {
 686             emitLineToRev(x1, y1);

</pre><hr></hr><pre>
 718     private void emitCurveTo(final double x0, final double y0,
 719                              final double x1, final double y1,
 720                              final double x2, final double y2,
 721                              final double x3, final double y3, final boolean rev)
 722     {
 723         if (rev) {
 724             reverse.pushCubic(x0, y0, x1, y1, x2, y2);
 725         } else {
 726             out.curveTo(x1, y1, x2, y2, x3, y3);
 727         }
 728     }
 729 
 730     private void emitClose() {
 731         out.closePath();
 732     }
 733 
 734     private void drawJoin(double pdx, double pdy,
 735                           double x0, double y0,
 736                           double dx, double dy,
 737                           double omx, double omy,
<span class="changed"> 738                           double mx, double my,</span>
<span class="changed"> 739                           final int outcode)</span>
 740     {
 741         if (prev != DRAWING_OP_TO) {
 742             emitMoveTo(x0 + mx, y0 + my);
<span class="new"> 743             if (!opened) {</span>
 744                 this.sdx = dx;
 745                 this.sdy = dy;
 746                 this.smx = mx;
 747                 this.smy = my;
<span class="new"> 748             }</span>
 749         } else {
<span class="changed"> 750             final boolean cw = isCW(pdx, pdy, dx, dy);</span>
<span class="changed"> 751             if (outcode == 0) {</span>
 752                 if (joinStyle == JOIN_MITER) {
 753                     drawMiter(pdx, pdy, x0, y0, dx, dy, omx, omy, mx, my, cw);
 754                 } else if (joinStyle == JOIN_ROUND) {
 755                     drawRoundJoin(x0, y0,
 756                                   omx, omy,
 757                                   mx, my, cw,
 758                                   ROUND_JOIN_THRESHOLD);
 759                 }
<span class="new"> 760             }</span>
 761             emitLineTo(x0, y0, !cw);
 762         }
 763         prev = DRAWING_OP_TO;
 764     }
 765 
 766     private static boolean within(final double x1, final double y1,
 767                                   final double x2, final double y2,
 768                                   final double ERR)
 769     {
 770         assert ERR &gt; 0 : "";
 771         // compare taxicab distance. ERR will always be small, so using
 772         // true distance won't give much benefit
 773         return (DHelpers.within(x1, x2, ERR) &amp;&amp;  // we want to avoid calling Math.abs
 774                 DHelpers.within(y1, y2, ERR)); // this is just as good.
 775     }
 776 
 777     private void getLineOffsets(double x1, double y1,
 778                                 double x2, double y2,
 779                                 double[] left, double[] right) {
 780         computeOffset(x2 - x1, y2 - y1, lineWidth2, offset0);

</pre><hr></hr><pre>
1044         int ret = 0;
1045         // we subdivide at values of t such that the remaining rotated
1046         // curves are monotonic in x and y.
1047         ret += c.dxRoots(ts, ret);
1048         ret += c.dyRoots(ts, ret);
1049         // subdivide at inflection points.
1050         if (type == 8) {
1051             // quadratic curves can't have inflection points
1052             ret += c.infPoints(ts, ret);
1053         }
1054 
1055         // now we must subdivide at points where one of the offset curves will have
1056         // a cusp. This happens at ts where the radius of curvature is equal to w.
1057         ret += c.rootsOfROCMinusW(ts, ret, w, 0.0001d);
1058 
1059         ret = DHelpers.filterOutNotInAB(ts, 0, ret, 0.0001d, 0.9999d);
1060         DHelpers.isort(ts, 0, ret);
1061         return ret;
1062     }
1063 
<span class="changed">1064     @Override</span>
<span class="changed">1065     public void curveTo(final double x1, final double y1,</span>
<span class="changed">1066                         final double x2, final double y2,</span>
<span class="changed">1067                         final double x3, final double y3)</span>
1068     {
<span class="new">1069         final int outcode0 = this.cOutCode;</span>
<span class="new">1070         if (clipRect != null) {</span>
<span class="new">1071             final int outcode3 = DHelpers.outcode(x3, y3, clipRect);</span>
<span class="new">1072             this.cOutCode = outcode3;</span>
<span class="new">1073 </span>
<span class="new">1074             if ((outcode0 &amp; outcode3) != 0) {</span>
<span class="new">1075                 final int outcode1 = DHelpers.outcode(x1, y1, clipRect);</span>
<span class="new">1076                 final int outcode2 = DHelpers.outcode(x2, y2, clipRect);</span>
<span class="new">1077 </span>
<span class="new">1078                 // basic rejection criteria</span>
<span class="new">1079                 if ((outcode0 &amp; outcode1 &amp; outcode2 &amp; outcode3) != 0) {</span>
<span class="new">1080                     moveTo(x3, y3, outcode0);</span>
<span class="new">1081                     opened = true;</span>
<span class="new">1082                     return;</span>
<span class="new">1083                 }</span>
<span class="new">1084             }</span>
<span class="new">1085         }</span>
<span class="new">1086 </span>
1087         final double[] mid = middle;
1088 
1089         mid[0] = cx0; mid[1] = cy0;
1090         mid[2] = x1;  mid[3] = y1;
1091         mid[4] = x2;  mid[5] = y2;
1092         mid[6] = x3;  mid[7] = y3;
1093 
1094         // need these so we can update the state at the end of this method
<span class="changed">1095         final double xf = x3, yf = y3;</span>
1096         double dxs = mid[2] - mid[0];
1097         double dys = mid[3] - mid[1];
1098         double dxf = mid[6] - mid[4];
1099         double dyf = mid[7] - mid[5];
1100 
1101         boolean p1eqp2 = (dxs == 0.0d &amp;&amp; dys == 0.0d);
1102         boolean p3eqp4 = (dxf == 0.0d &amp;&amp; dyf == 0.0d);
1103         if (p1eqp2) {
1104             dxs = mid[4] - mid[0];
1105             dys = mid[5] - mid[1];
1106             if (dxs == 0.0d &amp;&amp; dys == 0.0d) {
1107                 dxs = mid[6] - mid[0];
1108                 dys = mid[7] - mid[1];
1109             }
1110         }
1111         if (p3eqp4) {
1112             dxf = mid[6] - mid[2];
1113             dyf = mid[7] - mid[3];
1114             if (dxf == 0.0d &amp;&amp; dyf == 0.0d) {
1115                 dxf = mid[6] - mid[0];
1116                 dyf = mid[7] - mid[1];
1117             }
1118         }
1119         if (dxs == 0.0d &amp;&amp; dys == 0.0d) {
1120             // this happens if the "curve" is just a point
<span class="new">1121             // fix outcode0 for lineTo() call:</span>
<span class="new">1122             if (clipRect != null) {</span>
<span class="new">1123                 this.cOutCode = outcode0;</span>
<span class="new">1124             }</span>
1125             lineTo(mid[0], mid[1]);
1126             return;
1127         }
1128 
1129         // if these vectors are too small, normalize them, to avoid future
1130         // precision problems.
1131         if (Math.abs(dxs) &lt; 0.1d &amp;&amp; Math.abs(dys) &lt; 0.1d) {
1132             double len = Math.sqrt(dxs*dxs + dys*dys);
1133             dxs /= len;
1134             dys /= len;
1135         }
1136         if (Math.abs(dxf) &lt; 0.1d &amp;&amp; Math.abs(dyf) &lt; 0.1d) {
1137             double len = Math.sqrt(dxf*dxf + dyf*dyf);
1138             dxf /= len;
1139             dyf /= len;
1140         }
1141 
1142         computeOffset(dxs, dys, lineWidth2, offset0);
<span class="changed">1143         drawJoin(cdx, cdy, cx0, cy0, dxs, dys, cmx, cmy, offset0[0], offset0[1], outcode0);</span>
1144 
1145         final int nSplits = findSubdivPoints(curve, mid, subdivTs, 8, lineWidth2);
1146 
1147         double prevT = 0.0d;
1148         for (int i = 0, off = 0; i &lt; nSplits; i++, off += 6) {
1149             final double t = subdivTs[i];
1150             DHelpers.subdivideCubicAt((t - prevT) / (1.0d - prevT),
1151                                      mid, off, mid, off, mid, off + 6);
1152             prevT = t;
1153         }
1154 
1155         final double[] l = lp;
1156         final double[] r = rp;
1157 
1158         int kind = 0;
1159         for (int i = 0, off = 0; i &lt;= nSplits; i++, off += 6) {
1160             kind = computeOffsetCubic(mid, off, l, r);
1161 
1162             emitLineTo(l[0], l[1]);
1163 
1164             switch(kind) {
1165             case 8:
1166                 emitCurveTo(l[2], l[3], l[4], l[5], l[6], l[7]);
1167                 emitCurveToRev(r[0], r[1], r[2], r[3], r[4], r[5]);
1168                 break;
1169             case 4:
1170                 emitLineTo(l[2], l[3]);
1171                 emitLineToRev(r[0], r[1]);
1172                 break;
1173             default:
1174             }
1175             emitLineToRev(r[kind - 2], r[kind - 1]);
1176         }
1177 
<span class="changed">1178         this.prev = DRAWING_OP_TO;</span>



1179         this.cx0 = xf;
1180         this.cy0 = yf;
<span class="changed">1181         this.cdx = dxf;</span>
<span class="changed">1182         this.cdy = dyf;</span>
<span class="changed">1183         this.cmx = (l[kind - 2] - r[kind - 2]) / 2.0d;</span>
<span class="changed">1184         this.cmy = (l[kind - 1] - r[kind - 1]) / 2.0d;</span>
<span class="changed">1185     }</span>
<span class="changed">1186 </span>
<span class="changed">1187     @Override</span>
<span class="changed">1188     public void quadTo(final double x1, final double y1,</span>
<span class="changed">1189                        final double x2, final double y2)</span>
<span class="changed">1190     {</span>
<span class="changed">1191         final int outcode0 = this.cOutCode;</span>
<span class="changed">1192         if (clipRect != null) {</span>
<span class="changed">1193             final int outcode2 = DHelpers.outcode(x2, y2, clipRect);</span>
<span class="changed">1194             this.cOutCode = outcode2;</span>
<span class="changed">1195 </span>
<span class="changed">1196             if ((outcode0 &amp; outcode2) != 0) {</span>
<span class="changed">1197                 final int outcode1 = DHelpers.outcode(x1, y1, clipRect);</span>
<span class="changed">1198 </span>
<span class="changed">1199                 // basic rejection criteria</span>
<span class="changed">1200                 if ((outcode0 &amp; outcode1 &amp; outcode2) != 0) {</span>
<span class="changed">1201                     moveTo(x2, y2, outcode0);</span>
<span class="changed">1202                     opened = true;</span>
<span class="changed">1203                     return;</span>
<span class="changed">1204                 }</span>
<span class="changed">1205             }</span>
1206         }
1207 

1208         final double[] mid = middle;
1209 
1210         mid[0] = cx0; mid[1] = cy0;
1211         mid[2] = x1;  mid[3] = y1;
1212         mid[4] = x2;  mid[5] = y2;
1213 
1214         // need these so we can update the state at the end of this method
<span class="changed">1215         final double xf = x2, yf = y2;</span>
1216         double dxs = mid[2] - mid[0];
1217         double dys = mid[3] - mid[1];
1218         double dxf = mid[4] - mid[2];
1219         double dyf = mid[5] - mid[3];
1220         if ((dxs == 0.0d &amp;&amp; dys == 0.0d) || (dxf == 0.0d &amp;&amp; dyf == 0.0d)) {
1221             dxs = dxf = mid[4] - mid[0];
1222             dys = dyf = mid[5] - mid[1];
1223         }
1224         if (dxs == 0.0d &amp;&amp; dys == 0.0d) {
1225             // this happens if the "curve" is just a point
<span class="new">1226             // fix outcode0 for lineTo() call:</span>
<span class="new">1227             if (clipRect != null) {</span>
<span class="new">1228                 this.cOutCode = outcode0;</span>
<span class="new">1229             }</span>
1230             lineTo(mid[0], mid[1]);
1231             return;
1232         }
1233         // if these vectors are too small, normalize them, to avoid future
1234         // precision problems.
1235         if (Math.abs(dxs) &lt; 0.1d &amp;&amp; Math.abs(dys) &lt; 0.1d) {
1236             double len = Math.sqrt(dxs*dxs + dys*dys);
1237             dxs /= len;
1238             dys /= len;
1239         }
1240         if (Math.abs(dxf) &lt; 0.1d &amp;&amp; Math.abs(dyf) &lt; 0.1d) {
1241             double len = Math.sqrt(dxf*dxf + dyf*dyf);
1242             dxf /= len;
1243             dyf /= len;
1244         }
1245 
1246         computeOffset(dxs, dys, lineWidth2, offset0);
<span class="changed">1247         drawJoin(cdx, cdy, cx0, cy0, dxs, dys, cmx, cmy, offset0[0], offset0[1], outcode0);</span>
1248 
1249         int nSplits = findSubdivPoints(curve, mid, subdivTs, 6, lineWidth2);
1250 
1251         double prevt = 0.0d;
1252         for (int i = 0, off = 0; i &lt; nSplits; i++, off += 4) {
1253             final double t = subdivTs[i];
1254             DHelpers.subdivideQuadAt((t - prevt) / (1.0d - prevt),
1255                                     mid, off, mid, off, mid, off + 4);
1256             prevt = t;
1257         }
1258 
1259         final double[] l = lp;
1260         final double[] r = rp;
1261 
1262         int kind = 0;
1263         for (int i = 0, off = 0; i &lt;= nSplits; i++, off += 4) {
1264             kind = computeOffsetQuad(mid, off, l, r);
1265 
1266             emitLineTo(l[0], l[1]);
1267 
1268             switch(kind) {
1269             case 6:
1270                 emitQuadTo(l[2], l[3], l[4], l[5]);
1271                 emitQuadToRev(r[0], r[1], r[2], r[3]);
1272                 break;
1273             case 4:
1274                 emitLineTo(l[2], l[3]);
1275                 emitLineToRev(r[0], r[1]);
1276                 break;
1277             default:
1278             }
1279             emitLineToRev(r[kind - 2], r[kind - 1]);
1280         }
1281 
<span class="changed">1282         this.prev = DRAWING_OP_TO;</span>



1283         this.cx0 = xf;
1284         this.cy0 = yf;
<span class="changed">1285         this.cdx = dxf;</span>
<span class="changed">1286         this.cdy = dyf;</span>
<span class="changed">1287         this.cmx = (l[kind - 2] - r[kind - 2]) / 2.0d;</span>
<span class="changed">1288         this.cmy = (l[kind - 1] - r[kind - 1]) / 2.0d;</span>
1289     }
1290 
1291     @Override public long getNativeConsumer() {
1292         throw new InternalError("Stroker doesn't use a native consumer");
1293     }






































































































































































































1294 }
</pre></td>
</tr></table>
<center><a href='../../../../../../src/share/classes/sun/java2d/marlin/DRendererContext.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../src/share/classes/sun/java2d/marlin/DTransformingPathConsumer2D.java.sdiff.html' target='_top'>next &gt</a></center>
</body></html>
