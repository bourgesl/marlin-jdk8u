<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>jdk Sdiff src/share/classes/sun/java2d/marlin </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../../../src/share/classes/sun/java2d/marlin/RendererStats.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../src/share/classes/sun/java2d/marlin/TransformingPathConsumer2D.java.sdiff.html' target='_top'>next &gt</a></center>
<h2>src/share/classes/sun/java2d/marlin/Stroker.java</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-13694">13694</a> : <a href="https://bugs.openjdk.java.net/browse/JDK-8191814">8191814</a>: Marlin rasterizer spends time computing geometry for stroked segments that do not intersect the clip
Summary: upgrade to Marlin 0.8.2 providing efficient path clipping (Stroker and Filler)
Reviewed-by: prr, serb</pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.java2d.marlin;
  27 
  28 import java.util.Arrays;
  29 
  30 import sun.awt.geom.PathConsumer2D;

  31 
  32 // TODO: some of the arithmetic here is too verbose and prone to hard to
  33 // debug typos. We should consider making a small Point/Vector class that
  34 // has methods like plus(Point), minus(Point), dot(Point), cross(Point)and such
  35 final class Stroker implements PathConsumer2D, MarlinConst {
  36 
  37     private static final int MOVE_TO = 0;
  38     private static final int DRAWING_OP_TO = 1; // ie. curve, line, or quad
  39     private static final int CLOSE = 2;
  40 
<span class="removed">  41     /**</span>
<span class="removed">  42      * Constant value for join style.</span>
<span class="removed">  43      */</span>
<span class="removed">  44     public static final int JOIN_MITER = 0;</span>
<span class="removed">  45 </span>
<span class="removed">  46     /**</span>
<span class="removed">  47      * Constant value for join style.</span>
<span class="removed">  48      */</span>
<span class="removed">  49     public static final int JOIN_ROUND = 1;</span>
<span class="removed">  50 </span>
<span class="removed">  51     /**</span>
<span class="removed">  52      * Constant value for join style.</span>
<span class="removed">  53      */</span>
<span class="removed">  54     public static final int JOIN_BEVEL = 2;</span>
<span class="removed">  55 </span>
<span class="removed">  56     /**</span>
<span class="removed">  57      * Constant value for end cap style.</span>
<span class="removed">  58      */</span>
<span class="removed">  59     public static final int CAP_BUTT = 0;</span>
<span class="removed">  60 </span>
<span class="removed">  61     /**</span>
<span class="removed">  62      * Constant value for end cap style.</span>
<span class="removed">  63      */</span>
<span class="removed">  64     public static final int CAP_ROUND = 1;</span>
<span class="removed">  65 </span>
<span class="removed">  66     /**</span>
<span class="removed">  67      * Constant value for end cap style.</span>
<span class="removed">  68      */</span>
<span class="removed">  69     public static final int CAP_SQUARE = 2;</span>
<span class="removed">  70 </span>
  71     // pisces used to use fixed point arithmetic with 16 decimal digits. I
  72     // didn't want to change the values of the constant below when I converted
  73     // it to floating point, so that's why the divisions by 2^16 are there.
  74     private static final float ROUND_JOIN_THRESHOLD = 1000.0f/65536.0f;
  75 
<span class="changed">  76     private static final float C = 0.5522847498307933f;</span>




  77 
  78     private static final int MAX_N_CURVES = 11;
  79 
  80     private PathConsumer2D out;
  81 
  82     private int capStyle;
  83     private int joinStyle;
  84 
  85     private float lineWidth2;
  86     private float invHalfLineWidth2Sq;
  87 
  88     private final float[] offset0 = new float[2];
  89     private final float[] offset1 = new float[2];
  90     private final float[] offset2 = new float[2];
  91     private final float[] miter = new float[2];
  92     private float miterLimitSq;
  93 
  94     private int prev;
  95 
  96     // The starting point of the path, and the slope there.

</pre><hr></hr><pre>
 103     // original path (thought they may have different directions), so these
 104     // could be computed from sdx,sdy and cdx,cdy (and vice versa), but that
 105     // would be error prone and hard to read, so we keep these anyway.
 106     private float smx, smy, cmx, cmy;
 107 
 108     private final PolyStack reverse;
 109 
 110     // This is where the curve to be processed is put. We give it
 111     // enough room to store all curves.
 112     private final float[] middle = new float[MAX_N_CURVES * 6 + 2];
 113     private final float[] lp = new float[8];
 114     private final float[] rp = new float[8];
 115     private final float[] subdivTs = new float[MAX_N_CURVES - 1];
 116 
 117     // per-thread renderer context
 118     final RendererContext rdrCtx;
 119 
 120     // dirty curve
 121     final Curve curve;
 122 














 123     /**
 124      * Constructs a &lt;code&gt;Stroker&lt;/code&gt;.
 125      * @param rdrCtx per-thread renderer context
 126      */
 127     Stroker(final RendererContext rdrCtx) {
 128         this.rdrCtx = rdrCtx;
 129 
<span class="changed"> 130         this.reverse = new PolyStack(rdrCtx);</span>








 131         this.curve = rdrCtx.curve;
 132     }
 133 
 134     /**
 135      * Inits the &lt;code&gt;Stroker&lt;/code&gt;.
 136      *
 137      * @param pc2d an output &lt;code&gt;PathConsumer2D&lt;/code&gt;.
 138      * @param lineWidth the desired line width in pixels
 139      * @param capStyle the desired end cap style, one of
 140      * &lt;code&gt;CAP_BUTT&lt;/code&gt;, &lt;code&gt;CAP_ROUND&lt;/code&gt; or
 141      * &lt;code&gt;CAP_SQUARE&lt;/code&gt;.
 142      * @param joinStyle the desired line join style, one of
 143      * &lt;code&gt;JOIN_MITER&lt;/code&gt;, &lt;code&gt;JOIN_ROUND&lt;/code&gt; or
 144      * &lt;code&gt;JOIN_BEVEL&lt;/code&gt;.
 145      * @param miterLimit the desired miter limit

 146      * @return this instance
 147      */
<span class="changed"> 148     Stroker init(PathConsumer2D pc2d,</span>
<span class="changed"> 149               float lineWidth,</span>
<span class="changed"> 150               int capStyle,</span>
<span class="changed"> 151               int joinStyle,</span>
<span class="changed"> 152               float miterLimit)</span>

 153     {
 154         this.out = pc2d;
 155 
 156         this.lineWidth2 = lineWidth / 2.0f;
 157         this.invHalfLineWidth2Sq = 1.0f / (2.0f * lineWidth2 * lineWidth2);
 158         this.capStyle = capStyle;
 159         this.joinStyle = joinStyle;
 160 
<span class="changed"> 161         float limit = miterLimit * lineWidth2;</span>
 162         this.miterLimitSq = limit * limit;
 163 
 164         this.prev = CLOSE;
 165 
 166         rdrCtx.stroking = 1;
 167 
































 168         return this; // fluent API
 169     }
 170 
 171     /**
 172      * Disposes this stroker:
 173      * clean up before reusing this instance
 174      */
 175     void dispose() {
 176         reverse.dispose();
 177 



 178         if (DO_CLEAN_DIRTY) {
 179             // Force zero-fill dirty arrays:
 180             Arrays.fill(offset0, 0.0f);
 181             Arrays.fill(offset1, 0.0f);
 182             Arrays.fill(offset2, 0.0f);
 183             Arrays.fill(miter, 0.0f);
 184             Arrays.fill(middle, 0.0f);
 185             Arrays.fill(lp, 0.0f);
 186             Arrays.fill(rp, 0.0f);
 187             Arrays.fill(subdivTs, 0.0f);
 188         }
 189     }
 190 
 191     private static void computeOffset(final float lx, final float ly,
 192                                       final float w, final float[] m)
 193     {
 194         float len = lx*lx + ly*ly;
 195         if (len == 0.0f) {
 196             m[0] = 0.0f;
 197             m[1] = 0.0f;

</pre><hr></hr><pre>
 428 
 429         computeMiter((x0 - pdx) + omx, (y0 - pdy) + omy, x0 + omx, y0 + omy,
 430                      (dx + x0) + mx, (dy + y0) + my, x0 + mx, y0 + my,
 431                      miter, 0);
 432 
 433         final float miterX = miter[0];
 434         final float miterY = miter[1];
 435         float lenSq = (miterX-x0)*(miterX-x0) + (miterY-y0)*(miterY-y0);
 436 
 437         // If the lines are parallel, lenSq will be either NaN or +inf
 438         // (actually, I'm not sure if the latter is possible. The important
 439         // thing is that -inf is not possible, because lenSq is a square).
 440         // For both of those values, the comparison below will fail and
 441         // no miter will be drawn, which is correct.
 442         if (lenSq &lt; miterLimitSq) {
 443             emitLineTo(miterX, miterY, rev);
 444         }
 445     }
 446 
 447     @Override
<span class="changed"> 448     public void moveTo(float x0, float y0) {</span>























 449         if (prev == DRAWING_OP_TO) {
<span class="changed"> 450             finish();</span>
 451         }
<span class="removed"> 452         this.sx0 = this.cx0 = x0;</span>
<span class="removed"> 453         this.sy0 = this.cy0 = y0;</span>
<span class="removed"> 454         this.cdx = this.sdx = 1.0f;</span>
<span class="removed"> 455         this.cdy = this.sdy = 0.0f;</span>
 456         this.prev = MOVE_TO;





 457     }
 458 
 459     @Override
<span class="changed"> 460     public void lineTo(float x1, float y1) {</span>



















 461         float dx = x1 - cx0;
 462         float dy = y1 - cy0;
 463         if (dx == 0.0f &amp;&amp; dy == 0.0f) {
 464             dx = 1.0f;
 465         }
 466         computeOffset(dx, dy, lineWidth2, offset0);
 467         final float mx = offset0[0];
 468         final float my = offset0[1];
 469 
<span class="changed"> 470         drawJoin(cdx, cdy, cx0, cy0, dx, dy, cmx, cmy, mx, my);</span>
 471 
 472         emitLineTo(cx0 + mx, cy0 + my);
 473         emitLineTo( x1 + mx,  y1 + my);
 474 
 475         emitLineToRev(cx0 - mx, cy0 - my);
 476         emitLineToRev( x1 - mx,  y1 - my);
 477 
<span class="changed"> 478         this.cmx = mx;</span>
<span class="changed"> 479         this.cmy = my;</span>
<span class="changed"> 480         this.cdx = dx;</span>
<span class="changed"> 481         this.cdy = dy;</span>
 482         this.cx0 = x1;
 483         this.cy0 = y1;
<span class="changed"> 484         this.prev = DRAWING_OP_TO;</span>



 485     }
 486 
 487     @Override
 488     public void closePath() {
<span class="changed"> 489         if (prev != DRAWING_OP_TO) {</span>

 490             if (prev == CLOSE) {
 491                 return;
 492             }
 493             emitMoveTo(cx0, cy0 - lineWidth2);
<span class="changed"> 494             this.cmx = this.smx = 0.0f;</span>
<span class="changed"> 495             this.cmy = this.smy = -lineWidth2;</span>
<span class="changed"> 496             this.cdx = this.sdx = 1.0f;</span>
<span class="changed"> 497             this.cdy = this.sdy = 0.0f;</span>
<span class="changed"> 498             finish();</span>







 499             return;
 500         }
 501 


 502         if (cx0 != sx0 || cy0 != sy0) {
<span class="changed"> 503             lineTo(sx0, sy0);</span>
 504         }
 505 
<span class="changed"> 506         drawJoin(cdx, cdy, cx0, cy0, sdx, sdy, cmx, cmy, smx, smy);</span>
 507 
 508         emitLineTo(sx0 + smx, sy0 + smy);
 509 



 510         emitMoveTo(sx0 - smx, sy0 - smy);



 511         emitReverse();
 512 
 513         this.prev = CLOSE;





 514         emitClose();
 515     }

 516 
 517     private void emitReverse() {
 518         reverse.popAll(out);
 519     }
 520 
 521     @Override
 522     public void pathDone() {
 523         if (prev == DRAWING_OP_TO) {
<span class="changed"> 524             finish();</span>
 525         }
 526 
 527         out.pathDone();
 528 
 529         // this shouldn't matter since this object won't be used
 530         // after the call to this method.
 531         this.prev = CLOSE;
 532 
 533         // Dispose this instance:
 534         dispose();
 535     }
 536 
<span class="changed"> 537     private void finish() {</span>







 538         if (capStyle == CAP_ROUND) {
 539             drawRoundCap(cx0, cy0, cmx, cmy);
 540         } else if (capStyle == CAP_SQUARE) {
 541             emitLineTo(cx0 - cmy + cmx, cy0 + cmx + cmy);
 542             emitLineTo(cx0 - cmy - cmx, cy0 + cmx - cmy);
 543         }
<span class="changed"> 544 </span>
 545         emitReverse();
 546 





 547         if (capStyle == CAP_ROUND) {
 548             drawRoundCap(sx0, sy0, -smx, -smy);
 549         } else if (capStyle == CAP_SQUARE) {
 550             emitLineTo(sx0 + smy - smx, sy0 - smx - smy);
 551             emitLineTo(sx0 + smy + smx, sy0 - smx + smy);
 552         }
<span class="changed"> 553 </span>




 554         emitClose();
 555     }
 556 
 557     private void emitMoveTo(final float x0, final float y0) {
 558         out.moveTo(x0, y0);
 559     }
 560 
 561     private void emitLineTo(final float x1, final float y1) {
 562         out.lineTo(x1, y1);
 563     }
 564 
 565     private void emitLineToRev(final float x1, final float y1) {
 566         reverse.pushLine(x1, y1);
 567     }
 568 
 569     private void emitLineTo(final float x1, final float y1,
 570                             final boolean rev)
 571     {
 572         if (rev) {
 573             emitLineToRev(x1, y1);

</pre><hr></hr><pre>
 605     private void emitCurveTo(final float x0, final float y0,
 606                              final float x1, final float y1,
 607                              final float x2, final float y2,
 608                              final float x3, final float y3, final boolean rev)
 609     {
 610         if (rev) {
 611             reverse.pushCubic(x0, y0, x1, y1, x2, y2);
 612         } else {
 613             out.curveTo(x1, y1, x2, y2, x3, y3);
 614         }
 615     }
 616 
 617     private void emitClose() {
 618         out.closePath();
 619     }
 620 
 621     private void drawJoin(float pdx, float pdy,
 622                           float x0, float y0,
 623                           float dx, float dy,
 624                           float omx, float omy,
<span class="changed"> 625                           float mx, float my)</span>

 626     {
 627         if (prev != DRAWING_OP_TO) {
 628             emitMoveTo(x0 + mx, y0 + my);

 629             this.sdx = dx;
 630             this.sdy = dy;
 631             this.smx = mx;
 632             this.smy = my;

 633         } else {
<span class="changed"> 634             boolean cw = isCW(pdx, pdy, dx, dy);</span>

 635             if (joinStyle == JOIN_MITER) {
 636                 drawMiter(pdx, pdy, x0, y0, dx, dy, omx, omy, mx, my, cw);
 637             } else if (joinStyle == JOIN_ROUND) {
 638                 drawRoundJoin(x0, y0,
 639                               omx, omy,
 640                               mx, my, cw,
 641                               ROUND_JOIN_THRESHOLD);
 642             }

 643             emitLineTo(x0, y0, !cw);
 644         }
 645         prev = DRAWING_OP_TO;
 646     }
 647 
 648     private static boolean within(final float x1, final float y1,
 649                                   final float x2, final float y2,
 650                                   final float ERR)
 651     {
 652         assert ERR &gt; 0 : "";
 653         // compare taxicab distance. ERR will always be small, so using
 654         // true distance won't give much benefit
 655         return (Helpers.within(x1, x2, ERR) &amp;&amp;  // we want to avoid calling Math.abs
 656                 Helpers.within(y1, y2, ERR)); // this is just as good.
 657     }
 658 
 659     private void getLineOffsets(float x1, float y1,
 660                                 float x2, float y2,
 661                                 float[] left, float[] right) {
 662         computeOffset(x2 - x1, y2 - y1, lineWidth2, offset0);

</pre><hr></hr><pre>
 926         int ret = 0;
 927         // we subdivide at values of t such that the remaining rotated
 928         // curves are monotonic in x and y.
 929         ret += c.dxRoots(ts, ret);
 930         ret += c.dyRoots(ts, ret);
 931         // subdivide at inflection points.
 932         if (type == 8) {
 933             // quadratic curves can't have inflection points
 934             ret += c.infPoints(ts, ret);
 935         }
 936 
 937         // now we must subdivide at points where one of the offset curves will have
 938         // a cusp. This happens at ts where the radius of curvature is equal to w.
 939         ret += c.rootsOfROCMinusW(ts, ret, w, 0.0001f);
 940 
 941         ret = Helpers.filterOutNotInAB(ts, 0, ret, 0.0001f, 0.9999f);
 942         Helpers.isort(ts, 0, ret);
 943         return ret;
 944     }
 945 
<span class="changed"> 946     @Override public void curveTo(float x1, float y1,</span>
<span class="changed"> 947                                   float x2, float y2,</span>
<span class="changed"> 948                                   float x3, float y3)</span>

 949     {


















 950         final float[] mid = middle;
 951 
 952         mid[0] = cx0; mid[1] = cy0;
 953         mid[2] = x1;  mid[3] = y1;
 954         mid[4] = x2;  mid[5] = y2;
 955         mid[6] = x3;  mid[7] = y3;
 956 
 957         // need these so we can update the state at the end of this method
<span class="changed"> 958         final float xf = mid[6], yf = mid[7];</span>
 959         float dxs = mid[2] - mid[0];
 960         float dys = mid[3] - mid[1];
 961         float dxf = mid[6] - mid[4];
 962         float dyf = mid[7] - mid[5];
 963 
 964         boolean p1eqp2 = (dxs == 0.0f &amp;&amp; dys == 0.0f);
 965         boolean p3eqp4 = (dxf == 0.0f &amp;&amp; dyf == 0.0f);
 966         if (p1eqp2) {
 967             dxs = mid[4] - mid[0];
 968             dys = mid[5] - mid[1];
 969             if (dxs == 0.0f &amp;&amp; dys == 0.0f) {
 970                 dxs = mid[6] - mid[0];
 971                 dys = mid[7] - mid[1];
 972             }
 973         }
 974         if (p3eqp4) {
 975             dxf = mid[6] - mid[2];
 976             dyf = mid[7] - mid[3];
 977             if (dxf == 0.0f &amp;&amp; dyf == 0.0f) {
 978                 dxf = mid[6] - mid[0];
 979                 dyf = mid[7] - mid[1];
 980             }
 981         }
 982         if (dxs == 0.0f &amp;&amp; dys == 0.0f) {
 983             // this happens if the "curve" is just a point




 984             lineTo(mid[0], mid[1]);
 985             return;
 986         }
 987 
 988         // if these vectors are too small, normalize them, to avoid future
 989         // precision problems.
 990         if (Math.abs(dxs) &lt; 0.1f &amp;&amp; Math.abs(dys) &lt; 0.1f) {
 991             float len = (float) Math.sqrt(dxs*dxs + dys*dys);
 992             dxs /= len;
 993             dys /= len;
 994         }
 995         if (Math.abs(dxf) &lt; 0.1f &amp;&amp; Math.abs(dyf) &lt; 0.1f) {
 996             float len = (float) Math.sqrt(dxf*dxf + dyf*dyf);
 997             dxf /= len;
 998             dyf /= len;
 999         }
1000 
1001         computeOffset(dxs, dys, lineWidth2, offset0);
<span class="changed">1002         drawJoin(cdx, cdy, cx0, cy0, dxs, dys, cmx, cmy, offset0[0], offset0[1]);</span>
1003 
1004         final int nSplits = findSubdivPoints(curve, mid, subdivTs, 8, lineWidth2);
1005 
1006         float prevT = 0.0f;
1007         for (int i = 0, off = 0; i &lt; nSplits; i++, off += 6) {
1008             final float t = subdivTs[i];
1009             Helpers.subdivideCubicAt((t - prevT) / (1.0f - prevT),
1010                                      mid, off, mid, off, mid, off + 6);
1011             prevT = t;
1012         }
1013 
1014         final float[] l = lp;
1015         final float[] r = rp;
1016 
1017         int kind = 0;
1018         for (int i = 0, off = 0; i &lt;= nSplits; i++, off += 6) {
1019             kind = computeOffsetCubic(mid, off, l, r);
1020 
1021             emitLineTo(l[0], l[1]);
1022 
1023             switch(kind) {
1024             case 8:
1025                 emitCurveTo(l[2], l[3], l[4], l[5], l[6], l[7]);
1026                 emitCurveToRev(r[0], r[1], r[2], r[3], r[4], r[5]);
1027                 break;
1028             case 4:
1029                 emitLineTo(l[2], l[3]);
1030                 emitLineToRev(r[0], r[1]);
1031                 break;
1032             default:
1033             }
1034             emitLineToRev(r[kind - 2], r[kind - 1]);
1035         }
1036 
<span class="changed">1037         this.cmx = (l[kind - 2] - r[kind - 2]) / 2.0f;</span>
<span class="changed">1038         this.cmy = (l[kind - 1] - r[kind - 1]) / 2.0f;</span>
<span class="changed">1039         this.cdx = dxf;</span>
<span class="changed">1040         this.cdy = dyf;</span>
1041         this.cx0 = xf;
1042         this.cy0 = yf;
<span class="changed">1043         this.prev = DRAWING_OP_TO;</span>
























1044     }
1045 
<span class="removed">1046     @Override public void quadTo(float x1, float y1, float x2, float y2) {</span>
1047         final float[] mid = middle;
1048 
1049         mid[0] = cx0; mid[1] = cy0;
1050         mid[2] = x1;  mid[3] = y1;
1051         mid[4] = x2;  mid[5] = y2;
1052 
1053         // need these so we can update the state at the end of this method
<span class="changed">1054         final float xf = mid[4], yf = mid[5];</span>
1055         float dxs = mid[2] - mid[0];
1056         float dys = mid[3] - mid[1];
1057         float dxf = mid[4] - mid[2];
1058         float dyf = mid[5] - mid[3];
1059         if ((dxs == 0.0f &amp;&amp; dys == 0.0f) || (dxf == 0.0f &amp;&amp; dyf == 0.0f)) {
1060             dxs = dxf = mid[4] - mid[0];
1061             dys = dyf = mid[5] - mid[1];
1062         }
1063         if (dxs == 0.0f &amp;&amp; dys == 0.0f) {
1064             // this happens if the "curve" is just a point




1065             lineTo(mid[0], mid[1]);
1066             return;
1067         }
1068         // if these vectors are too small, normalize them, to avoid future
1069         // precision problems.
1070         if (Math.abs(dxs) &lt; 0.1f &amp;&amp; Math.abs(dys) &lt; 0.1f) {
1071             float len = (float) Math.sqrt(dxs*dxs + dys*dys);
1072             dxs /= len;
1073             dys /= len;
1074         }
1075         if (Math.abs(dxf) &lt; 0.1f &amp;&amp; Math.abs(dyf) &lt; 0.1f) {
1076             float len = (float) Math.sqrt(dxf*dxf + dyf*dyf);
1077             dxf /= len;
1078             dyf /= len;
1079         }
1080 
1081         computeOffset(dxs, dys, lineWidth2, offset0);
<span class="changed">1082         drawJoin(cdx, cdy, cx0, cy0, dxs, dys, cmx, cmy, offset0[0], offset0[1]);</span>
1083 
1084         int nSplits = findSubdivPoints(curve, mid, subdivTs, 6, lineWidth2);
1085 
1086         float prevt = 0.0f;
1087         for (int i = 0, off = 0; i &lt; nSplits; i++, off += 4) {
1088             final float t = subdivTs[i];
1089             Helpers.subdivideQuadAt((t - prevt) / (1.0f - prevt),
1090                                     mid, off, mid, off, mid, off + 4);
1091             prevt = t;
1092         }
1093 
1094         final float[] l = lp;
1095         final float[] r = rp;
1096 
1097         int kind = 0;
1098         for (int i = 0, off = 0; i &lt;= nSplits; i++, off += 4) {
1099             kind = computeOffsetQuad(mid, off, l, r);
1100 
1101             emitLineTo(l[0], l[1]);
1102 
1103             switch(kind) {
1104             case 6:
1105                 emitQuadTo(l[2], l[3], l[4], l[5]);
1106                 emitQuadToRev(r[0], r[1], r[2], r[3]);
1107                 break;
1108             case 4:
1109                 emitLineTo(l[2], l[3]);
1110                 emitLineToRev(r[0], r[1]);
1111                 break;
1112             default:
1113             }
1114             emitLineToRev(r[kind - 2], r[kind - 1]);
1115         }
1116 
<span class="changed">1117         this.cmx = (l[kind - 2] - r[kind - 2]) / 2.0f;</span>
<span class="changed">1118         this.cmy = (l[kind - 1] - r[kind - 1]) / 2.0f;</span>
<span class="changed">1119         this.cdx = dxf;</span>
<span class="changed">1120         this.cdy = dyf;</span>
1121         this.cx0 = xf;
1122         this.cy0 = yf;
<span class="changed">1123         this.prev = DRAWING_OP_TO;</span>



1124     }
1125 
1126     @Override public long getNativeConsumer() {
1127         throw new InternalError("Stroker doesn't use a native consumer");
1128     }
<span class="removed">1129 </span>
<span class="removed">1130     // a stack of polynomial curves where each curve shares endpoints with</span>
<span class="removed">1131     // adjacent ones.</span>
<span class="removed">1132     static final class PolyStack {</span>
<span class="removed">1133         private static final byte TYPE_LINETO  = (byte) 0;</span>
<span class="removed">1134         private static final byte TYPE_QUADTO  = (byte) 1;</span>
<span class="removed">1135         private static final byte TYPE_CUBICTO = (byte) 2;</span>
<span class="removed">1136 </span>
<span class="removed">1137         // curves capacity = edges count (8192) = edges x 2 (coords)</span>
<span class="removed">1138         private static final int INITIAL_CURVES_COUNT = INITIAL_EDGES_COUNT &lt;&lt; 1;</span>
<span class="removed">1139 </span>
<span class="removed">1140         // types capacity = edges count (4096)</span>
<span class="removed">1141         private static final int INITIAL_TYPES_COUNT = INITIAL_EDGES_COUNT;</span>
<span class="removed">1142 </span>
<span class="removed">1143         float[] curves;</span>
<span class="removed">1144         int end;</span>
<span class="removed">1145         byte[] curveTypes;</span>
<span class="removed">1146         int numCurves;</span>
<span class="removed">1147 </span>
<span class="removed">1148         // per-thread renderer context</span>
<span class="removed">1149         final RendererContext rdrCtx;</span>
<span class="removed">1150 </span>
<span class="removed">1151         // curves ref (dirty)</span>
<span class="removed">1152         final FloatArrayCache.Reference curves_ref;</span>
<span class="removed">1153         // curveTypes ref (dirty)</span>
<span class="removed">1154         final ByteArrayCache.Reference curveTypes_ref;</span>
<span class="removed">1155 </span>
<span class="removed">1156         // used marks (stats only)</span>
<span class="removed">1157         int curveTypesUseMark;</span>
<span class="removed">1158         int curvesUseMark;</span>
<span class="removed">1159 </span>
<span class="removed">1160         /**</span>
<span class="removed">1161          * Constructor</span>
<span class="removed">1162          * @param rdrCtx per-thread renderer context</span>
<span class="removed">1163          */</span>
<span class="removed">1164         PolyStack(final RendererContext rdrCtx) {</span>
<span class="removed">1165             this.rdrCtx = rdrCtx;</span>
<span class="removed">1166 </span>
<span class="removed">1167             curves_ref = rdrCtx.newDirtyFloatArrayRef(INITIAL_CURVES_COUNT); // 32K</span>
<span class="removed">1168             curves     = curves_ref.initial;</span>
<span class="removed">1169 </span>
<span class="removed">1170             curveTypes_ref = rdrCtx.newDirtyByteArrayRef(INITIAL_TYPES_COUNT); // 4K</span>
<span class="removed">1171             curveTypes     = curveTypes_ref.initial;</span>
<span class="removed">1172             numCurves = 0;</span>
<span class="removed">1173             end = 0;</span>
<span class="removed">1174 </span>
<span class="removed">1175             if (DO_STATS) {</span>
<span class="removed">1176                 curveTypesUseMark = 0;</span>
<span class="removed">1177                 curvesUseMark = 0;</span>
<span class="removed">1178             }</span>
<span class="removed">1179         }</span>
<span class="removed">1180 </span>
<span class="removed">1181         /**</span>
<span class="removed">1182          * Disposes this PolyStack:</span>
<span class="removed">1183          * clean up before reusing this instance</span>
<span class="removed">1184          */</span>
<span class="removed">1185         void dispose() {</span>
<span class="removed">1186             end = 0;</span>
<span class="removed">1187             numCurves = 0;</span>
<span class="removed">1188 </span>
<span class="removed">1189             if (DO_STATS) {</span>
<span class="removed">1190                 rdrCtx.stats.stat_rdr_poly_stack_types.add(curveTypesUseMark);</span>
<span class="removed">1191                 rdrCtx.stats.stat_rdr_poly_stack_curves.add(curvesUseMark);</span>
<span class="removed">1192                 rdrCtx.stats.hist_rdr_poly_stack_curves.add(curvesUseMark);</span>
<span class="removed">1193 </span>
<span class="removed">1194                 // reset marks</span>
<span class="removed">1195                 curveTypesUseMark = 0;</span>
<span class="removed">1196                 curvesUseMark = 0;</span>
<span class="removed">1197             }</span>
<span class="removed">1198 </span>
<span class="removed">1199             // Return arrays:</span>
<span class="removed">1200             // curves and curveTypes are kept dirty</span>
<span class="removed">1201             curves     = curves_ref.putArray(curves);</span>
<span class="removed">1202             curveTypes = curveTypes_ref.putArray(curveTypes);</span>
<span class="removed">1203         }</span>
<span class="removed">1204 </span>
<span class="removed">1205         private void ensureSpace(final int n) {</span>
<span class="removed">1206             // use substraction to avoid integer overflow:</span>
<span class="removed">1207             if (curves.length - end &lt; n) {</span>
<span class="removed">1208                 if (DO_STATS) {</span>
<span class="removed">1209                     rdrCtx.stats.stat_array_stroker_polystack_curves</span>
<span class="removed">1210                         .add(end + n);</span>
<span class="removed">1211                 }</span>
<span class="removed">1212                 curves = curves_ref.widenArray(curves, end, end + n);</span>
<span class="removed">1213             }</span>
<span class="removed">1214             if (curveTypes.length &lt;= numCurves) {</span>
<span class="removed">1215                 if (DO_STATS) {</span>
<span class="removed">1216                     rdrCtx.stats.stat_array_stroker_polystack_curveTypes</span>
<span class="removed">1217                         .add(numCurves + 1);</span>
<span class="removed">1218                 }</span>
<span class="removed">1219                 curveTypes = curveTypes_ref.widenArray(curveTypes,</span>
<span class="removed">1220                                                        numCurves,</span>
<span class="removed">1221                                                        numCurves + 1);</span>
<span class="removed">1222             }</span>
<span class="removed">1223         }</span>
<span class="removed">1224 </span>
<span class="removed">1225         void pushCubic(float x0, float y0,</span>
<span class="removed">1226                        float x1, float y1,</span>
<span class="removed">1227                        float x2, float y2)</span>
<span class="removed">1228         {</span>
<span class="removed">1229             ensureSpace(6);</span>
<span class="removed">1230             curveTypes[numCurves++] = TYPE_CUBICTO;</span>
<span class="removed">1231             // we reverse the coordinate order to make popping easier</span>
<span class="removed">1232             final float[] _curves = curves;</span>
<span class="removed">1233             int e = end;</span>
<span class="removed">1234             _curves[e++] = x2;    _curves[e++] = y2;</span>
<span class="removed">1235             _curves[e++] = x1;    _curves[e++] = y1;</span>
<span class="removed">1236             _curves[e++] = x0;    _curves[e++] = y0;</span>
<span class="removed">1237             end = e;</span>
<span class="removed">1238         }</span>
<span class="removed">1239 </span>
<span class="removed">1240         void pushQuad(float x0, float y0,</span>
<span class="removed">1241                       float x1, float y1)</span>
<span class="removed">1242         {</span>
<span class="removed">1243             ensureSpace(4);</span>
<span class="removed">1244             curveTypes[numCurves++] = TYPE_QUADTO;</span>
<span class="removed">1245             final float[] _curves = curves;</span>
<span class="removed">1246             int e = end;</span>
<span class="removed">1247             _curves[e++] = x1;    _curves[e++] = y1;</span>
<span class="removed">1248             _curves[e++] = x0;    _curves[e++] = y0;</span>
<span class="removed">1249             end = e;</span>
<span class="removed">1250         }</span>
<span class="removed">1251 </span>
<span class="removed">1252         void pushLine(float x, float y) {</span>
<span class="removed">1253             ensureSpace(2);</span>
<span class="removed">1254             curveTypes[numCurves++] = TYPE_LINETO;</span>
<span class="removed">1255             curves[end++] = x;    curves[end++] = y;</span>
<span class="removed">1256         }</span>
<span class="removed">1257 </span>
<span class="removed">1258         void popAll(PathConsumer2D io) {</span>
<span class="removed">1259             if (DO_STATS) {</span>
<span class="removed">1260                 // update used marks:</span>
<span class="removed">1261                 if (numCurves &gt; curveTypesUseMark) {</span>
<span class="removed">1262                     curveTypesUseMark = numCurves;</span>
<span class="removed">1263                 }</span>
<span class="removed">1264                 if (end &gt; curvesUseMark) {</span>
<span class="removed">1265                     curvesUseMark = end;</span>
<span class="removed">1266                 }</span>
<span class="removed">1267             }</span>
<span class="removed">1268             final byte[]  _curveTypes = curveTypes;</span>
<span class="removed">1269             final float[] _curves = curves;</span>
<span class="removed">1270             int nc = numCurves;</span>
<span class="removed">1271             int e  = end;</span>
<span class="removed">1272 </span>
<span class="removed">1273             while (nc != 0) {</span>
<span class="removed">1274                 switch(_curveTypes[--nc]) {</span>
<span class="removed">1275                 case TYPE_LINETO:</span>
<span class="removed">1276                     e -= 2;</span>
<span class="removed">1277                     io.lineTo(_curves[e], _curves[e+1]);</span>
<span class="removed">1278                     continue;</span>
<span class="removed">1279                 case TYPE_QUADTO:</span>
<span class="removed">1280                     e -= 4;</span>
<span class="removed">1281                     io.quadTo(_curves[e+0], _curves[e+1],</span>
<span class="removed">1282                               _curves[e+2], _curves[e+3]);</span>
<span class="removed">1283                     continue;</span>
<span class="removed">1284                 case TYPE_CUBICTO:</span>
<span class="removed">1285                     e -= 6;</span>
<span class="removed">1286                     io.curveTo(_curves[e+0], _curves[e+1],</span>
<span class="removed">1287                                _curves[e+2], _curves[e+3],</span>
<span class="removed">1288                                _curves[e+4], _curves[e+5]);</span>
<span class="removed">1289                     continue;</span>
<span class="removed">1290                 default:</span>
<span class="removed">1291                 }</span>
<span class="removed">1292             }</span>
<span class="removed">1293             numCurves = 0;</span>
<span class="removed">1294             end = 0;</span>
<span class="removed">1295         }</span>
<span class="removed">1296 </span>
<span class="removed">1297         @Override</span>
<span class="removed">1298         public String toString() {</span>
<span class="removed">1299             String ret = "";</span>
<span class="removed">1300             int nc = numCurves;</span>
<span class="removed">1301             int last = end;</span>
<span class="removed">1302             int len;</span>
<span class="removed">1303             while (nc != 0) {</span>
<span class="removed">1304                 switch(curveTypes[--nc]) {</span>
<span class="removed">1305                 case TYPE_LINETO:</span>
<span class="removed">1306                     len = 2;</span>
<span class="removed">1307                     ret += "line: ";</span>
<span class="removed">1308                     break;</span>
<span class="removed">1309                 case TYPE_QUADTO:</span>
<span class="removed">1310                     len = 4;</span>
<span class="removed">1311                     ret += "quad: ";</span>
<span class="removed">1312                     break;</span>
<span class="removed">1313                 case TYPE_CUBICTO:</span>
<span class="removed">1314                     len = 6;</span>
<span class="removed">1315                     ret += "cubic: ";</span>
<span class="removed">1316                     break;</span>
<span class="removed">1317                 default:</span>
<span class="removed">1318                     len = 0;</span>
<span class="removed">1319                 }</span>
<span class="removed">1320                 last -= len;</span>
<span class="removed">1321                 ret += Arrays.toString(Arrays.copyOfRange(curves, last, last+len))</span>
<span class="removed">1322                                        + "\n";</span>
<span class="removed">1323             }</span>
<span class="removed">1324             return ret;</span>
<span class="removed">1325         }</span>
<span class="removed">1326     }</span>
1327 }
</pre></td><td><pre>

</pre><hr></hr><pre>
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.java2d.marlin;
  27 
  28 import java.util.Arrays;
  29 
  30 import sun.awt.geom.PathConsumer2D;
<span class="new">  31 import sun.java2d.marlin.Helpers.PolyStack;</span>
  32 
  33 // TODO: some of the arithmetic here is too verbose and prone to hard to
  34 // debug typos. We should consider making a small Point/Vector class that
  35 // has methods like plus(Point), minus(Point), dot(Point), cross(Point)and such
  36 final class Stroker implements PathConsumer2D, MarlinConst {
  37 
  38     private static final int MOVE_TO = 0;
  39     private static final int DRAWING_OP_TO = 1; // ie. curve, line, or quad
  40     private static final int CLOSE = 2;
  41 






























  42     // pisces used to use fixed point arithmetic with 16 decimal digits. I
  43     // didn't want to change the values of the constant below when I converted
  44     // it to floating point, so that's why the divisions by 2^16 are there.
  45     private static final float ROUND_JOIN_THRESHOLD = 1000.0f/65536.0f;
  46 
<span class="changed">  47     // kappa = (4/3) * (SQRT(2) - 1)</span>
<span class="changed">  48     private static final float C = (float)(4.0d * (Math.sqrt(2.0d) - 1.0d) / 3.0d);</span>
<span class="changed">  49 </span>
<span class="changed">  50     // SQRT(2)</span>
<span class="changed">  51     private static final float SQRT_2 = (float)Math.sqrt(2.0d);</span>
  52 
  53     private static final int MAX_N_CURVES = 11;
  54 
  55     private PathConsumer2D out;
  56 
  57     private int capStyle;
  58     private int joinStyle;
  59 
  60     private float lineWidth2;
  61     private float invHalfLineWidth2Sq;
  62 
  63     private final float[] offset0 = new float[2];
  64     private final float[] offset1 = new float[2];
  65     private final float[] offset2 = new float[2];
  66     private final float[] miter = new float[2];
  67     private float miterLimitSq;
  68 
  69     private int prev;
  70 
  71     // The starting point of the path, and the slope there.

</pre><hr></hr><pre>
  78     // original path (thought they may have different directions), so these
  79     // could be computed from sdx,sdy and cdx,cdy (and vice versa), but that
  80     // would be error prone and hard to read, so we keep these anyway.
  81     private float smx, smy, cmx, cmy;
  82 
  83     private final PolyStack reverse;
  84 
  85     // This is where the curve to be processed is put. We give it
  86     // enough room to store all curves.
  87     private final float[] middle = new float[MAX_N_CURVES * 6 + 2];
  88     private final float[] lp = new float[8];
  89     private final float[] rp = new float[8];
  90     private final float[] subdivTs = new float[MAX_N_CURVES - 1];
  91 
  92     // per-thread renderer context
  93     final RendererContext rdrCtx;
  94 
  95     // dirty curve
  96     final Curve curve;
  97 
<span class="new">  98     // Bounds of the drawing region, at pixel precision.</span>
<span class="new">  99     private float[] clipRect;</span>
<span class="new"> 100 </span>
<span class="new"> 101     // the outcode of the current point</span>
<span class="new"> 102     private int cOutCode = 0;</span>
<span class="new"> 103 </span>
<span class="new"> 104     // the outcode of the starting point</span>
<span class="new"> 105     private int sOutCode = 0;</span>
<span class="new"> 106 </span>
<span class="new"> 107     // flag indicating if the path is opened (clipped)</span>
<span class="new"> 108     private boolean opened = false;</span>
<span class="new"> 109     // flag indicating if the starting point's cap is done</span>
<span class="new"> 110     private boolean capStart = false;</span>
<span class="new"> 111 </span>
 112     /**
 113      * Constructs a &lt;code&gt;Stroker&lt;/code&gt;.
 114      * @param rdrCtx per-thread renderer context
 115      */
 116     Stroker(final RendererContext rdrCtx) {
 117         this.rdrCtx = rdrCtx;
 118 
<span class="changed"> 119         this.reverse = (rdrCtx.stats != null) ?</span>
<span class="changed"> 120             new PolyStack(rdrCtx,</span>
<span class="changed"> 121                     rdrCtx.stats.stat_str_polystack_types,</span>
<span class="changed"> 122                     rdrCtx.stats.stat_str_polystack_curves,</span>
<span class="changed"> 123                     rdrCtx.stats.hist_str_polystack_curves,</span>
<span class="changed"> 124                     rdrCtx.stats.stat_array_str_polystack_curves,</span>
<span class="changed"> 125                     rdrCtx.stats.stat_array_str_polystack_types)</span>
<span class="changed"> 126             : new PolyStack(rdrCtx);</span>
<span class="changed"> 127 </span>
 128         this.curve = rdrCtx.curve;
 129     }
 130 
 131     /**
 132      * Inits the &lt;code&gt;Stroker&lt;/code&gt;.
 133      *
 134      * @param pc2d an output &lt;code&gt;PathConsumer2D&lt;/code&gt;.
 135      * @param lineWidth the desired line width in pixels
 136      * @param capStyle the desired end cap style, one of
 137      * &lt;code&gt;CAP_BUTT&lt;/code&gt;, &lt;code&gt;CAP_ROUND&lt;/code&gt; or
 138      * &lt;code&gt;CAP_SQUARE&lt;/code&gt;.
 139      * @param joinStyle the desired line join style, one of
 140      * &lt;code&gt;JOIN_MITER&lt;/code&gt;, &lt;code&gt;JOIN_ROUND&lt;/code&gt; or
 141      * &lt;code&gt;JOIN_BEVEL&lt;/code&gt;.
 142      * @param miterLimit the desired miter limit
<span class="new"> 143      * @param scale scaling factor applied to clip boundaries</span>
 144      * @return this instance
 145      */
<span class="changed"> 146     Stroker init(final PathConsumer2D pc2d,</span>
<span class="changed"> 147                  final float lineWidth,</span>
<span class="changed"> 148                  final int capStyle,</span>
<span class="changed"> 149                  final int joinStyle,</span>
<span class="changed"> 150                  final float miterLimit,</span>
<span class="changed"> 151                  final float scale)</span>
 152     {
 153         this.out = pc2d;
 154 
 155         this.lineWidth2 = lineWidth / 2.0f;
 156         this.invHalfLineWidth2Sq = 1.0f / (2.0f * lineWidth2 * lineWidth2);
 157         this.capStyle = capStyle;
 158         this.joinStyle = joinStyle;
 159 
<span class="changed"> 160         final float limit = miterLimit * lineWidth2;</span>
 161         this.miterLimitSq = limit * limit;
 162 
 163         this.prev = CLOSE;
 164 
 165         rdrCtx.stroking = 1;
 166 
<span class="new"> 167         if (rdrCtx.doClip) {</span>
<span class="new"> 168             // Adjust the clipping rectangle with the stroker margin (miter limit, width)</span>
<span class="new"> 169             float rdrOffX = 0.0f, rdrOffY = 0.0f;</span>
<span class="new"> 170             float margin = lineWidth2;</span>
<span class="new"> 171 </span>
<span class="new"> 172             if (capStyle == CAP_SQUARE) {</span>
<span class="new"> 173                 margin *= SQRT_2;</span>
<span class="new"> 174             }</span>
<span class="new"> 175             if ((joinStyle == JOIN_MITER) &amp;&amp; (margin &lt; limit)) {</span>
<span class="new"> 176                 margin = limit;</span>
<span class="new"> 177             }</span>
<span class="new"> 178             if (scale != 1.0f) {</span>
<span class="new"> 179                 margin *= scale;</span>
<span class="new"> 180                 rdrOffX = scale * Renderer.RDR_OFFSET_X;</span>
<span class="new"> 181                 rdrOffY = scale * Renderer.RDR_OFFSET_Y;</span>
<span class="new"> 182             }</span>
<span class="new"> 183             // add a small rounding error:</span>
<span class="new"> 184             margin += 1e-3f;</span>
<span class="new"> 185 </span>
<span class="new"> 186             // bounds as half-open intervals: minX &lt;= x &lt; maxX and minY &lt;= y &lt; maxY</span>
<span class="new"> 187             // adjust clip rectangle (ymin, ymax, xmin, xmax):</span>
<span class="new"> 188             final float[] _clipRect = rdrCtx.clipRect;</span>
<span class="new"> 189             _clipRect[0] -= margin - rdrOffY;</span>
<span class="new"> 190             _clipRect[1] += margin + rdrOffY;</span>
<span class="new"> 191             _clipRect[2] -= margin - rdrOffX;</span>
<span class="new"> 192             _clipRect[3] += margin + rdrOffX;</span>
<span class="new"> 193             this.clipRect = _clipRect;</span>
<span class="new"> 194         } else {</span>
<span class="new"> 195             this.clipRect = null;</span>
<span class="new"> 196             this.cOutCode = 0;</span>
<span class="new"> 197             this.sOutCode = 0;</span>
<span class="new"> 198         }</span>
 199         return this; // fluent API
 200     }
 201 
 202     /**
 203      * Disposes this stroker:
 204      * clean up before reusing this instance
 205      */
 206     void dispose() {
 207         reverse.dispose();
 208 
<span class="new"> 209         opened   = false;</span>
<span class="new"> 210         capStart = false;</span>
<span class="new"> 211 </span>
 212         if (DO_CLEAN_DIRTY) {
 213             // Force zero-fill dirty arrays:
 214             Arrays.fill(offset0, 0.0f);
 215             Arrays.fill(offset1, 0.0f);
 216             Arrays.fill(offset2, 0.0f);
 217             Arrays.fill(miter, 0.0f);
 218             Arrays.fill(middle, 0.0f);
 219             Arrays.fill(lp, 0.0f);
 220             Arrays.fill(rp, 0.0f);
 221             Arrays.fill(subdivTs, 0.0f);
 222         }
 223     }
 224 
 225     private static void computeOffset(final float lx, final float ly,
 226                                       final float w, final float[] m)
 227     {
 228         float len = lx*lx + ly*ly;
 229         if (len == 0.0f) {
 230             m[0] = 0.0f;
 231             m[1] = 0.0f;

</pre><hr></hr><pre>
 462 
 463         computeMiter((x0 - pdx) + omx, (y0 - pdy) + omy, x0 + omx, y0 + omy,
 464                      (dx + x0) + mx, (dy + y0) + my, x0 + mx, y0 + my,
 465                      miter, 0);
 466 
 467         final float miterX = miter[0];
 468         final float miterY = miter[1];
 469         float lenSq = (miterX-x0)*(miterX-x0) + (miterY-y0)*(miterY-y0);
 470 
 471         // If the lines are parallel, lenSq will be either NaN or +inf
 472         // (actually, I'm not sure if the latter is possible. The important
 473         // thing is that -inf is not possible, because lenSq is a square).
 474         // For both of those values, the comparison below will fail and
 475         // no miter will be drawn, which is correct.
 476         if (lenSq &lt; miterLimitSq) {
 477             emitLineTo(miterX, miterY, rev);
 478         }
 479     }
 480 
 481     @Override
<span class="changed"> 482     public void moveTo(final float x0, final float y0) {</span>
<span class="changed"> 483         moveTo(x0, y0, cOutCode);</span>
<span class="changed"> 484         // update starting point:</span>
<span class="changed"> 485         this.sx0 = x0;</span>
<span class="changed"> 486         this.sy0 = y0;</span>
<span class="changed"> 487         this.sdx = 1.0f;</span>
<span class="changed"> 488         this.sdy = 0.0f;</span>
<span class="changed"> 489         this.opened   = false;</span>
<span class="changed"> 490         this.capStart = false;</span>
<span class="changed"> 491 </span>
<span class="changed"> 492         if (clipRect != null) {</span>
<span class="changed"> 493             final int outcode = Helpers.outcode(x0, y0, clipRect);</span>
<span class="changed"> 494             this.cOutCode = outcode;</span>
<span class="changed"> 495             this.sOutCode = outcode;</span>
<span class="changed"> 496         }</span>
<span class="changed"> 497     }</span>
<span class="changed"> 498 </span>
<span class="changed"> 499     private void moveTo(final float x0, final float y0,</span>
<span class="changed"> 500                         final int outcode)</span>
<span class="changed"> 501     {</span>
<span class="changed"> 502         if (prev == MOVE_TO) {</span>
<span class="changed"> 503             this.cx0 = x0;</span>
<span class="changed"> 504             this.cy0 = y0;</span>
<span class="changed"> 505         } else {</span>
 506             if (prev == DRAWING_OP_TO) {
<span class="changed"> 507                 finish(outcode);</span>
 508             }




 509             this.prev = MOVE_TO;
<span class="new"> 510             this.cx0 = x0;</span>
<span class="new"> 511             this.cy0 = y0;</span>
<span class="new"> 512             this.cdx = 1.0f;</span>
<span class="new"> 513             this.cdy = 0.0f;</span>
<span class="new"> 514         }</span>
 515     }
 516 
 517     @Override
<span class="changed"> 518     public void lineTo(final float x1, final float y1) {</span>
<span class="changed"> 519         lineTo(x1, y1, false);</span>
<span class="changed"> 520     }</span>
<span class="changed"> 521 </span>
<span class="changed"> 522     private void lineTo(final float x1, final float y1,</span>
<span class="changed"> 523                         final boolean force)</span>
<span class="changed"> 524     {</span>
<span class="changed"> 525         final int outcode0 = this.cOutCode;</span>
<span class="changed"> 526         if (!force &amp;&amp; clipRect != null) {</span>
<span class="changed"> 527             final int outcode1 = Helpers.outcode(x1, y1, clipRect);</span>
<span class="changed"> 528             this.cOutCode = outcode1;</span>
<span class="changed"> 529 </span>
<span class="changed"> 530             // basic rejection criteria</span>
<span class="changed"> 531             if ((outcode0 &amp; outcode1) != 0) {</span>
<span class="changed"> 532                 moveTo(x1, y1, outcode0);</span>
<span class="changed"> 533                 opened = true;</span>
<span class="changed"> 534                 return;</span>
<span class="changed"> 535             }</span>
<span class="changed"> 536         }</span>
<span class="changed"> 537 </span>
 538         float dx = x1 - cx0;
 539         float dy = y1 - cy0;
 540         if (dx == 0.0f &amp;&amp; dy == 0.0f) {
 541             dx = 1.0f;
 542         }
 543         computeOffset(dx, dy, lineWidth2, offset0);
 544         final float mx = offset0[0];
 545         final float my = offset0[1];
 546 
<span class="changed"> 547         drawJoin(cdx, cdy, cx0, cy0, dx, dy, cmx, cmy, mx, my, outcode0);</span>
 548 
 549         emitLineTo(cx0 + mx, cy0 + my);
 550         emitLineTo( x1 + mx,  y1 + my);
 551 
 552         emitLineToRev(cx0 - mx, cy0 - my);
 553         emitLineToRev( x1 - mx,  y1 - my);
 554 
<span class="changed"> 555         this.prev = DRAWING_OP_TO;</span>



 556         this.cx0 = x1;
 557         this.cy0 = y1;
<span class="changed"> 558         this.cdx = dx;</span>
<span class="changed"> 559         this.cdy = dy;</span>
<span class="changed"> 560         this.cmx = mx;</span>
<span class="changed"> 561         this.cmy = my;</span>
 562     }
 563 
 564     @Override
 565     public void closePath() {
<span class="changed"> 566         // distinguish empty path at all vs opened path ?</span>
<span class="changed"> 567         if (prev != DRAWING_OP_TO &amp;&amp; !opened) {</span>
 568             if (prev == CLOSE) {
 569                 return;
 570             }
 571             emitMoveTo(cx0, cy0 - lineWidth2);
<span class="changed"> 572 </span>
<span class="changed"> 573             this.sdx = 1.0f;</span>
<span class="changed"> 574             this.sdy = 0.0f;</span>
<span class="changed"> 575             this.cdx = 1.0f;</span>
<span class="changed"> 576             this.cdy = 0.0f;</span>
<span class="changed"> 577 </span>
<span class="changed"> 578             this.smx = 0.0f;</span>
<span class="changed"> 579             this.smy = -lineWidth2;</span>
<span class="changed"> 580             this.cmx = 0.0f;</span>
<span class="changed"> 581             this.cmy = -lineWidth2;</span>
<span class="changed"> 582 </span>
<span class="changed"> 583             finish(cOutCode);</span>
 584             return;
 585         }
 586 
<span class="new"> 587         // basic acceptance criteria</span>
<span class="new"> 588         if ((sOutCode &amp; cOutCode) == 0) {</span>
 589             if (cx0 != sx0 || cy0 != sy0) {
<span class="changed"> 590                 lineTo(sx0, sy0, true);</span>
 591             }
 592 
<span class="changed"> 593             drawJoin(cdx, cdy, cx0, cy0, sdx, sdy, cmx, cmy, smx, smy, sOutCode);</span>
 594 
 595             emitLineTo(sx0 + smx, sy0 + smy);
 596 
<span class="new"> 597             if (opened) {</span>
<span class="new"> 598                 emitLineTo(sx0 - smx, sy0 - smy);</span>
<span class="new"> 599             } else {</span>
 600                 emitMoveTo(sx0 - smx, sy0 - smy);
<span class="new"> 601             }</span>
<span class="new"> 602         }</span>
<span class="new"> 603         // Ignore caps like finish(false)</span>
 604         emitReverse();
 605 
 606         this.prev = CLOSE;
<span class="new"> 607 </span>
<span class="new"> 608         if (opened) {</span>
<span class="new"> 609             // do not emit close</span>
<span class="new"> 610             opened = false;</span>
<span class="new"> 611         } else {</span>
 612             emitClose();
 613         }
<span class="new"> 614     }</span>
 615 
 616     private void emitReverse() {
 617         reverse.popAll(out);
 618     }
 619 
 620     @Override
 621     public void pathDone() {
 622         if (prev == DRAWING_OP_TO) {
<span class="changed"> 623             finish(cOutCode);</span>
 624         }
 625 
 626         out.pathDone();
 627 
 628         // this shouldn't matter since this object won't be used
 629         // after the call to this method.
 630         this.prev = CLOSE;
 631 
 632         // Dispose this instance:
 633         dispose();
 634     }
 635 
<span class="changed"> 636     private void finish(final int outcode) {</span>
<span class="changed"> 637         // Problem: impossible to guess if the path will be closed in advance</span>
<span class="changed"> 638         //          i.e. if caps must be drawn or not ?</span>
<span class="changed"> 639         // Solution: use the ClosedPathDetector before Stroker to determine</span>
<span class="changed"> 640         // if the path is a closed path or not</span>
<span class="changed"> 641         if (!rdrCtx.closedPath) {</span>
<span class="changed"> 642             if (outcode == 0) {</span>
<span class="changed"> 643                 // current point = end's cap:</span>
 644                 if (capStyle == CAP_ROUND) {
 645                     drawRoundCap(cx0, cy0, cmx, cmy);
 646                 } else if (capStyle == CAP_SQUARE) {
 647                     emitLineTo(cx0 - cmy + cmx, cy0 + cmx + cmy);
 648                     emitLineTo(cx0 - cmy - cmx, cy0 + cmx - cmy);
 649                 }
<span class="changed"> 650             }</span>
 651             emitReverse();
 652 
<span class="new"> 653             if (!capStart) {</span>
<span class="new"> 654                 capStart = true;</span>
<span class="new"> 655 </span>
<span class="new"> 656                 if (sOutCode == 0) {</span>
<span class="new"> 657                     // starting point = initial cap:</span>
 658                     if (capStyle == CAP_ROUND) {
 659                         drawRoundCap(sx0, sy0, -smx, -smy);
 660                     } else if (capStyle == CAP_SQUARE) {
 661                         emitLineTo(sx0 + smy - smx, sy0 - smx - smy);
 662                         emitLineTo(sx0 + smy + smx, sy0 - smx + smy);
 663                     }
<span class="changed"> 664                 }</span>
<span class="changed"> 665             }</span>
<span class="changed"> 666         } else {</span>
<span class="changed"> 667             emitReverse();</span>
<span class="changed"> 668         }</span>
 669         emitClose();
 670     }
 671 
 672     private void emitMoveTo(final float x0, final float y0) {
 673         out.moveTo(x0, y0);
 674     }
 675 
 676     private void emitLineTo(final float x1, final float y1) {
 677         out.lineTo(x1, y1);
 678     }
 679 
 680     private void emitLineToRev(final float x1, final float y1) {
 681         reverse.pushLine(x1, y1);
 682     }
 683 
 684     private void emitLineTo(final float x1, final float y1,
 685                             final boolean rev)
 686     {
 687         if (rev) {
 688             emitLineToRev(x1, y1);

</pre><hr></hr><pre>
 720     private void emitCurveTo(final float x0, final float y0,
 721                              final float x1, final float y1,
 722                              final float x2, final float y2,
 723                              final float x3, final float y3, final boolean rev)
 724     {
 725         if (rev) {
 726             reverse.pushCubic(x0, y0, x1, y1, x2, y2);
 727         } else {
 728             out.curveTo(x1, y1, x2, y2, x3, y3);
 729         }
 730     }
 731 
 732     private void emitClose() {
 733         out.closePath();
 734     }
 735 
 736     private void drawJoin(float pdx, float pdy,
 737                           float x0, float y0,
 738                           float dx, float dy,
 739                           float omx, float omy,
<span class="changed"> 740                           float mx, float my,</span>
<span class="changed"> 741                           final int outcode)</span>
 742     {
 743         if (prev != DRAWING_OP_TO) {
 744             emitMoveTo(x0 + mx, y0 + my);
<span class="new"> 745             if (!opened) {</span>
 746                 this.sdx = dx;
 747                 this.sdy = dy;
 748                 this.smx = mx;
 749                 this.smy = my;
<span class="new"> 750             }</span>
 751         } else {
<span class="changed"> 752             final boolean cw = isCW(pdx, pdy, dx, dy);</span>
<span class="changed"> 753             if (outcode == 0) {</span>
 754                 if (joinStyle == JOIN_MITER) {
 755                     drawMiter(pdx, pdy, x0, y0, dx, dy, omx, omy, mx, my, cw);
 756                 } else if (joinStyle == JOIN_ROUND) {
 757                     drawRoundJoin(x0, y0,
 758                                   omx, omy,
 759                                   mx, my, cw,
 760                                   ROUND_JOIN_THRESHOLD);
 761                 }
<span class="new"> 762             }</span>
 763             emitLineTo(x0, y0, !cw);
 764         }
 765         prev = DRAWING_OP_TO;
 766     }
 767 
 768     private static boolean within(final float x1, final float y1,
 769                                   final float x2, final float y2,
 770                                   final float ERR)
 771     {
 772         assert ERR &gt; 0 : "";
 773         // compare taxicab distance. ERR will always be small, so using
 774         // true distance won't give much benefit
 775         return (Helpers.within(x1, x2, ERR) &amp;&amp;  // we want to avoid calling Math.abs
 776                 Helpers.within(y1, y2, ERR)); // this is just as good.
 777     }
 778 
 779     private void getLineOffsets(float x1, float y1,
 780                                 float x2, float y2,
 781                                 float[] left, float[] right) {
 782         computeOffset(x2 - x1, y2 - y1, lineWidth2, offset0);

</pre><hr></hr><pre>
1046         int ret = 0;
1047         // we subdivide at values of t such that the remaining rotated
1048         // curves are monotonic in x and y.
1049         ret += c.dxRoots(ts, ret);
1050         ret += c.dyRoots(ts, ret);
1051         // subdivide at inflection points.
1052         if (type == 8) {
1053             // quadratic curves can't have inflection points
1054             ret += c.infPoints(ts, ret);
1055         }
1056 
1057         // now we must subdivide at points where one of the offset curves will have
1058         // a cusp. This happens at ts where the radius of curvature is equal to w.
1059         ret += c.rootsOfROCMinusW(ts, ret, w, 0.0001f);
1060 
1061         ret = Helpers.filterOutNotInAB(ts, 0, ret, 0.0001f, 0.9999f);
1062         Helpers.isort(ts, 0, ret);
1063         return ret;
1064     }
1065 
<span class="changed">1066     @Override</span>
<span class="changed">1067     public void curveTo(final float x1, final float y1,</span>
<span class="changed">1068                         final float x2, final float y2,</span>
<span class="changed">1069                         final float x3, final float y3)</span>
1070     {
<span class="new">1071         final int outcode0 = this.cOutCode;</span>
<span class="new">1072         if (clipRect != null) {</span>
<span class="new">1073             final int outcode3 = Helpers.outcode(x3, y3, clipRect);</span>
<span class="new">1074             this.cOutCode = outcode3;</span>
<span class="new">1075 </span>
<span class="new">1076             if ((outcode0 &amp; outcode3) != 0) {</span>
<span class="new">1077                 final int outcode1 = Helpers.outcode(x1, y1, clipRect);</span>
<span class="new">1078                 final int outcode2 = Helpers.outcode(x2, y2, clipRect);</span>
<span class="new">1079 </span>
<span class="new">1080                 // basic rejection criteria</span>
<span class="new">1081                 if ((outcode0 &amp; outcode1 &amp; outcode2 &amp; outcode3) != 0) {</span>
<span class="new">1082                     moveTo(x3, y3, outcode0);</span>
<span class="new">1083                     opened = true;</span>
<span class="new">1084                     return;</span>
<span class="new">1085                 }</span>
<span class="new">1086             }</span>
<span class="new">1087         }</span>
<span class="new">1088 </span>
1089         final float[] mid = middle;
1090 
1091         mid[0] = cx0; mid[1] = cy0;
1092         mid[2] = x1;  mid[3] = y1;
1093         mid[4] = x2;  mid[5] = y2;
1094         mid[6] = x3;  mid[7] = y3;
1095 
1096         // need these so we can update the state at the end of this method
<span class="changed">1097         final float xf = x3, yf = y3;</span>
1098         float dxs = mid[2] - mid[0];
1099         float dys = mid[3] - mid[1];
1100         float dxf = mid[6] - mid[4];
1101         float dyf = mid[7] - mid[5];
1102 
1103         boolean p1eqp2 = (dxs == 0.0f &amp;&amp; dys == 0.0f);
1104         boolean p3eqp4 = (dxf == 0.0f &amp;&amp; dyf == 0.0f);
1105         if (p1eqp2) {
1106             dxs = mid[4] - mid[0];
1107             dys = mid[5] - mid[1];
1108             if (dxs == 0.0f &amp;&amp; dys == 0.0f) {
1109                 dxs = mid[6] - mid[0];
1110                 dys = mid[7] - mid[1];
1111             }
1112         }
1113         if (p3eqp4) {
1114             dxf = mid[6] - mid[2];
1115             dyf = mid[7] - mid[3];
1116             if (dxf == 0.0f &amp;&amp; dyf == 0.0f) {
1117                 dxf = mid[6] - mid[0];
1118                 dyf = mid[7] - mid[1];
1119             }
1120         }
1121         if (dxs == 0.0f &amp;&amp; dys == 0.0f) {
1122             // this happens if the "curve" is just a point
<span class="new">1123             // fix outcode0 for lineTo() call:</span>
<span class="new">1124             if (clipRect != null) {</span>
<span class="new">1125                 this.cOutCode = outcode0;</span>
<span class="new">1126             }</span>
1127             lineTo(mid[0], mid[1]);
1128             return;
1129         }
1130 
1131         // if these vectors are too small, normalize them, to avoid future
1132         // precision problems.
1133         if (Math.abs(dxs) &lt; 0.1f &amp;&amp; Math.abs(dys) &lt; 0.1f) {
1134             float len = (float) Math.sqrt(dxs*dxs + dys*dys);
1135             dxs /= len;
1136             dys /= len;
1137         }
1138         if (Math.abs(dxf) &lt; 0.1f &amp;&amp; Math.abs(dyf) &lt; 0.1f) {
1139             float len = (float) Math.sqrt(dxf*dxf + dyf*dyf);
1140             dxf /= len;
1141             dyf /= len;
1142         }
1143 
1144         computeOffset(dxs, dys, lineWidth2, offset0);
<span class="changed">1145         drawJoin(cdx, cdy, cx0, cy0, dxs, dys, cmx, cmy, offset0[0], offset0[1], outcode0);</span>
1146 
1147         final int nSplits = findSubdivPoints(curve, mid, subdivTs, 8, lineWidth2);
1148 
1149         float prevT = 0.0f;
1150         for (int i = 0, off = 0; i &lt; nSplits; i++, off += 6) {
1151             final float t = subdivTs[i];
1152             Helpers.subdivideCubicAt((t - prevT) / (1.0f - prevT),
1153                                      mid, off, mid, off, mid, off + 6);
1154             prevT = t;
1155         }
1156 
1157         final float[] l = lp;
1158         final float[] r = rp;
1159 
1160         int kind = 0;
1161         for (int i = 0, off = 0; i &lt;= nSplits; i++, off += 6) {
1162             kind = computeOffsetCubic(mid, off, l, r);
1163 
1164             emitLineTo(l[0], l[1]);
1165 
1166             switch(kind) {
1167             case 8:
1168                 emitCurveTo(l[2], l[3], l[4], l[5], l[6], l[7]);
1169                 emitCurveToRev(r[0], r[1], r[2], r[3], r[4], r[5]);
1170                 break;
1171             case 4:
1172                 emitLineTo(l[2], l[3]);
1173                 emitLineToRev(r[0], r[1]);
1174                 break;
1175             default:
1176             }
1177             emitLineToRev(r[kind - 2], r[kind - 1]);
1178         }
1179 
<span class="changed">1180         this.prev = DRAWING_OP_TO;</span>



1181         this.cx0 = xf;
1182         this.cy0 = yf;
<span class="changed">1183         this.cdx = dxf;</span>
<span class="changed">1184         this.cdy = dyf;</span>
<span class="changed">1185         this.cmx = (l[kind - 2] - r[kind - 2]) / 2.0f;</span>
<span class="changed">1186         this.cmy = (l[kind - 1] - r[kind - 1]) / 2.0f;</span>
<span class="changed">1187     }</span>
<span class="changed">1188 </span>
<span class="changed">1189     @Override</span>
<span class="changed">1190     public void quadTo(final float x1, final float y1,</span>
<span class="changed">1191                        final float x2, final float y2)</span>
<span class="changed">1192     {</span>
<span class="changed">1193         final int outcode0 = this.cOutCode;</span>
<span class="changed">1194         if (clipRect != null) {</span>
<span class="changed">1195             final int outcode2 = Helpers.outcode(x2, y2, clipRect);</span>
<span class="changed">1196             this.cOutCode = outcode2;</span>
<span class="changed">1197 </span>
<span class="changed">1198             if ((outcode0 &amp; outcode2) != 0) {</span>
<span class="changed">1199                 final int outcode1 = Helpers.outcode(x1, y1, clipRect);</span>
<span class="changed">1200 </span>
<span class="changed">1201                 // basic rejection criteria</span>
<span class="changed">1202                 if ((outcode0 &amp; outcode1 &amp; outcode2) != 0) {</span>
<span class="changed">1203                     moveTo(x2, y2, outcode0);</span>
<span class="changed">1204                     opened = true;</span>
<span class="changed">1205                     return;</span>
<span class="changed">1206                 }</span>
<span class="changed">1207             }</span>
1208         }
1209 

1210         final float[] mid = middle;
1211 
1212         mid[0] = cx0; mid[1] = cy0;
1213         mid[2] = x1;  mid[3] = y1;
1214         mid[4] = x2;  mid[5] = y2;
1215 
1216         // need these so we can update the state at the end of this method
<span class="changed">1217         final float xf = x2, yf = y2;</span>
1218         float dxs = mid[2] - mid[0];
1219         float dys = mid[3] - mid[1];
1220         float dxf = mid[4] - mid[2];
1221         float dyf = mid[5] - mid[3];
1222         if ((dxs == 0.0f &amp;&amp; dys == 0.0f) || (dxf == 0.0f &amp;&amp; dyf == 0.0f)) {
1223             dxs = dxf = mid[4] - mid[0];
1224             dys = dyf = mid[5] - mid[1];
1225         }
1226         if (dxs == 0.0f &amp;&amp; dys == 0.0f) {
1227             // this happens if the "curve" is just a point
<span class="new">1228             // fix outcode0 for lineTo() call:</span>
<span class="new">1229             if (clipRect != null) {</span>
<span class="new">1230                 this.cOutCode = outcode0;</span>
<span class="new">1231             }</span>
1232             lineTo(mid[0], mid[1]);
1233             return;
1234         }
1235         // if these vectors are too small, normalize them, to avoid future
1236         // precision problems.
1237         if (Math.abs(dxs) &lt; 0.1f &amp;&amp; Math.abs(dys) &lt; 0.1f) {
1238             float len = (float) Math.sqrt(dxs*dxs + dys*dys);
1239             dxs /= len;
1240             dys /= len;
1241         }
1242         if (Math.abs(dxf) &lt; 0.1f &amp;&amp; Math.abs(dyf) &lt; 0.1f) {
1243             float len = (float) Math.sqrt(dxf*dxf + dyf*dyf);
1244             dxf /= len;
1245             dyf /= len;
1246         }
1247 
1248         computeOffset(dxs, dys, lineWidth2, offset0);
<span class="changed">1249         drawJoin(cdx, cdy, cx0, cy0, dxs, dys, cmx, cmy, offset0[0], offset0[1], outcode0);</span>
1250 
1251         int nSplits = findSubdivPoints(curve, mid, subdivTs, 6, lineWidth2);
1252 
1253         float prevt = 0.0f;
1254         for (int i = 0, off = 0; i &lt; nSplits; i++, off += 4) {
1255             final float t = subdivTs[i];
1256             Helpers.subdivideQuadAt((t - prevt) / (1.0f - prevt),
1257                                     mid, off, mid, off, mid, off + 4);
1258             prevt = t;
1259         }
1260 
1261         final float[] l = lp;
1262         final float[] r = rp;
1263 
1264         int kind = 0;
1265         for (int i = 0, off = 0; i &lt;= nSplits; i++, off += 4) {
1266             kind = computeOffsetQuad(mid, off, l, r);
1267 
1268             emitLineTo(l[0], l[1]);
1269 
1270             switch(kind) {
1271             case 6:
1272                 emitQuadTo(l[2], l[3], l[4], l[5]);
1273                 emitQuadToRev(r[0], r[1], r[2], r[3]);
1274                 break;
1275             case 4:
1276                 emitLineTo(l[2], l[3]);
1277                 emitLineToRev(r[0], r[1]);
1278                 break;
1279             default:
1280             }
1281             emitLineToRev(r[kind - 2], r[kind - 1]);
1282         }
1283 
<span class="changed">1284         this.prev = DRAWING_OP_TO;</span>



1285         this.cx0 = xf;
1286         this.cy0 = yf;
<span class="changed">1287         this.cdx = dxf;</span>
<span class="changed">1288         this.cdy = dyf;</span>
<span class="changed">1289         this.cmx = (l[kind - 2] - r[kind - 2]) / 2.0f;</span>
<span class="changed">1290         this.cmy = (l[kind - 1] - r[kind - 1]) / 2.0f;</span>
1291     }
1292 
1293     @Override public long getNativeConsumer() {
1294         throw new InternalError("Stroker doesn't use a native consumer");
1295     }






































































































































































































1296 }
</pre></td>
</tr></table>
<center><a href='../../../../../../src/share/classes/sun/java2d/marlin/RendererStats.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../src/share/classes/sun/java2d/marlin/TransformingPathConsumer2D.java.sdiff.html' target='_top'>next &gt</a></center>
</body></html>
