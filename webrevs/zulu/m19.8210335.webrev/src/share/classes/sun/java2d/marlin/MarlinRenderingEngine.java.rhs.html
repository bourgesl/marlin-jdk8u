<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-13698">13698</a> : <a href="https://bugs.openjdk.java.net/browse/JDK-8210335">8210335</a>: Clipping problems with complex affine transforms: negative scaling factors or small scaling factors
Summary: fixed clipping rectangle to take into account the inverse transform (scale/shear)
Reviewed-by: prr, serb</pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2007, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the "Classpath" exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.java2d.marlin;
  27 
  28 import java.awt.BasicStroke;
  29 import java.awt.Shape;
  30 import java.awt.geom.AffineTransform;
  31 import java.awt.geom.Path2D;
  32 import java.awt.geom.PathIterator;
  33 import java.security.AccessController;
<a name="1" id="anc1"></a><span class="new">  34 import java.util.Arrays;</span>
  35 import static sun.java2d.marlin.MarlinUtils.logInfo;
  36 import sun.awt.geom.PathConsumer2D;
  37 import sun.java2d.ReentrantContextProvider;
  38 import sun.java2d.ReentrantContextProviderCLQ;
  39 import sun.java2d.ReentrantContextProviderTL;
  40 import sun.java2d.pipe.AATileGenerator;
  41 import sun.java2d.pipe.Region;
  42 import sun.java2d.pipe.RenderingEngine;
  43 import sun.security.action.GetPropertyAction;
  44 
  45 /**
  46  * Marlin RendererEngine implementation (derived from Pisces)
  47  */
  48 public final class MarlinRenderingEngine extends RenderingEngine
  49                                          implements MarlinConst
  50 {
  51     // slightly slower ~2% if enabled stroker clipping (lines) but skipping cap / join handling is few percents faster in specific cases
  52     static final boolean DISABLE_2ND_STROKER_CLIPPING = true;
  53 
  54     static final boolean DO_TRACE_PATH = false;
  55 
  56     static final boolean DO_CLIP = MarlinProperties.isDoClip();
  57     static final boolean DO_CLIP_FILL = true;
  58     static final boolean DO_CLIP_RUNTIME_ENABLE = MarlinProperties.isDoClipRuntimeFlag();
  59 
  60     private static final float MIN_PEN_SIZE = 1.0f / MIN_SUBPIXELS;
  61 
  62     static final float UPPER_BND = Float.MAX_VALUE / 2.0f;
  63     static final float LOWER_BND = -UPPER_BND;
  64 
  65     private enum NormMode {
  66         ON_WITH_AA {
  67             @Override
  68             PathIterator getNormalizingPathIterator(final RendererContext rdrCtx,
  69                                                     final PathIterator src)
  70             {
  71                 // NormalizingPathIterator NearestPixelCenter:
  72                 return rdrCtx.nPCPathIterator.init(src);
  73             }
  74         },
  75         ON_NO_AA{
  76             @Override
  77             PathIterator getNormalizingPathIterator(final RendererContext rdrCtx,
  78                                                     final PathIterator src)
  79             {
  80                 // NearestPixel NormalizingPathIterator:
  81                 return rdrCtx.nPQPathIterator.init(src);
  82             }
  83         },
  84         OFF{
  85             @Override
  86             PathIterator getNormalizingPathIterator(final RendererContext rdrCtx,
  87                                                     final PathIterator src)
  88             {
  89                 // return original path iterator if normalization is disabled:
  90                 return src;
  91             }
  92         };
  93 
  94         abstract PathIterator getNormalizingPathIterator(RendererContext rdrCtx,
  95                                                          PathIterator src);
  96     }
  97 
  98     /**
  99      * Public constructor
 100      */
 101     public MarlinRenderingEngine() {
 102         super();
 103         logSettings(MarlinRenderingEngine.class.getName());
 104     }
 105 
 106     /**
 107      * Create a widened path as specified by the parameters.
 108      * &lt;p&gt;
 109      * The specified {@code src} {@link Shape} is widened according
 110      * to the specified attribute parameters as per the
 111      * {@link BasicStroke} specification.
 112      *
 113      * @param src the source path to be widened
 114      * @param width the width of the widened path as per {@code BasicStroke}
 115      * @param caps the end cap decorations as per {@code BasicStroke}
 116      * @param join the segment join decorations as per {@code BasicStroke}
 117      * @param miterlimit the miter limit as per {@code BasicStroke}
 118      * @param dashes the dash length array as per {@code BasicStroke}
 119      * @param dashphase the initial dash phase as per {@code BasicStroke}
 120      * @return the widened path stored in a new {@code Shape} object
 121      * @since 1.7
 122      */
 123     @Override
 124     public Shape createStrokedShape(Shape src,
 125                                     float width,
 126                                     int caps,
 127                                     int join,
 128                                     float miterlimit,
 129                                     float[] dashes,
 130                                     float dashphase)
 131     {
 132         final RendererContext rdrCtx = getRendererContext();
 133         try {
 134             // initialize a large copyable Path2D to avoid a lot of array growing:
 135             final Path2D.Float p2d = rdrCtx.getPath2D();
 136 
 137             strokeTo(rdrCtx,
 138                      src,
 139                      null,
 140                      width,
 141                      NormMode.OFF,
 142                      caps,
 143                      join,
 144                      miterlimit,
 145                      dashes,
 146                      dashphase,
 147                      rdrCtx.transformerPC2D.wrapPath2D(p2d)
 148                     );
 149 
 150             // Use Path2D copy constructor (trim)
 151             return new Path2D.Float(p2d);
 152 
 153         } finally {
 154             // recycle the RendererContext instance
 155             returnRendererContext(rdrCtx);
 156         }
 157     }
 158 
 159     /**
 160      * Sends the geometry for a widened path as specified by the parameters
 161      * to the specified consumer.
 162      * &lt;p&gt;
 163      * The specified {@code src} {@link Shape} is widened according
 164      * to the parameters specified by the {@link BasicStroke} object.
 165      * Adjustments are made to the path as appropriate for the
 166      * {@link VALUE_STROKE_NORMALIZE} hint if the {@code normalize}
 167      * boolean parameter is true.
 168      * Adjustments are made to the path as appropriate for the
 169      * {@link VALUE_ANTIALIAS_ON} hint if the {@code antialias}
 170      * boolean parameter is true.
 171      * &lt;p&gt;
 172      * The geometry of the widened path is forwarded to the indicated
 173      * {@link PathConsumer2D} object as it is calculated.
 174      *
 175      * @param src the source path to be widened
 176      * @param bs the {@code BasicSroke} object specifying the
 177      *           decorations to be applied to the widened path
 178      * @param normalize indicates whether stroke normalization should
 179      *                  be applied
 180      * @param antialias indicates whether or not adjustments appropriate
 181      *                  to antialiased rendering should be applied
 182      * @param consumer the {@code PathConsumer2D} instance to forward
 183      *                 the widened geometry to
 184      * @since 1.7
 185      */
 186     @Override
 187     public void strokeTo(Shape src,
 188                          AffineTransform at,
 189                          BasicStroke bs,
 190                          boolean thin,
 191                          boolean normalize,
 192                          boolean antialias,
 193                          final PathConsumer2D consumer)
 194     {
 195         final NormMode norm = (normalize) ?
 196                 ((antialias) ? NormMode.ON_WITH_AA : NormMode.ON_NO_AA)
 197                 : NormMode.OFF;
 198 
 199         final RendererContext rdrCtx = getRendererContext();
 200         try {
 201             strokeTo(rdrCtx, src, at, bs, thin, norm, antialias, consumer);
 202         } finally {
 203             // recycle the RendererContext instance
 204             returnRendererContext(rdrCtx);
 205         }
 206     }
 207 
 208     void strokeTo(final RendererContext rdrCtx,
 209                   Shape src,
 210                   AffineTransform at,
 211                   BasicStroke bs,
 212                   boolean thin,
 213                   NormMode normalize,
 214                   boolean antialias,
 215                   PathConsumer2D pc2d)
 216     {
 217         float lw;
 218         if (thin) {
 219             if (antialias) {
 220                 lw = userSpaceLineWidth(at, MIN_PEN_SIZE);
 221             } else {
 222                 lw = userSpaceLineWidth(at, 1.0f);
 223             }
 224         } else {
 225             lw = bs.getLineWidth();
 226         }
 227         strokeTo(rdrCtx,
 228                  src,
 229                  at,
 230                  lw,
 231                  normalize,
 232                  bs.getEndCap(),
 233                  bs.getLineJoin(),
 234                  bs.getMiterLimit(),
 235                  bs.getDashArray(),
 236                  bs.getDashPhase(),
 237                  pc2d);
 238     }
 239 
 240     private final float userSpaceLineWidth(AffineTransform at, float lw) {
 241 
 242         float widthScale;
 243 
 244         if (at == null) {
 245             widthScale = 1.0f;
 246         } else if ((at.getType() &amp; (AffineTransform.TYPE_GENERAL_TRANSFORM  |
 247                                     AffineTransform.TYPE_GENERAL_SCALE)) != 0) {
 248             widthScale = (float)Math.sqrt(at.getDeterminant());
 249         } else {
 250             // First calculate the "maximum scale" of this transform.
 251             double A = at.getScaleX();       // m00
 252             double C = at.getShearX();       // m01
 253             double B = at.getShearY();       // m10
 254             double D = at.getScaleY();       // m11
 255 
 256             /*
 257              * Given a 2 x 2 affine matrix [ A B ] such that
 258              *                             [ C D ]
 259              * v' = [x' y'] = [Ax + Cy, Bx + Dy], we want to
 260              * find the maximum magnitude (norm) of the vector v'
 261              * with the constraint (x^2 + y^2 = 1).
 262              * The equation to maximize is
 263              *     |v'| = sqrt((Ax+Cy)^2+(Bx+Dy)^2)
 264              * or  |v'| = sqrt((AA+BB)x^2 + 2(AC+BD)xy + (CC+DD)y^2).
 265              * Since sqrt is monotonic we can maximize |v'|^2
 266              * instead and plug in the substitution y = sqrt(1 - x^2).
 267              * Trigonometric equalities can then be used to get
 268              * rid of most of the sqrt terms.
 269              */
 270 
 271             double EA = A*A + B*B;          // x^2 coefficient
 272             double EB = 2.0d * (A*C + B*D); // xy coefficient
 273             double EC = C*C + D*D;          // y^2 coefficient
 274 
 275             /*
 276              * There is a lot of calculus omitted here.
 277              *
 278              * Conceptually, in the interests of understanding the
 279              * terms that the calculus produced we can consider
 280              * that EA and EC end up providing the lengths along
 281              * the major axes and the hypot term ends up being an
 282              * adjustment for the additional length along the off-axis
 283              * angle of rotated or sheared ellipses as well as an
 284              * adjustment for the fact that the equation below
 285              * averages the two major axis lengths.  (Notice that
 286              * the hypot term contains a part which resolves to the
 287              * difference of these two axis lengths in the absence
 288              * of rotation.)
 289              *
 290              * In the calculus, the ratio of the EB and (EA-EC) terms
 291              * ends up being the tangent of 2*theta where theta is
 292              * the angle that the long axis of the ellipse makes
 293              * with the horizontal axis.  Thus, this equation is
 294              * calculating the length of the hypotenuse of a triangle
 295              * along that axis.
 296              */
 297 
 298             double hypot = Math.sqrt(EB*EB + (EA-EC)*(EA-EC));
 299             // sqrt omitted, compare to squared limits below.
 300             double widthsquared = ((EA + EC + hypot) / 2.0d);
 301 
 302             widthScale = (float)Math.sqrt(widthsquared);
 303         }
 304 
 305         return (lw / widthScale);
 306     }
 307 
 308     void strokeTo(final RendererContext rdrCtx,
 309                   Shape src,
 310                   AffineTransform at,
 311                   float width,
 312                   NormMode norm,
 313                   int caps,
 314                   int join,
 315                   float miterlimit,
 316                   float[] dashes,
 317                   float dashphase,
 318                   PathConsumer2D pc2d)
 319     {
 320         // We use strokerat so that in Stroker and Dasher we can work only
 321         // with the pre-transformation coordinates. This will repeat a lot of
 322         // computations done in the path iterator, but the alternative is to
 323         // work with transformed paths and compute untransformed coordinates
 324         // as needed. This would be faster but I do not think the complexity
 325         // of working with both untransformed and transformed coordinates in
 326         // the same code is worth it.
 327         // However, if a path's width is constant after a transformation,
 328         // we can skip all this untransforming.
 329 
 330         // As pathTo() will check transformed coordinates for invalid values
 331         // (NaN / Infinity) to ignore such points, it is necessary to apply the
 332         // transformation before the path processing.
 333         AffineTransform strokerat = null;
 334 
 335         int dashLen = -1;
 336         boolean recycleDashes = false;
<a name="2" id="anc2"></a>
 337 
 338         if (at != null &amp;&amp; !at.isIdentity()) {
 339             final double a = at.getScaleX();
 340             final double b = at.getShearX();
 341             final double c = at.getShearY();
 342             final double d = at.getScaleY();
 343             final double det = a * d - c * b;
 344 
 345             if (Math.abs(det) &lt;= (2.0f * Float.MIN_VALUE)) {
 346                 // this rendering engine takes one dimensional curves and turns
 347                 // them into 2D shapes by giving them width.
 348                 // However, if everything is to be passed through a singular
 349                 // transformation, these 2D shapes will be squashed down to 1D
 350                 // again so, nothing can be drawn.
 351 
 352                 // Every path needs an initial moveTo and a pathDone. If these
 353                 // are not there this causes a SIGSEGV in libawt.so (at the time
 354                 // of writing of this comment (September 16, 2010)). Actually,
 355                 // I am not sure if the moveTo is necessary to avoid the SIGSEGV
 356                 // but the pathDone is definitely needed.
 357                 pc2d.moveTo(0.0f, 0.0f);
 358                 pc2d.pathDone();
 359                 return;
 360             }
 361 
 362             // If the transform is a constant multiple of an orthogonal transformation
 363             // then every length is just multiplied by a constant, so we just
 364             // need to transform input paths to stroker and tell stroker
 365             // the scaled width. This condition is satisfied if
 366             // a*b == -c*d &amp;&amp; a*a+c*c == b*b+d*d. In the actual check below, we
 367             // leave a bit of room for error.
 368             if (nearZero(a*b + c*d) &amp;&amp; nearZero(a*a + c*c - (b*b + d*d))) {
<a name="3" id="anc3"></a><span class="changed"> 369                 final float scale = (float) Math.sqrt(a*a + c*c);</span>
 370 
 371                 if (dashes != null) {
 372                     recycleDashes = true;
 373                     dashLen = dashes.length;
 374                     dashes = rdrCtx.dasher.copyDashArray(dashes);
 375                     for (int i = 0; i &lt; dashLen; i++) {
 376                         dashes[i] *= scale;
 377                     }
 378                     dashphase *= scale;
 379                 }
 380                 width *= scale;
 381 
 382                 // by now strokerat == null. Input paths to
 383                 // stroker (and maybe dasher) will have the full transform at
 384                 // applied to them and nothing will happen to the output paths.
 385             } else {
 386                 strokerat = at;
 387 
 388                 // by now strokerat == at. Input paths to
 389                 // stroker (and maybe dasher) will have the full transform at
 390                 // applied to them, then they will be normalized, and then
 391                 // the inverse of *only the non translation part of at* will
 392                 // be applied to the normalized paths. This won't cause problems
 393                 // in stroker, because, suppose at = T*A, where T is just the
 394                 // translation part of at, and A is the rest. T*A has already
 395                 // been applied to Stroker/Dasher's input. Then Ainv will be
 396                 // applied. Ainv*T*A is not equal to T, but it is a translation,
 397                 // which means that none of stroker's assumptions about its
 398                 // input will be violated. After all this, A will be applied
 399                 // to stroker's output.
 400             }
 401         } else {
 402             // either at is null or it's the identity. In either case
 403             // we don't transform the path.
 404             at = null;
 405         }
 406 
 407         final TransformingPathConsumer2D transformerPC2D = rdrCtx.transformerPC2D;
 408 
 409         if (DO_TRACE_PATH) {
 410             // trace Stroker:
 411             pc2d = transformerPC2D.traceStroker(pc2d);
 412         }
 413 
 414         if (USE_SIMPLIFIER) {
 415             // Use simplifier after stroker before Renderer
 416             // to remove collinear segments (notably due to cap square)
 417             pc2d = rdrCtx.simplifier.init(pc2d);
 418         }
 419 
 420         // deltaTransformConsumer may adjust the clip rectangle:
 421         pc2d = transformerPC2D.deltaTransformConsumer(pc2d, strokerat);
 422 
 423         // stroker will adjust the clip rectangle (width / miter limit):
<a name="4" id="anc4"></a><span class="changed"> 424         pc2d = rdrCtx.stroker.init(pc2d, width, caps, join, miterlimit,</span>
 425                 (dashes == null));
 426 
 427         // Curve Monotizer:
 428         rdrCtx.monotonizer.init(width);
 429 
 430         if (dashes != null) {
 431             if (!recycleDashes) {
 432                 dashLen = dashes.length;
 433             }
 434             if (DO_TRACE_PATH) {
 435                 pc2d = transformerPC2D.traceDasher(pc2d);
 436             }
 437             pc2d = rdrCtx.dasher.init(pc2d, dashes, dashLen, dashphase,
 438                                       recycleDashes);
 439 
 440             if (DISABLE_2ND_STROKER_CLIPPING) {
 441                 // disable stoker clipping
 442                 rdrCtx.stroker.disableClipping();
 443             }
 444 
 445         } else if (rdrCtx.doClip &amp;&amp; (caps != Stroker.CAP_BUTT)) {
 446             if (DO_TRACE_PATH) {
 447                 pc2d = transformerPC2D.traceClosedPathDetector(pc2d);
 448             }
 449 
 450             // If no dash and clip is enabled:
 451             // detect closedPaths (polygons) for caps
 452             pc2d = transformerPC2D.detectClosedPath(pc2d);
 453         }
 454         pc2d = transformerPC2D.inverseDeltaTransformConsumer(pc2d, strokerat);
 455 
 456         if (DO_TRACE_PATH) {
 457             // trace Input:
 458             pc2d = transformerPC2D.traceInput(pc2d);
 459         }
 460 
 461         final PathIterator pi = norm.getNormalizingPathIterator(rdrCtx,
 462                                          src.getPathIterator(at));
 463 
 464         pathTo(rdrCtx, pi, pc2d);
 465 
 466         /*
 467          * Pipeline seems to be:
 468          * shape.getPathIterator(at)
 469          * -&gt; (NormalizingPathIterator)
 470          * -&gt; (inverseDeltaTransformConsumer)
 471          * -&gt; (Dasher)
 472          * -&gt; Stroker
 473          * -&gt; (deltaTransformConsumer)
 474          *
 475          * -&gt; (CollinearSimplifier) to remove redundant segments
 476          *
 477          * -&gt; pc2d = Renderer (bounding box)
 478          */
 479     }
 480 
 481     private static boolean nearZero(final double num) {
 482         return Math.abs(num) &lt; 2.0d * Math.ulp(num);
 483     }
 484 
 485     abstract static class NormalizingPathIterator implements PathIterator {
 486 
 487         private PathIterator src;
 488 
 489         // the adjustment applied to the current position.
 490         private float curx_adjust, cury_adjust;
 491         // the adjustment applied to the last moveTo position.
 492         private float movx_adjust, movy_adjust;
 493 
 494         private final float[] tmp;
 495 
 496         NormalizingPathIterator(final float[] tmp) {
 497             this.tmp = tmp;
 498         }
 499 
 500         final NormalizingPathIterator init(final PathIterator src) {
 501             this.src = src;
 502             return this; // fluent API
 503         }
 504 
 505         /**
 506          * Disposes this path iterator:
 507          * clean up before reusing this instance
 508          */
 509         final void dispose() {
 510             // free source PathIterator:
 511             this.src = null;
 512         }
 513 
 514         @Override
 515         public final int currentSegment(final float[] coords) {
 516             int lastCoord;
 517             final int type = src.currentSegment(coords);
 518 
 519             switch(type) {
 520                 case PathIterator.SEG_MOVETO:
 521                 case PathIterator.SEG_LINETO:
 522                     lastCoord = 0;
 523                     break;
 524                 case PathIterator.SEG_QUADTO:
 525                     lastCoord = 2;
 526                     break;
 527                 case PathIterator.SEG_CUBICTO:
 528                     lastCoord = 4;
 529                     break;
 530                 case PathIterator.SEG_CLOSE:
 531                     // we don't want to deal with this case later. We just exit now
 532                     curx_adjust = movx_adjust;
 533                     cury_adjust = movy_adjust;
 534                     return type;
 535                 default:
 536                     throw new InternalError("Unrecognized curve type");
 537             }
 538 
 539             // normalize endpoint
 540             float coord, x_adjust, y_adjust;
 541 
 542             coord = coords[lastCoord];
 543             x_adjust = normCoord(coord); // new coord
 544             coords[lastCoord] = x_adjust;
 545             x_adjust -= coord;
 546 
 547             coord = coords[lastCoord + 1];
 548             y_adjust = normCoord(coord); // new coord
 549             coords[lastCoord + 1] = y_adjust;
 550             y_adjust -= coord;
 551 
 552             // now that the end points are done, normalize the control points
 553             switch(type) {
 554                 case PathIterator.SEG_MOVETO:
 555                     movx_adjust = x_adjust;
 556                     movy_adjust = y_adjust;
 557                     break;
 558                 case PathIterator.SEG_LINETO:
 559                     break;
 560                 case PathIterator.SEG_QUADTO:
 561                     coords[0] += (curx_adjust + x_adjust) / 2.0f;
 562                     coords[1] += (cury_adjust + y_adjust) / 2.0f;
 563                     break;
 564                 case PathIterator.SEG_CUBICTO:
 565                     coords[0] += curx_adjust;
 566                     coords[1] += cury_adjust;
 567                     coords[2] += x_adjust;
 568                     coords[3] += y_adjust;
 569                     break;
 570                 case PathIterator.SEG_CLOSE:
 571                     // handled earlier
 572                 default:
 573             }
 574             curx_adjust = x_adjust;
 575             cury_adjust = y_adjust;
 576             return type;
 577         }
 578 
 579         abstract float normCoord(final float coord);
 580 
 581         @Override
 582         public final int currentSegment(final double[] coords) {
 583             final float[] _tmp = tmp; // dirty
 584             int type = this.currentSegment(_tmp);
 585             for (int i = 0; i &lt; 6; i++) {
 586                 coords[i] = _tmp[i];
 587             }
 588             return type;
 589         }
 590 
 591         @Override
 592         public final int getWindingRule() {
 593             return src.getWindingRule();
 594         }
 595 
 596         @Override
 597         public final boolean isDone() {
 598             if (src.isDone()) {
 599                 // Dispose this instance:
 600                 dispose();
 601                 return true;
 602             }
 603             return false;
 604         }
 605 
 606         @Override
 607         public final void next() {
 608             src.next();
 609         }
 610 
 611         static final class NearestPixelCenter
 612                                 extends NormalizingPathIterator
 613         {
 614             NearestPixelCenter(final float[] tmp) {
 615                 super(tmp);
 616             }
 617 
 618             @Override
 619             float normCoord(final float coord) {
 620                 // round to nearest pixel center
 621                 return FloatMath.floor_f(coord) + 0.5f;
 622             }
 623         }
 624 
 625         static final class NearestPixelQuarter
 626                                 extends NormalizingPathIterator
 627         {
 628             NearestPixelQuarter(final float[] tmp) {
 629                 super(tmp);
 630             }
 631 
 632             @Override
 633             float normCoord(final float coord) {
 634                 // round to nearest (0.25, 0.25) pixel quarter
 635                 return FloatMath.floor_f(coord + 0.25f) + 0.25f;
 636             }
 637         }
 638     }
 639 
 640     private static void pathTo(final RendererContext rdrCtx, final PathIterator pi,
 641                                PathConsumer2D pc2d)
 642     {
 643         if (USE_PATH_SIMPLIFIER) {
 644             // Use path simplifier at the first step
 645             // to remove useless points
 646             pc2d = rdrCtx.pathSimplifier.init(pc2d);
 647         }
 648 
 649         // mark context as DIRTY:
 650         rdrCtx.dirty = true;
 651 
 652         pathToLoop(rdrCtx.float6, pi, pc2d);
 653 
 654         // mark context as CLEAN:
 655         rdrCtx.dirty = false;
 656     }
 657 
 658     private static void pathToLoop(final float[] coords, final PathIterator pi,
 659                                    final PathConsumer2D pc2d)
 660     {
 661         // ported from DuctusRenderingEngine.feedConsumer() but simplified:
 662         // - removed skip flag = !subpathStarted
 663         // - removed pathClosed (ie subpathStarted not set to false)
 664         boolean subpathStarted = false;
 665 
 666         for (; !pi.isDone(); pi.next()) {
 667             switch (pi.currentSegment(coords)) {
 668             case PathIterator.SEG_MOVETO:
 669                 /* Checking SEG_MOVETO coordinates if they are out of the
 670                  * [LOWER_BND, UPPER_BND] range. This check also handles NaN
 671                  * and Infinity values. Skipping next path segment in case of
 672                  * invalid data.
 673                  */
 674                 if (coords[0] &lt; UPPER_BND &amp;&amp; coords[0] &gt; LOWER_BND &amp;&amp;
 675                     coords[1] &lt; UPPER_BND &amp;&amp; coords[1] &gt; LOWER_BND)
 676                 {
 677                     pc2d.moveTo(coords[0], coords[1]);
 678                     subpathStarted = true;
 679                 }
 680                 break;
 681             case PathIterator.SEG_LINETO:
 682                 /* Checking SEG_LINETO coordinates if they are out of the
 683                  * [LOWER_BND, UPPER_BND] range. This check also handles NaN
 684                  * and Infinity values. Ignoring current path segment in case
 685                  * of invalid data. If segment is skipped its endpoint
 686                  * (if valid) is used to begin new subpath.
 687                  */
 688                 if (coords[0] &lt; UPPER_BND &amp;&amp; coords[0] &gt; LOWER_BND &amp;&amp;
 689                     coords[1] &lt; UPPER_BND &amp;&amp; coords[1] &gt; LOWER_BND)
 690                 {
 691                     if (subpathStarted) {
 692                         pc2d.lineTo(coords[0], coords[1]);
 693                     } else {
 694                         pc2d.moveTo(coords[0], coords[1]);
 695                         subpathStarted = true;
 696                     }
 697                 }
 698                 break;
 699             case PathIterator.SEG_QUADTO:
 700                 // Quadratic curves take two points
 701                 /* Checking SEG_QUADTO coordinates if they are out of the
 702                  * [LOWER_BND, UPPER_BND] range. This check also handles NaN
 703                  * and Infinity values. Ignoring current path segment in case
 704                  * of invalid endpoints's data. Equivalent to the SEG_LINETO
 705                  * if endpoint coordinates are valid but there are invalid data
 706                  * among other coordinates
 707                  */
 708                 if (coords[2] &lt; UPPER_BND &amp;&amp; coords[2] &gt; LOWER_BND &amp;&amp;
 709                     coords[3] &lt; UPPER_BND &amp;&amp; coords[3] &gt; LOWER_BND)
 710                 {
 711                     if (subpathStarted) {
 712                         if (coords[0] &lt; UPPER_BND &amp;&amp; coords[0] &gt; LOWER_BND &amp;&amp;
 713                             coords[1] &lt; UPPER_BND &amp;&amp; coords[1] &gt; LOWER_BND)
 714                         {
 715                             pc2d.quadTo(coords[0], coords[1],
 716                                         coords[2], coords[3]);
 717                         } else {
 718                             pc2d.lineTo(coords[2], coords[3]);
 719                         }
 720                     } else {
 721                         pc2d.moveTo(coords[2], coords[3]);
 722                         subpathStarted = true;
 723                     }
 724                 }
 725                 break;
 726             case PathIterator.SEG_CUBICTO:
 727                 // Cubic curves take three points
 728                 /* Checking SEG_CUBICTO coordinates if they are out of the
 729                  * [LOWER_BND, UPPER_BND] range. This check also handles NaN
 730                  * and Infinity values. Ignoring current path segment in case
 731                  * of invalid endpoints's data. Equivalent to the SEG_LINETO
 732                  * if endpoint coordinates are valid but there are invalid data
 733                  * among other coordinates
 734                  */
 735                 if (coords[4] &lt; UPPER_BND &amp;&amp; coords[4] &gt; LOWER_BND &amp;&amp;
 736                     coords[5] &lt; UPPER_BND &amp;&amp; coords[5] &gt; LOWER_BND)
 737                 {
 738                     if (subpathStarted) {
 739                         if (coords[0] &lt; UPPER_BND &amp;&amp; coords[0] &gt; LOWER_BND &amp;&amp;
 740                             coords[1] &lt; UPPER_BND &amp;&amp; coords[1] &gt; LOWER_BND &amp;&amp;
 741                             coords[2] &lt; UPPER_BND &amp;&amp; coords[2] &gt; LOWER_BND &amp;&amp;
 742                             coords[3] &lt; UPPER_BND &amp;&amp; coords[3] &gt; LOWER_BND)
 743                         {
 744                             pc2d.curveTo(coords[0], coords[1],
 745                                          coords[2], coords[3],
 746                                          coords[4], coords[5]);
 747                         } else {
 748                             pc2d.lineTo(coords[4], coords[5]);
 749                         }
 750                     } else {
 751                         pc2d.moveTo(coords[4], coords[5]);
 752                         subpathStarted = true;
 753                     }
 754                 }
 755                 break;
 756             case PathIterator.SEG_CLOSE:
 757                 if (subpathStarted) {
 758                     pc2d.closePath();
 759                     // do not set subpathStarted to false
 760                     // in case of missing moveTo() after close()
 761                 }
 762                 break;
 763             default:
 764             }
 765         }
 766         pc2d.pathDone();
 767     }
 768 
 769     /**
 770      * Construct an antialiased tile generator for the given shape with
 771      * the given rendering attributes and store the bounds of the tile
 772      * iteration in the bbox parameter.
 773      * The {@code at} parameter specifies a transform that should affect
 774      * both the shape and the {@code BasicStroke} attributes.
 775      * The {@code clip} parameter specifies the current clip in effect
 776      * in device coordinates and can be used to prune the data for the
 777      * operation, but the renderer is not required to perform any
 778      * clipping.
 779      * If the {@code BasicStroke} parameter is null then the shape
 780      * should be filled as is, otherwise the attributes of the
 781      * {@code BasicStroke} should be used to specify a draw operation.
 782      * The {@code thin} parameter indicates whether or not the
 783      * transformed {@code BasicStroke} represents coordinates smaller
 784      * than the minimum resolution of the antialiasing rasterizer as
 785      * specified by the {@code getMinimumAAPenWidth()} method.
 786      * &lt;p&gt;
 787      * Upon returning, this method will fill the {@code bbox} parameter
 788      * with 4 values indicating the bounds of the iteration of the
 789      * tile generator.
 790      * The iteration order of the tiles will be as specified by the
 791      * pseudo-code:
 792      * &lt;pre&gt;
 793      *     for (y = bbox[1]; y &lt; bbox[3]; y += tileheight) {
 794      *         for (x = bbox[0]; x &lt; bbox[2]; x += tilewidth) {
 795      *         }
 796      *     }
 797      * &lt;/pre&gt;
 798      * If there is no output to be rendered, this method may return
 799      * null.
 800      *
 801      * @param s the shape to be rendered (fill or draw)
 802      * @param at the transform to be applied to the shape and the
 803      *           stroke attributes
 804      * @param clip the current clip in effect in device coordinates
 805      * @param bs if non-null, a {@code BasicStroke} whose attributes
 806      *           should be applied to this operation
 807      * @param thin true if the transformed stroke attributes are smaller
 808      *             than the minimum dropout pen width
 809      * @param normalize true if the {@code VALUE_STROKE_NORMALIZE}
 810      *                  {@code RenderingHint} is in effect
 811      * @param bbox returns the bounds of the iteration
 812      * @return the {@code AATileGenerator} instance to be consulted
 813      *         for tile coverages, or null if there is no output to render
 814      * @since 1.7
 815      */
 816     @Override
 817     public AATileGenerator getAATileGenerator(Shape s,
 818                                               AffineTransform at,
 819                                               Region clip,
 820                                               BasicStroke bs,
 821                                               boolean thin,
 822                                               boolean normalize,
 823                                               int[] bbox)
 824     {
 825         MarlinTileGenerator ptg = null;
 826         Renderer r = null;
 827 
 828         final RendererContext rdrCtx = getRendererContext();
 829         try {
 830             if (DO_CLIP || (DO_CLIP_RUNTIME_ENABLE &amp;&amp; MarlinProperties.isDoClipAtRuntime())) {
 831                 // Define the initial clip bounds:
 832                 final float[] clipRect = rdrCtx.clipRect;
 833 
<a name="5" id="anc5"></a><span class="changed"> 834                 // Adjust the clipping rectangle with the renderer offsets</span>
<span class="changed"> 835                 final float rdrOffX = Renderer.RDR_OFFSET_X;</span>
<span class="changed"> 836                 final float rdrOffY = Renderer.RDR_OFFSET_Y;</span>
<span class="changed"> 837 </span>
<span class="changed"> 838                 // add a small rounding error:</span>
<span class="changed"> 839                 final float margin = 1e-3f;</span>
<span class="changed"> 840 </span>
<span class="changed"> 841                 clipRect[0] = clip.getLoY()</span>
<span class="changed"> 842                                 - margin + rdrOffY;</span>
<span class="changed"> 843                 clipRect[1] = clip.getLoY() + clip.getHeight()</span>
<span class="changed"> 844                                 + margin + rdrOffY;</span>
<span class="changed"> 845                 clipRect[2] = clip.getLoX()</span>
<span class="changed"> 846                                 - margin + rdrOffX;</span>
<span class="changed"> 847                 clipRect[3] = clip.getLoX() + clip.getWidth()</span>
<span class="changed"> 848                                 + margin + rdrOffX;</span>
<span class="changed"> 849 </span>
<span class="changed"> 850                 if (MarlinConst.DO_LOG_CLIP) {</span>
<span class="changed"> 851                     MarlinUtils.logInfo("clipRect (clip): "</span>
<span class="changed"> 852                                         + Arrays.toString(rdrCtx.clipRect));</span>
<span class="changed"> 853                 }</span>
 854 
 855                 // Enable clipping:
 856                 rdrCtx.doClip = true;
 857             }
 858 
 859             // Test if at is identity:
 860             final AffineTransform _at = (at != null &amp;&amp; !at.isIdentity()) ? at
 861                                         : null;
 862 
 863             final NormMode norm = (normalize) ? NormMode.ON_WITH_AA : NormMode.OFF;
 864 
 865             if (bs == null) {
 866                 // fill shape:
 867                 final PathIterator pi = norm.getNormalizingPathIterator(rdrCtx,
 868                                                  s.getPathIterator(_at));
 869 
 870                 // note: Winding rule may be EvenOdd ONLY for fill operations !
 871                 r = rdrCtx.renderer.init(clip.getLoX(), clip.getLoY(),
 872                                          clip.getWidth(), clip.getHeight(),
 873                                          pi.getWindingRule());
 874 
 875                 PathConsumer2D pc2d = r;
 876 
 877                 if (DO_CLIP_FILL &amp;&amp; rdrCtx.doClip) {
 878                     if (DO_TRACE_PATH) {
 879                         // trace Filler:
 880                         pc2d = rdrCtx.transformerPC2D.traceFiller(pc2d);
 881                     }
 882                     pc2d = rdrCtx.transformerPC2D.pathClipper(pc2d);
 883                 }
 884 
 885                 if (DO_TRACE_PATH) {
 886                     // trace Input:
 887                     pc2d = rdrCtx.transformerPC2D.traceInput(pc2d);
 888                 }
 889                 pathTo(rdrCtx, pi, pc2d);
 890 
 891             } else {
 892                 // draw shape with given stroke:
 893                 r = rdrCtx.renderer.init(clip.getLoX(), clip.getLoY(),
 894                                          clip.getWidth(), clip.getHeight(),
 895                                          WIND_NON_ZERO);
 896 
 897                 strokeTo(rdrCtx, s, _at, bs, thin, norm, true, r);
 898             }
 899             if (r.endRendering()) {
 900                 ptg = rdrCtx.ptg.init();
 901                 ptg.getBbox(bbox);
 902                 // note: do not returnRendererContext(rdrCtx)
 903                 // as it will be called later by MarlinTileGenerator.dispose()
 904                 r = null;
 905             }
 906         } finally {
 907             if (r != null) {
 908                 // dispose renderer and recycle the RendererContext instance:
 909                 r.dispose();
 910             }
 911         }
 912 
 913         // Return null to cancel AA tile generation (nothing to render)
 914         return ptg;
 915     }
 916 
 917     @Override
 918     public AATileGenerator getAATileGenerator(double x, double y,
 919                                               double dx1, double dy1,
 920                                               double dx2, double dy2,
 921                                               double lw1, double lw2,
 922                                               Region clip,
 923                                               int[] bbox)
 924     {
 925         // REMIND: Deal with large coordinates!
 926         double ldx1, ldy1, ldx2, ldy2;
 927         boolean innerpgram = (lw1 &gt; 0.0d &amp;&amp; lw2 &gt; 0.0d);
 928 
 929         if (innerpgram) {
 930             ldx1 = dx1 * lw1;
 931             ldy1 = dy1 * lw1;
 932             ldx2 = dx2 * lw2;
 933             ldy2 = dy2 * lw2;
 934             x -= (ldx1 + ldx2) / 2.0d;
 935             y -= (ldy1 + ldy2) / 2.0d;
 936             dx1 += ldx1;
 937             dy1 += ldy1;
 938             dx2 += ldx2;
 939             dy2 += ldy2;
 940             if (lw1 &gt; 1.0d &amp;&amp; lw2 &gt; 1.0d) {
 941                 // Inner parallelogram was entirely consumed by stroke...
 942                 innerpgram = false;
 943             }
 944         } else {
 945             ldx1 = ldy1 = ldx2 = ldy2 = 0.0d;
 946         }
 947 
 948         MarlinTileGenerator ptg = null;
 949         Renderer r = null;
 950 
 951         final RendererContext rdrCtx = getRendererContext();
 952         try {
 953             r = rdrCtx.renderer.init(clip.getLoX(), clip.getLoY(),
 954                                      clip.getWidth(), clip.getHeight(),
 955                                      WIND_EVEN_ODD);
 956 
 957             r.moveTo((float) x, (float) y);
 958             r.lineTo((float) (x+dx1), (float) (y+dy1));
 959             r.lineTo((float) (x+dx1+dx2), (float) (y+dy1+dy2));
 960             r.lineTo((float) (x+dx2), (float) (y+dy2));
 961             r.closePath();
 962 
 963             if (innerpgram) {
 964                 x += ldx1 + ldx2;
 965                 y += ldy1 + ldy2;
 966                 dx1 -= 2.0d * ldx1;
 967                 dy1 -= 2.0d * ldy1;
 968                 dx2 -= 2.0d * ldx2;
 969                 dy2 -= 2.0d * ldy2;
 970                 r.moveTo((float) x, (float) y);
 971                 r.lineTo((float) (x+dx1), (float) (y+dy1));
 972                 r.lineTo((float) (x+dx1+dx2), (float) (y+dy1+dy2));
 973                 r.lineTo((float) (x+dx2), (float) (y+dy2));
 974                 r.closePath();
 975             }
 976             r.pathDone();
 977 
 978             if (r.endRendering()) {
 979                 ptg = rdrCtx.ptg.init();
 980                 ptg.getBbox(bbox);
 981                 // note: do not returnRendererContext(rdrCtx)
 982                 // as it will be called later by MarlinTileGenerator.dispose()
 983                 r = null;
 984             }
 985         } finally {
 986             if (r != null) {
 987                 // dispose renderer and recycle the RendererContext instance:
 988                 r.dispose();
 989             }
 990         }
 991 
 992         // Return null to cancel AA tile generation (nothing to render)
 993         return ptg;
 994     }
 995 
 996     /**
 997      * Returns the minimum pen width that the antialiasing rasterizer
 998      * can represent without dropouts occuring.
 999      * @since 1.7
1000      */
1001     @Override
1002     public float getMinimumAAPenSize() {
1003         return MIN_PEN_SIZE;
1004     }
1005 
1006     static {
1007         if (PathIterator.WIND_NON_ZERO != WIND_NON_ZERO ||
1008             PathIterator.WIND_EVEN_ODD != WIND_EVEN_ODD ||
1009             BasicStroke.JOIN_MITER != JOIN_MITER ||
1010             BasicStroke.JOIN_ROUND != JOIN_ROUND ||
1011             BasicStroke.JOIN_BEVEL != JOIN_BEVEL ||
1012             BasicStroke.CAP_BUTT != CAP_BUTT ||
1013             BasicStroke.CAP_ROUND != CAP_ROUND ||
1014             BasicStroke.CAP_SQUARE != CAP_SQUARE)
1015         {
1016             throw new InternalError("mismatched renderer constants");
1017         }
1018     }
1019 
1020     // --- RendererContext handling ---
1021     // use ThreadLocal or ConcurrentLinkedQueue to get one RendererContext
1022     private static final boolean USE_THREAD_LOCAL;
1023 
1024     // reference type stored in either TL or CLQ
1025     static final int REF_TYPE;
1026 
1027     // Per-thread RendererContext
1028     private static final ReentrantContextProvider&lt;RendererContext&gt; RDR_CTX_PROVIDER;
1029 
1030     // Static initializer to use TL or CLQ mode
1031     static {
1032         USE_THREAD_LOCAL = MarlinProperties.isUseThreadLocal();
1033 
1034         // Soft reference by default:
1035         final String refType = AccessController.doPrivileged(
1036                             new GetPropertyAction("sun.java2d.renderer.useRef",
1037                             "soft"));
1038         switch (refType) {
1039             default:
1040             case "soft":
1041                 REF_TYPE = ReentrantContextProvider.REF_SOFT;
1042                 break;
1043             case "weak":
1044                 REF_TYPE = ReentrantContextProvider.REF_WEAK;
1045                 break;
1046             case "hard":
1047                 REF_TYPE = ReentrantContextProvider.REF_HARD;
1048                 break;
1049         }
1050 
1051         if (USE_THREAD_LOCAL) {
1052             RDR_CTX_PROVIDER = new ReentrantContextProviderTL&lt;RendererContext&gt;(REF_TYPE)
1053                 {
1054                     @Override
1055                     protected RendererContext newContext() {
1056                         return RendererContext.createContext();
1057                     }
1058                 };
1059         } else {
1060             RDR_CTX_PROVIDER = new ReentrantContextProviderCLQ&lt;RendererContext&gt;(REF_TYPE)
1061                 {
1062                     @Override
1063                     protected RendererContext newContext() {
1064                         return RendererContext.createContext();
1065                     }
1066                 };
1067         }
1068     }
1069 
1070     private static boolean SETTINGS_LOGGED = !ENABLE_LOGS;
1071 
1072     private static void logSettings(final String reClass) {
1073         // log information at startup
1074         if (SETTINGS_LOGGED) {
1075             return;
1076         }
1077         SETTINGS_LOGGED = true;
1078 
1079         String refType;
1080         switch (REF_TYPE) {
1081             default:
1082             case ReentrantContextProvider.REF_HARD:
1083                 refType = "hard";
1084                 break;
1085             case ReentrantContextProvider.REF_SOFT:
1086                 refType = "soft";
1087                 break;
1088             case ReentrantContextProvider.REF_WEAK:
1089                 refType = "weak";
1090                 break;
1091         }
1092 
1093         logInfo("=========================================================="
1094                 + "=====================");
1095 
1096         logInfo("Marlin software rasterizer           = ENABLED");
1097         logInfo("Version                              = ["
1098                 + Version.getVersion() + "]");
1099         logInfo("sun.java2d.renderer                  = "
1100                 + reClass);
1101         logInfo("sun.java2d.renderer.useThreadLocal   = "
1102                 + USE_THREAD_LOCAL);
1103         logInfo("sun.java2d.renderer.useRef           = "
1104                 + refType);
1105 
1106         logInfo("sun.java2d.renderer.edges            = "
1107                 + MarlinConst.INITIAL_EDGES_COUNT);
1108         logInfo("sun.java2d.renderer.pixelWidth       = "
1109                 + MarlinConst.INITIAL_PIXEL_WIDTH);
1110         logInfo("sun.java2d.renderer.pixelHeight      = "
1111                 + MarlinConst.INITIAL_PIXEL_HEIGHT);
1112 
1113         logInfo("sun.java2d.renderer.subPixel_log2_X  = "
1114                 + MarlinConst.SUBPIXEL_LG_POSITIONS_X);
1115         logInfo("sun.java2d.renderer.subPixel_log2_Y  = "
1116                 + MarlinConst.SUBPIXEL_LG_POSITIONS_Y);
1117 
1118         logInfo("sun.java2d.renderer.tileSize_log2    = "
1119                 + MarlinConst.TILE_H_LG);
1120         logInfo("sun.java2d.renderer.tileWidth_log2   = "
1121                 + MarlinConst.TILE_W_LG);
1122         logInfo("sun.java2d.renderer.blockSize_log2   = "
1123                 + MarlinConst.BLOCK_SIZE_LG);
1124 
1125         // RLE / blockFlags settings
1126 
1127         logInfo("sun.java2d.renderer.forceRLE         = "
1128                 + MarlinProperties.isForceRLE());
1129         logInfo("sun.java2d.renderer.forceNoRLE       = "
1130                 + MarlinProperties.isForceNoRLE());
1131         logInfo("sun.java2d.renderer.useTileFlags     = "
1132                 + MarlinProperties.isUseTileFlags());
1133         logInfo("sun.java2d.renderer.useTileFlags.useHeuristics = "
1134                 + MarlinProperties.isUseTileFlagsWithHeuristics());
1135         logInfo("sun.java2d.renderer.rleMinWidth      = "
1136                 + MarlinCache.RLE_MIN_WIDTH);
1137 
1138         // optimisation parameters
1139         logInfo("sun.java2d.renderer.useSimplifier    = "
1140                 + MarlinConst.USE_SIMPLIFIER);
1141         logInfo("sun.java2d.renderer.usePathSimplifier= "
1142                 + MarlinConst.USE_PATH_SIMPLIFIER);
1143         logInfo("sun.java2d.renderer.pathSimplifier.pixTol = "
1144                 + MarlinProperties.getPathSimplifierPixelTolerance());
1145 
1146         logInfo("sun.java2d.renderer.clip             = "
1147                 + MarlinProperties.isDoClip());
1148         logInfo("sun.java2d.renderer.clip.runtime.enable = "
1149                 + MarlinProperties.isDoClipRuntimeFlag());
1150 
1151         logInfo("sun.java2d.renderer.clip.subdivider  = "
1152                 + MarlinProperties.isDoClipSubdivider());
1153         logInfo("sun.java2d.renderer.clip.subdivider.minLength = "
1154                 + MarlinProperties.getSubdividerMinLength());
1155 
1156         // debugging parameters
1157         logInfo("sun.java2d.renderer.doStats          = "
1158                 + MarlinConst.DO_STATS);
1159         logInfo("sun.java2d.renderer.doMonitors       = "
1160                 + MarlinConst.DO_MONITORS);
1161         logInfo("sun.java2d.renderer.doChecks         = "
1162                 + MarlinConst.DO_CHECKS);
1163 
1164         // logging parameters
1165         logInfo("sun.java2d.renderer.useLogger        = "
1166                 + MarlinConst.USE_LOGGER);
1167         logInfo("sun.java2d.renderer.logCreateContext = "
1168                 + MarlinConst.LOG_CREATE_CONTEXT);
1169         logInfo("sun.java2d.renderer.logUnsafeMalloc  = "
1170                 + MarlinConst.LOG_UNSAFE_MALLOC);
1171 
1172         // quality settings
1173         logInfo("sun.java2d.renderer.curve_len_err    = "
1174                 + MarlinProperties.getCurveLengthError());
1175         logInfo("sun.java2d.renderer.cubic_dec_d2     = "
1176                 + MarlinProperties.getCubicDecD2());
1177         logInfo("sun.java2d.renderer.cubic_inc_d1     = "
1178                 + MarlinProperties.getCubicIncD1());
1179         logInfo("sun.java2d.renderer.quad_dec_d2      = "
1180                 + MarlinProperties.getQuadDecD2());
1181 
1182         logInfo("Renderer settings:");
1183         logInfo("CUB_DEC_BND  = " + Renderer.CUB_DEC_BND);
1184         logInfo("CUB_INC_BND  = " + Renderer.CUB_INC_BND);
1185         logInfo("QUAD_DEC_BND = " + Renderer.QUAD_DEC_BND);
1186 
1187         logInfo("INITIAL_EDGES_CAPACITY               = "
1188                 + MarlinConst.INITIAL_EDGES_CAPACITY);
1189         logInfo("INITIAL_CROSSING_COUNT               = "
1190                 + Renderer.INITIAL_CROSSING_COUNT);
1191 
1192         logInfo("=========================================================="
1193                 + "=====================");
1194     }
1195 
1196     /**
1197      * Get the RendererContext instance dedicated to the current thread
1198      * @return RendererContext instance
1199      */
1200     @SuppressWarnings({"unchecked"})
1201     static RendererContext getRendererContext() {
1202         final RendererContext rdrCtx = RDR_CTX_PROVIDER.acquire();
1203         if (DO_MONITORS) {
1204             rdrCtx.stats.mon_pre_getAATileGenerator.start();
1205         }
1206         return rdrCtx;
1207     }
1208 
1209     /**
1210      * Reset and return the given RendererContext instance for reuse
1211      * @param rdrCtx RendererContext instance
1212      */
1213     static void returnRendererContext(final RendererContext rdrCtx) {
1214         rdrCtx.dispose();
1215 
1216         if (DO_MONITORS) {
1217             rdrCtx.stats.mon_pre_getAATileGenerator.stop();
1218         }
1219         RDR_CTX_PROVIDER.release(rdrCtx);
1220     }
1221 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="6" type="hidden" /></form></body></html>
