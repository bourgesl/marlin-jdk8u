<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-13698">13698</a> : <a href="https://bugs.openjdk.java.net/browse/JDK-8210335">8210335</a>: Clipping problems with complex affine transforms: negative scaling factors or small scaling factors
Summary: fixed clipping rectangle to take into account the inverse transform (scale/shear)
Reviewed-by: prr, serb</pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the "Classpath" exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.java2d.marlin;
  27 
  28 import java.awt.BasicStroke;
  29 import java.awt.Shape;
  30 import java.awt.geom.AffineTransform;
  31 import java.awt.geom.Path2D;
  32 import java.awt.geom.PathIterator;
  33 import java.security.AccessController;
<a name="1" id="anc1"></a><span class="new">  34 import java.util.Arrays;</span>
  35 import sun.awt.geom.PathConsumer2D;
  36 import static sun.java2d.marlin.MarlinUtils.logInfo;
  37 import sun.java2d.ReentrantContextProvider;
  38 import sun.java2d.ReentrantContextProviderCLQ;
  39 import sun.java2d.ReentrantContextProviderTL;
  40 import sun.java2d.pipe.AATileGenerator;
  41 import sun.java2d.pipe.Region;
  42 import sun.java2d.pipe.RenderingEngine;
  43 import sun.security.action.GetPropertyAction;
  44 
  45 /**
  46  * Marlin RendererEngine implementation (derived from Pisces)
  47  */
  48 public final class DMarlinRenderingEngine extends RenderingEngine
  49                                           implements MarlinConst
  50 {
  51     // slightly slower ~2% if enabled stroker clipping (lines) but skipping cap / join handling is few percents faster in specific cases
  52     static final boolean DISABLE_2ND_STROKER_CLIPPING = true;
  53 
  54     static final boolean DO_TRACE_PATH = false;
  55 
  56     static final boolean DO_CLIP = MarlinProperties.isDoClip();
  57     static final boolean DO_CLIP_FILL = true;
  58     static final boolean DO_CLIP_RUNTIME_ENABLE = MarlinProperties.isDoClipRuntimeFlag();
  59 
  60     private static final float MIN_PEN_SIZE = 1.0f / MIN_SUBPIXELS;
  61 
  62     static final double UPPER_BND = Float.MAX_VALUE / 2.0d;
  63     static final double LOWER_BND = -UPPER_BND;
  64 
  65     private enum NormMode {
  66         ON_WITH_AA {
  67             @Override
  68             PathIterator getNormalizingPathIterator(final DRendererContext rdrCtx,
  69                                                     final PathIterator src)
  70             {
  71                 // NormalizingPathIterator NearestPixelCenter:
  72                 return rdrCtx.nPCPathIterator.init(src);
  73             }
  74         },
  75         ON_NO_AA{
  76             @Override
  77             PathIterator getNormalizingPathIterator(final DRendererContext rdrCtx,
  78                                                     final PathIterator src)
  79             {
  80                 // NearestPixel NormalizingPathIterator:
  81                 return rdrCtx.nPQPathIterator.init(src);
  82             }
  83         },
  84         OFF{
  85             @Override
  86             PathIterator getNormalizingPathIterator(final DRendererContext rdrCtx,
  87                                                     final PathIterator src)
  88             {
  89                 // return original path iterator if normalization is disabled:
  90                 return src;
  91             }
  92         };
  93 
  94         abstract PathIterator getNormalizingPathIterator(DRendererContext rdrCtx,
  95                                                          PathIterator src);
  96     }
  97 
  98     /**
  99      * Public constructor
 100      */
 101     public DMarlinRenderingEngine() {
 102         super();
 103         logSettings(DMarlinRenderingEngine.class.getName());
 104     }
 105 
 106     /**
 107      * Create a widened path as specified by the parameters.
 108      * &lt;p&gt;
 109      * The specified {@code src} {@link Shape} is widened according
 110      * to the specified attribute parameters as per the
 111      * {@link BasicStroke} specification.
 112      *
 113      * @param src the source path to be widened
 114      * @param width the width of the widened path as per {@code BasicStroke}
 115      * @param caps the end cap decorations as per {@code BasicStroke}
 116      * @param join the segment join decorations as per {@code BasicStroke}
 117      * @param miterlimit the miter limit as per {@code BasicStroke}
 118      * @param dashes the dash length array as per {@code BasicStroke}
 119      * @param dashphase the initial dash phase as per {@code BasicStroke}
 120      * @return the widened path stored in a new {@code Shape} object
 121      * @since 1.7
 122      */
 123     @Override
 124     public Shape createStrokedShape(Shape src,
 125                                     float width,
 126                                     int caps,
 127                                     int join,
 128                                     float miterlimit,
 129                                     float[] dashes,
 130                                     float dashphase)
 131     {
 132         final DRendererContext rdrCtx = getRendererContext();
 133         try {
 134             // initialize a large copyable Path2D to avoid a lot of array growing:
 135             final Path2D.Double p2d = rdrCtx.getPath2D();
 136 
 137             strokeTo(rdrCtx,
 138                      src,
 139                      null,
 140                      width,
 141                      NormMode.OFF,
 142                      caps,
 143                      join,
 144                      miterlimit,
 145                      dashes,
 146                      dashphase,
 147                      rdrCtx.transformerPC2D.wrapPath2D(p2d)
 148                     );
 149 
 150             // Use Path2D copy constructor (trim)
 151             return new Path2D.Double(p2d);
 152 
 153         } finally {
 154             // recycle the DRendererContext instance
 155             returnRendererContext(rdrCtx);
 156         }
 157     }
 158 
 159     /**
 160      * Sends the geometry for a widened path as specified by the parameters
 161      * to the specified consumer.
 162      * &lt;p&gt;
 163      * The specified {@code src} {@link Shape} is widened according
 164      * to the parameters specified by the {@link BasicStroke} object.
 165      * Adjustments are made to the path as appropriate for the
 166      * {@link java.awt.RenderingHints#VALUE_STROKE_NORMALIZE} hint if the
 167      * {@code normalize} boolean parameter is true.
 168      * Adjustments are made to the path as appropriate for the
 169      * {@link java.awt.RenderingHints#VALUE_ANTIALIAS_ON} hint if the
 170      * {@code antialias} boolean parameter is true.
 171      * &lt;p&gt;
 172      * The geometry of the widened path is forwarded to the indicated
 173      * {@link DPathConsumer2D} object as it is calculated.
 174      *
 175      * @param src the source path to be widened
 176      * @param bs the {@code BasicSroke} object specifying the
 177      *           decorations to be applied to the widened path
 178      * @param normalize indicates whether stroke normalization should
 179      *                  be applied
 180      * @param antialias indicates whether or not adjustments appropriate
 181      *                  to antialiased rendering should be applied
 182      * @param consumer the {@code DPathConsumer2D} instance to forward
 183      *                 the widened geometry to
 184      * @since 1.7
 185      */
 186     @Override
 187     public void strokeTo(Shape src,
 188                          AffineTransform at,
 189                          BasicStroke bs,
 190                          boolean thin,
 191                          boolean normalize,
 192                          boolean antialias,
 193                          final PathConsumer2D consumer)
 194     {
 195         final NormMode norm = (normalize) ?
 196                 ((antialias) ? NormMode.ON_WITH_AA : NormMode.ON_NO_AA)
 197                 : NormMode.OFF;
 198 
 199         final DRendererContext rdrCtx = getRendererContext();
 200         try {
 201             strokeTo(rdrCtx, src, at, bs, thin, norm, antialias,
 202                      rdrCtx.p2dAdapter.init(consumer));
 203         } finally {
 204             // recycle the DRendererContext instance
 205             returnRendererContext(rdrCtx);
 206         }
 207     }
 208 
 209     void strokeTo(final DRendererContext rdrCtx,
 210                   Shape src,
 211                   AffineTransform at,
 212                   BasicStroke bs,
 213                   boolean thin,
 214                   NormMode normalize,
 215                   boolean antialias,
 216                   DPathConsumer2D pc2d)
 217     {
 218         double lw;
 219         if (thin) {
 220             if (antialias) {
 221                 lw = userSpaceLineWidth(at, MIN_PEN_SIZE);
 222             } else {
 223                 lw = userSpaceLineWidth(at, 1.0d);
 224             }
 225         } else {
 226             lw = bs.getLineWidth();
 227         }
 228         strokeTo(rdrCtx,
 229                  src,
 230                  at,
 231                  lw,
 232                  normalize,
 233                  bs.getEndCap(),
 234                  bs.getLineJoin(),
 235                  bs.getMiterLimit(),
 236                  bs.getDashArray(),
 237                  bs.getDashPhase(),
 238                  pc2d);
 239     }
 240 
 241     private final double userSpaceLineWidth(AffineTransform at, double lw) {
 242 
 243         double widthScale;
 244 
 245         if (at == null) {
 246             widthScale = 1.0d;
 247         } else if ((at.getType() &amp; (AffineTransform.TYPE_GENERAL_TRANSFORM  |
 248                                     AffineTransform.TYPE_GENERAL_SCALE)) != 0) {
 249             widthScale = Math.sqrt(at.getDeterminant());
 250         } else {
 251             // First calculate the "maximum scale" of this transform.
 252             double A = at.getScaleX();       // m00
 253             double C = at.getShearX();       // m01
 254             double B = at.getShearY();       // m10
 255             double D = at.getScaleY();       // m11
 256 
 257             /*
 258              * Given a 2 x 2 affine matrix [ A B ] such that
 259              *                             [ C D ]
 260              * v' = [x' y'] = [Ax + Cy, Bx + Dy], we want to
 261              * find the maximum magnitude (norm) of the vector v'
 262              * with the constraint (x^2 + y^2 = 1).
 263              * The equation to maximize is
 264              *     |v'| = sqrt((Ax+Cy)^2+(Bx+Dy)^2)
 265              * or  |v'| = sqrt((AA+BB)x^2 + 2(AC+BD)xy + (CC+DD)y^2).
 266              * Since sqrt is monotonic we can maximize |v'|^2
 267              * instead and plug in the substitution y = sqrt(1 - x^2).
 268              * Trigonometric equalities can then be used to get
 269              * rid of most of the sqrt terms.
 270              */
 271 
 272             double EA = A*A + B*B;          // x^2 coefficient
 273             double EB = 2.0d * (A*C + B*D); // xy coefficient
 274             double EC = C*C + D*D;          // y^2 coefficient
 275 
 276             /*
 277              * There is a lot of calculus omitted here.
 278              *
 279              * Conceptually, in the interests of understanding the
 280              * terms that the calculus produced we can consider
 281              * that EA and EC end up providing the lengths along
 282              * the major axes and the hypot term ends up being an
 283              * adjustment for the additional length along the off-axis
 284              * angle of rotated or sheared ellipses as well as an
 285              * adjustment for the fact that the equation below
 286              * averages the two major axis lengths.  (Notice that
 287              * the hypot term contains a part which resolves to the
 288              * difference of these two axis lengths in the absence
 289              * of rotation.)
 290              *
 291              * In the calculus, the ratio of the EB and (EA-EC) terms
 292              * ends up being the tangent of 2*theta where theta is
 293              * the angle that the long axis of the ellipse makes
 294              * with the horizontal axis.  Thus, this equation is
 295              * calculating the length of the hypotenuse of a triangle
 296              * along that axis.
 297              */
 298 
 299             double hypot = Math.sqrt(EB*EB + (EA-EC)*(EA-EC));
 300             // sqrt omitted, compare to squared limits below.
 301             double widthsquared = ((EA + EC + hypot) / 2.0d);
 302 
 303             widthScale = Math.sqrt(widthsquared);
 304         }
 305 
 306         return (lw / widthScale);
 307     }
 308 
 309     void strokeTo(final DRendererContext rdrCtx,
 310                   Shape src,
 311                   AffineTransform at,
 312                   double width,
 313                   NormMode norm,
 314                   int caps,
 315                   int join,
 316                   float miterlimit,
 317                   float[] dashes,
 318                   float dashphase,
 319                   DPathConsumer2D pc2d)
 320     {
 321         // We use strokerat so that in Stroker and Dasher we can work only
 322         // with the pre-transformation coordinates. This will repeat a lot of
 323         // computations done in the path iterator, but the alternative is to
 324         // work with transformed paths and compute untransformed coordinates
 325         // as needed. This would be faster but I do not think the complexity
 326         // of working with both untransformed and transformed coordinates in
 327         // the same code is worth it.
 328         // However, if a path's width is constant after a transformation,
 329         // we can skip all this untransforming.
 330 
 331         // As pathTo() will check transformed coordinates for invalid values
 332         // (NaN / Infinity) to ignore such points, it is necessary to apply the
 333         // transformation before the path processing.
 334         AffineTransform strokerat = null;
 335 
 336         int dashLen = -1;
 337         boolean recycleDashes = false;
<a name="2" id="anc2"></a>
 338         double[] dashesD = null;
 339 
 340         // Ensure converting dashes to double precision:
 341         if (dashes != null) {
 342             recycleDashes = true;
 343             dashLen = dashes.length;
 344             dashesD = rdrCtx.dasher.copyDashArray(dashes);
 345         }
 346 
 347         if (at != null &amp;&amp; !at.isIdentity()) {
 348             final double a = at.getScaleX();
 349             final double b = at.getShearX();
 350             final double c = at.getShearY();
 351             final double d = at.getScaleY();
 352             final double det = a * d - c * b;
 353 
 354             if (Math.abs(det) &lt;= (2.0d * Double.MIN_VALUE)) {
 355                 // this rendering engine takes one dimensional curves and turns
 356                 // them into 2D shapes by giving them width.
 357                 // However, if everything is to be passed through a singular
 358                 // transformation, these 2D shapes will be squashed down to 1D
 359                 // again so, nothing can be drawn.
 360 
 361                 // Every path needs an initial moveTo and a pathDone. If these
 362                 // are not there this causes a SIGSEGV in libawt.so (at the time
 363                 // of writing of this comment (September 16, 2010)). Actually,
 364                 // I am not sure if the moveTo is necessary to avoid the SIGSEGV
 365                 // but the pathDone is definitely needed.
 366                 pc2d.moveTo(0.0d, 0.0d);
 367                 pc2d.pathDone();
 368                 return;
 369             }
 370 
 371             // If the transform is a constant multiple of an orthogonal transformation
 372             // then every length is just multiplied by a constant, so we just
 373             // need to transform input paths to stroker and tell stroker
 374             // the scaled width. This condition is satisfied if
 375             // a*b == -c*d &amp;&amp; a*a+c*c == b*b+d*d. In the actual check below, we
 376             // leave a bit of room for error.
 377             if (nearZero(a*b + c*d) &amp;&amp; nearZero(a*a + c*c - (b*b + d*d))) {
<a name="3" id="anc3"></a><span class="changed"> 378                 final double scale = Math.sqrt(a*a + c*c);</span>
 379 
 380                 if (dashesD != null) {
 381                     for (int i = 0; i &lt; dashLen; i++) {
 382                         dashesD[i] *= scale;
 383                     }
 384                     dashphase *= scale;
 385                 }
 386                 width *= scale;
 387 
 388                 // by now strokerat == null. Input paths to
 389                 // stroker (and maybe dasher) will have the full transform at
 390                 // applied to them and nothing will happen to the output paths.
 391             } else {
 392                 strokerat = at;
 393 
 394                 // by now strokerat == at. Input paths to
 395                 // stroker (and maybe dasher) will have the full transform at
 396                 // applied to them, then they will be normalized, and then
 397                 // the inverse of *only the non translation part of at* will
 398                 // be applied to the normalized paths. This won't cause problems
 399                 // in stroker, because, suppose at = T*A, where T is just the
 400                 // translation part of at, and A is the rest. T*A has already
 401                 // been applied to Stroker/Dasher's input. Then Ainv will be
 402                 // applied. Ainv*T*A is not equal to T, but it is a translation,
 403                 // which means that none of stroker's assumptions about its
 404                 // input will be violated. After all this, A will be applied
 405                 // to stroker's output.
 406             }
 407         } else {
 408             // either at is null or it's the identity. In either case
 409             // we don't transform the path.
 410             at = null;
 411         }
 412 
 413         final DTransformingPathConsumer2D transformerPC2D = rdrCtx.transformerPC2D;
 414 
 415         if (DO_TRACE_PATH) {
 416             // trace Stroker:
 417             pc2d = transformerPC2D.traceStroker(pc2d);
 418         }
 419 
 420         if (USE_SIMPLIFIER) {
 421             // Use simplifier after stroker before Renderer
 422             // to remove collinear segments (notably due to cap square)
 423             pc2d = rdrCtx.simplifier.init(pc2d);
 424         }
 425 
 426         // deltaTransformConsumer may adjust the clip rectangle:
 427         pc2d = transformerPC2D.deltaTransformConsumer(pc2d, strokerat);
 428 
 429         // stroker will adjust the clip rectangle (width / miter limit):
<a name="4" id="anc4"></a><span class="changed"> 430         pc2d = rdrCtx.stroker.init(pc2d, width, caps, join, miterlimit,</span>
 431                 (dashesD == null));
 432 
 433         // Curve Monotizer:
 434         rdrCtx.monotonizer.init(width);
 435 
 436         if (dashesD != null) {
 437             if (DO_TRACE_PATH) {
 438                 pc2d = transformerPC2D.traceDasher(pc2d);
 439             }
 440             pc2d = rdrCtx.dasher.init(pc2d, dashesD, dashLen, dashphase,
 441                                       recycleDashes);
 442 
 443             if (DISABLE_2ND_STROKER_CLIPPING) {
 444                 // disable stoker clipping:
 445                 rdrCtx.stroker.disableClipping();
 446             }
 447 
 448         } else if (rdrCtx.doClip &amp;&amp; (caps != Stroker.CAP_BUTT)) {
 449             if (DO_TRACE_PATH) {
 450                 pc2d = transformerPC2D.traceClosedPathDetector(pc2d);
 451             }
 452 
 453             // If no dash and clip is enabled:
 454             // detect closedPaths (polygons) for caps
 455             pc2d = transformerPC2D.detectClosedPath(pc2d);
 456         }
 457         pc2d = transformerPC2D.inverseDeltaTransformConsumer(pc2d, strokerat);
 458 
 459         if (DO_TRACE_PATH) {
 460             // trace Input:
 461             pc2d = transformerPC2D.traceInput(pc2d);
 462         }
 463 
 464         final PathIterator pi = norm.getNormalizingPathIterator(rdrCtx,
 465                                          src.getPathIterator(at));
 466 
 467         pathTo(rdrCtx, pi, pc2d);
 468 
 469         /*
 470          * Pipeline seems to be:
 471          * shape.getPathIterator(at)
 472          * -&gt; (NormalizingPathIterator)
 473          * -&gt; (inverseDeltaTransformConsumer)
 474          * -&gt; (Dasher)
 475          * -&gt; Stroker
 476          * -&gt; (deltaTransformConsumer)
 477          *
 478          * -&gt; (CollinearSimplifier) to remove redundant segments
 479          *
 480          * -&gt; pc2d = Renderer (bounding box)
 481          */
 482     }
 483 
 484     private static boolean nearZero(final double num) {
 485         return Math.abs(num) &lt; 2.0d * Math.ulp(num);
 486     }
 487 
 488     abstract static class NormalizingPathIterator implements PathIterator {
 489 
 490         private PathIterator src;
 491 
 492         // the adjustment applied to the current position.
 493         private double curx_adjust, cury_adjust;
 494         // the adjustment applied to the last moveTo position.
 495         private double movx_adjust, movy_adjust;
 496 
 497         private final double[] tmp;
 498 
 499         NormalizingPathIterator(final double[] tmp) {
 500             this.tmp = tmp;
 501         }
 502 
 503         final NormalizingPathIterator init(final PathIterator src) {
 504             this.src = src;
 505             return this; // fluent API
 506         }
 507 
 508         /**
 509          * Disposes this path iterator:
 510          * clean up before reusing this instance
 511          */
 512         final void dispose() {
 513             // free source PathIterator:
 514             this.src = null;
 515         }
 516 
 517         @Override
 518         public final int currentSegment(final double[] coords) {
 519             int lastCoord;
 520             final int type = src.currentSegment(coords);
 521 
 522             switch(type) {
 523                 case PathIterator.SEG_MOVETO:
 524                 case PathIterator.SEG_LINETO:
 525                     lastCoord = 0;
 526                     break;
 527                 case PathIterator.SEG_QUADTO:
 528                     lastCoord = 2;
 529                     break;
 530                 case PathIterator.SEG_CUBICTO:
 531                     lastCoord = 4;
 532                     break;
 533                 case PathIterator.SEG_CLOSE:
 534                     // we don't want to deal with this case later. We just exit now
 535                     curx_adjust = movx_adjust;
 536                     cury_adjust = movy_adjust;
 537                     return type;
 538                 default:
 539                     throw new InternalError("Unrecognized curve type");
 540             }
 541 
 542             // normalize endpoint
 543             double coord, x_adjust, y_adjust;
 544 
 545             coord = coords[lastCoord];
 546             x_adjust = normCoord(coord); // new coord
 547             coords[lastCoord] = x_adjust;
 548             x_adjust -= coord;
 549 
 550             coord = coords[lastCoord + 1];
 551             y_adjust = normCoord(coord); // new coord
 552             coords[lastCoord + 1] = y_adjust;
 553             y_adjust -= coord;
 554 
 555             // now that the end points are done, normalize the control points
 556             switch(type) {
 557                 case PathIterator.SEG_MOVETO:
 558                     movx_adjust = x_adjust;
 559                     movy_adjust = y_adjust;
 560                     break;
 561                 case PathIterator.SEG_LINETO:
 562                     break;
 563                 case PathIterator.SEG_QUADTO:
 564                     coords[0] += (curx_adjust + x_adjust) / 2.0d;
 565                     coords[1] += (cury_adjust + y_adjust) / 2.0d;
 566                     break;
 567                 case PathIterator.SEG_CUBICTO:
 568                     coords[0] += curx_adjust;
 569                     coords[1] += cury_adjust;
 570                     coords[2] += x_adjust;
 571                     coords[3] += y_adjust;
 572                     break;
 573                 case PathIterator.SEG_CLOSE:
 574                     // handled earlier
 575                 default:
 576             }
 577             curx_adjust = x_adjust;
 578             cury_adjust = y_adjust;
 579             return type;
 580         }
 581 
 582         abstract double normCoord(final double coord);
 583 
 584         @Override
 585         public final int currentSegment(final float[] coords) {
 586             final double[] _tmp = tmp; // dirty
 587             int type = this.currentSegment(_tmp);
 588             for (int i = 0; i &lt; 6; i++) {
 589                 coords[i] = (float)_tmp[i];
 590             }
 591             return type;
 592         }
 593 
 594         @Override
 595         public final int getWindingRule() {
 596             return src.getWindingRule();
 597         }
 598 
 599         @Override
 600         public final boolean isDone() {
 601             if (src.isDone()) {
 602                 // Dispose this instance:
 603                 dispose();
 604                 return true;
 605             }
 606             return false;
 607         }
 608 
 609         @Override
 610         public final void next() {
 611             src.next();
 612         }
 613 
 614         static final class NearestPixelCenter
 615                                 extends NormalizingPathIterator
 616         {
 617             NearestPixelCenter(final double[] tmp) {
 618                 super(tmp);
 619             }
 620 
 621             @Override
 622             double normCoord(final double coord) {
 623                 // round to nearest pixel center
 624                 return Math.floor(coord) + 0.5d;
 625             }
 626         }
 627 
 628         static final class NearestPixelQuarter
 629                                 extends NormalizingPathIterator
 630         {
 631             NearestPixelQuarter(final double[] tmp) {
 632                 super(tmp);
 633             }
 634 
 635             @Override
 636             double normCoord(final double coord) {
 637                 // round to nearest (0.25, 0.25) pixel quarter
 638                 return Math.floor(coord + 0.25d) + 0.25d;
 639             }
 640         }
 641     }
 642 
 643     private static void pathTo(final DRendererContext rdrCtx, final PathIterator pi,
 644                                DPathConsumer2D pc2d)
 645     {
 646         if (USE_PATH_SIMPLIFIER) {
 647             // Use path simplifier at the first step
 648             // to remove useless points
 649             pc2d = rdrCtx.pathSimplifier.init(pc2d);
 650         }
 651 
 652         // mark context as DIRTY:
 653         rdrCtx.dirty = true;
 654 
 655         pathToLoop(rdrCtx.double6, pi, pc2d);
 656 
 657         // mark context as CLEAN:
 658         rdrCtx.dirty = false;
 659     }
 660 
 661     private static void pathToLoop(final double[] coords, final PathIterator pi,
 662                                    final DPathConsumer2D pc2d)
 663     {
 664         // ported from DuctusRenderingEngine.feedConsumer() but simplified:
 665         // - removed skip flag = !subpathStarted
 666         // - removed pathClosed (ie subpathStarted not set to false)
 667         boolean subpathStarted = false;
 668 
 669         for (; !pi.isDone(); pi.next()) {
 670             switch (pi.currentSegment(coords)) {
 671             case PathIterator.SEG_MOVETO:
 672                 /* Checking SEG_MOVETO coordinates if they are out of the
 673                  * [LOWER_BND, UPPER_BND] range. This check also handles NaN
 674                  * and Infinity values. Skipping next path segment in case of
 675                  * invalid data.
 676                  */
 677                 if (coords[0] &lt; UPPER_BND &amp;&amp; coords[0] &gt; LOWER_BND &amp;&amp;
 678                     coords[1] &lt; UPPER_BND &amp;&amp; coords[1] &gt; LOWER_BND)
 679                 {
 680                     pc2d.moveTo(coords[0], coords[1]);
 681                     subpathStarted = true;
 682                 }
 683                 break;
 684             case PathIterator.SEG_LINETO:
 685                 /* Checking SEG_LINETO coordinates if they are out of the
 686                  * [LOWER_BND, UPPER_BND] range. This check also handles NaN
 687                  * and Infinity values. Ignoring current path segment in case
 688                  * of invalid data. If segment is skipped its endpoint
 689                  * (if valid) is used to begin new subpath.
 690                  */
 691                 if (coords[0] &lt; UPPER_BND &amp;&amp; coords[0] &gt; LOWER_BND &amp;&amp;
 692                     coords[1] &lt; UPPER_BND &amp;&amp; coords[1] &gt; LOWER_BND)
 693                 {
 694                     if (subpathStarted) {
 695                         pc2d.lineTo(coords[0], coords[1]);
 696                     } else {
 697                         pc2d.moveTo(coords[0], coords[1]);
 698                         subpathStarted = true;
 699                     }
 700                 }
 701                 break;
 702             case PathIterator.SEG_QUADTO:
 703                 // Quadratic curves take two points
 704                 /* Checking SEG_QUADTO coordinates if they are out of the
 705                  * [LOWER_BND, UPPER_BND] range. This check also handles NaN
 706                  * and Infinity values. Ignoring current path segment in case
 707                  * of invalid endpoints's data. Equivalent to the SEG_LINETO
 708                  * if endpoint coordinates are valid but there are invalid data
 709                  * among other coordinates
 710                  */
 711                 if (coords[2] &lt; UPPER_BND &amp;&amp; coords[2] &gt; LOWER_BND &amp;&amp;
 712                     coords[3] &lt; UPPER_BND &amp;&amp; coords[3] &gt; LOWER_BND)
 713                 {
 714                     if (subpathStarted) {
 715                         if (coords[0] &lt; UPPER_BND &amp;&amp; coords[0] &gt; LOWER_BND &amp;&amp;
 716                             coords[1] &lt; UPPER_BND &amp;&amp; coords[1] &gt; LOWER_BND)
 717                         {
 718                             pc2d.quadTo(coords[0], coords[1],
 719                                         coords[2], coords[3]);
 720                         } else {
 721                             pc2d.lineTo(coords[2], coords[3]);
 722                         }
 723                     } else {
 724                         pc2d.moveTo(coords[2], coords[3]);
 725                         subpathStarted = true;
 726                     }
 727                 }
 728                 break;
 729             case PathIterator.SEG_CUBICTO:
 730                 // Cubic curves take three points
 731                 /* Checking SEG_CUBICTO coordinates if they are out of the
 732                  * [LOWER_BND, UPPER_BND] range. This check also handles NaN
 733                  * and Infinity values. Ignoring current path segment in case
 734                  * of invalid endpoints's data. Equivalent to the SEG_LINETO
 735                  * if endpoint coordinates are valid but there are invalid data
 736                  * among other coordinates
 737                  */
 738                 if (coords[4] &lt; UPPER_BND &amp;&amp; coords[4] &gt; LOWER_BND &amp;&amp;
 739                     coords[5] &lt; UPPER_BND &amp;&amp; coords[5] &gt; LOWER_BND)
 740                 {
 741                     if (subpathStarted) {
 742                         if (coords[0] &lt; UPPER_BND &amp;&amp; coords[0] &gt; LOWER_BND &amp;&amp;
 743                             coords[1] &lt; UPPER_BND &amp;&amp; coords[1] &gt; LOWER_BND &amp;&amp;
 744                             coords[2] &lt; UPPER_BND &amp;&amp; coords[2] &gt; LOWER_BND &amp;&amp;
 745                             coords[3] &lt; UPPER_BND &amp;&amp; coords[3] &gt; LOWER_BND)
 746                         {
 747                             pc2d.curveTo(coords[0], coords[1],
 748                                          coords[2], coords[3],
 749                                          coords[4], coords[5]);
 750                         } else {
 751                             pc2d.lineTo(coords[4], coords[5]);
 752                         }
 753                     } else {
 754                         pc2d.moveTo(coords[4], coords[5]);
 755                         subpathStarted = true;
 756                     }
 757                 }
 758                 break;
 759             case PathIterator.SEG_CLOSE:
 760                 if (subpathStarted) {
 761                     pc2d.closePath();
 762                     // do not set subpathStarted to false
 763                     // in case of missing moveTo() after close()
 764                 }
 765                 break;
 766             default:
 767             }
 768         }
 769         pc2d.pathDone();
 770     }
 771 
 772     /**
 773      * Construct an antialiased tile generator for the given shape with
 774      * the given rendering attributes and store the bounds of the tile
 775      * iteration in the bbox parameter.
 776      * The {@code at} parameter specifies a transform that should affect
 777      * both the shape and the {@code BasicStroke} attributes.
 778      * The {@code clip} parameter specifies the current clip in effect
 779      * in device coordinates and can be used to prune the data for the
 780      * operation, but the renderer is not required to perform any
 781      * clipping.
 782      * If the {@code BasicStroke} parameter is null then the shape
 783      * should be filled as is, otherwise the attributes of the
 784      * {@code BasicStroke} should be used to specify a draw operation.
 785      * The {@code thin} parameter indicates whether or not the
 786      * transformed {@code BasicStroke} represents coordinates smaller
 787      * than the minimum resolution of the antialiasing rasterizer as
 788      * specified by the {@code getMinimumAAPenWidth()} method.
 789      * &lt;p&gt;
 790      * Upon returning, this method will fill the {@code bbox} parameter
 791      * with 4 values indicating the bounds of the iteration of the
 792      * tile generator.
 793      * The iteration order of the tiles will be as specified by the
 794      * pseudo-code:
 795      * &lt;pre&gt;
 796      *     for (y = bbox[1]; y &lt; bbox[3]; y += tileheight) {
 797      *         for (x = bbox[0]; x &lt; bbox[2]; x += tilewidth) {
 798      *         }
 799      *     }
 800      * &lt;/pre&gt;
 801      * If there is no output to be rendered, this method may return
 802      * null.
 803      *
 804      * @param s the shape to be rendered (fill or draw)
 805      * @param at the transform to be applied to the shape and the
 806      *           stroke attributes
 807      * @param clip the current clip in effect in device coordinates
 808      * @param bs if non-null, a {@code BasicStroke} whose attributes
 809      *           should be applied to this operation
 810      * @param thin true if the transformed stroke attributes are smaller
 811      *             than the minimum dropout pen width
 812      * @param normalize true if the {@code VALUE_STROKE_NORMALIZE}
 813      *                  {@code RenderingHint} is in effect
 814      * @param bbox returns the bounds of the iteration
 815      * @return the {@code AATileGenerator} instance to be consulted
 816      *         for tile coverages, or null if there is no output to render
 817      * @since 1.7
 818      */
 819     @Override
 820     public AATileGenerator getAATileGenerator(Shape s,
 821                                               AffineTransform at,
 822                                               Region clip,
 823                                               BasicStroke bs,
 824                                               boolean thin,
 825                                               boolean normalize,
 826                                               int[] bbox)
 827     {
 828         MarlinTileGenerator ptg = null;
 829         DRenderer r = null;
 830 
 831         final DRendererContext rdrCtx = getRendererContext();
 832         try {
 833             if (DO_CLIP || (DO_CLIP_RUNTIME_ENABLE &amp;&amp; MarlinProperties.isDoClipAtRuntime())) {
 834                 // Define the initial clip bounds:
 835                 final double[] clipRect = rdrCtx.clipRect;
 836 
<a name="5" id="anc5"></a><span class="changed"> 837                 // Adjust the clipping rectangle with the renderer offsets</span>
<span class="changed"> 838                 final double rdrOffX = DRenderer.RDR_OFFSET_X;</span>
<span class="changed"> 839                 final double rdrOffY = DRenderer.RDR_OFFSET_Y;</span>
<span class="changed"> 840 </span>
<span class="changed"> 841                 // add a small rounding error:</span>
<span class="changed"> 842                 final double margin = 1e-3d;</span>
<span class="changed"> 843 </span>
<span class="changed"> 844                 clipRect[0] = clip.getLoY()</span>
<span class="changed"> 845                                 - margin + rdrOffY;</span>
<span class="changed"> 846                 clipRect[1] = clip.getLoY() + clip.getHeight()</span>
<span class="changed"> 847                                 + margin + rdrOffY;</span>
<span class="changed"> 848                 clipRect[2] = clip.getLoX()</span>
<span class="changed"> 849                                 - margin + rdrOffX;</span>
<span class="changed"> 850                 clipRect[3] = clip.getLoX() + clip.getWidth()</span>
<span class="changed"> 851                                 + margin + rdrOffX;</span>
<span class="changed"> 852 </span>
<span class="changed"> 853                 if (MarlinConst.DO_LOG_CLIP) {</span>
<span class="changed"> 854                     MarlinUtils.logInfo("clipRect (clip): "</span>
<span class="changed"> 855                                         + Arrays.toString(rdrCtx.clipRect));</span>
<span class="changed"> 856                 }</span>
 857 
 858                 // Enable clipping:
 859                 rdrCtx.doClip = true;
 860             }
 861 
 862             // Test if at is identity:
 863             final AffineTransform _at = (at != null &amp;&amp; !at.isIdentity()) ? at
 864                                         : null;
 865 
 866             final NormMode norm = (normalize) ? NormMode.ON_WITH_AA : NormMode.OFF;
 867 
 868             if (bs == null) {
 869                 // fill shape:
 870                 final PathIterator pi = norm.getNormalizingPathIterator(rdrCtx,
 871                                                  s.getPathIterator(_at));
 872 
 873                 // note: Winding rule may be EvenOdd ONLY for fill operations !
 874                 r = rdrCtx.renderer.init(clip.getLoX(), clip.getLoY(),
 875                                          clip.getWidth(), clip.getHeight(),
 876                                          pi.getWindingRule());
 877 
 878                 DPathConsumer2D pc2d = r;
 879 
 880                 if (DO_CLIP_FILL &amp;&amp; rdrCtx.doClip) {
 881                     if (DO_TRACE_PATH) {
 882                         // trace Filler:
 883                         pc2d = rdrCtx.transformerPC2D.traceFiller(pc2d);
 884                     }
 885                     pc2d = rdrCtx.transformerPC2D.pathClipper(pc2d);
 886                 }
 887 
 888                 if (DO_TRACE_PATH) {
 889                     // trace Input:
 890                     pc2d = rdrCtx.transformerPC2D.traceInput(pc2d);
 891                 }
 892                 pathTo(rdrCtx, pi, pc2d);
 893 
 894             } else {
 895                 // draw shape with given stroke:
 896                 r = rdrCtx.renderer.init(clip.getLoX(), clip.getLoY(),
 897                                          clip.getWidth(), clip.getHeight(),
 898                                          WIND_NON_ZERO);
 899 
 900                 strokeTo(rdrCtx, s, _at, bs, thin, norm, true, r);
 901             }
 902             if (r.endRendering()) {
 903                 ptg = rdrCtx.ptg.init();
 904                 ptg.getBbox(bbox);
 905                 // note: do not returnRendererContext(rdrCtx)
 906                 // as it will be called later by MarlinTileGenerator.dispose()
 907                 r = null;
 908             }
 909         } finally {
 910             if (r != null) {
 911                 // dispose renderer and recycle the RendererContext instance:
 912                 r.dispose();
 913             }
 914         }
 915 
 916         // Return null to cancel AA tile generation (nothing to render)
 917         return ptg;
 918     }
 919 
 920     @Override
 921     public AATileGenerator getAATileGenerator(double x, double y,
 922                                               double dx1, double dy1,
 923                                               double dx2, double dy2,
 924                                               double lw1, double lw2,
 925                                               Region clip,
 926                                               int[] bbox)
 927     {
 928         // REMIND: Deal with large coordinates!
 929         double ldx1, ldy1, ldx2, ldy2;
 930         boolean innerpgram = (lw1 &gt; 0.0d &amp;&amp; lw2 &gt; 0.0d);
 931 
 932         if (innerpgram) {
 933             ldx1 = dx1 * lw1;
 934             ldy1 = dy1 * lw1;
 935             ldx2 = dx2 * lw2;
 936             ldy2 = dy2 * lw2;
 937             x -= (ldx1 + ldx2) / 2.0d;
 938             y -= (ldy1 + ldy2) / 2.0d;
 939             dx1 += ldx1;
 940             dy1 += ldy1;
 941             dx2 += ldx2;
 942             dy2 += ldy2;
 943             if (lw1 &gt; 1.0d &amp;&amp; lw2 &gt; 1.0d) {
 944                 // Inner parallelogram was entirely consumed by stroke...
 945                 innerpgram = false;
 946             }
 947         } else {
 948             ldx1 = ldy1 = ldx2 = ldy2 = 0.0d;
 949         }
 950 
 951         MarlinTileGenerator ptg = null;
 952         DRenderer r = null;
 953 
 954         final DRendererContext rdrCtx = getRendererContext();
 955         try {
 956             r = rdrCtx.renderer.init(clip.getLoX(), clip.getLoY(),
 957                                      clip.getWidth(), clip.getHeight(),
 958                                      WIND_EVEN_ODD);
 959 
 960             r.moveTo( x,  y);
 961             r.lineTo( (x+dx1),  (y+dy1));
 962             r.lineTo( (x+dx1+dx2),  (y+dy1+dy2));
 963             r.lineTo( (x+dx2),  (y+dy2));
 964             r.closePath();
 965 
 966             if (innerpgram) {
 967                 x += ldx1 + ldx2;
 968                 y += ldy1 + ldy2;
 969                 dx1 -= 2.0d * ldx1;
 970                 dy1 -= 2.0d * ldy1;
 971                 dx2 -= 2.0d * ldx2;
 972                 dy2 -= 2.0d * ldy2;
 973                 r.moveTo( x,  y);
 974                 r.lineTo( (x+dx1),  (y+dy1));
 975                 r.lineTo( (x+dx1+dx2),  (y+dy1+dy2));
 976                 r.lineTo( (x+dx2),  (y+dy2));
 977                 r.closePath();
 978             }
 979             r.pathDone();
 980 
 981             if (r.endRendering()) {
 982                 ptg = rdrCtx.ptg.init();
 983                 ptg.getBbox(bbox);
 984                 // note: do not returnRendererContext(rdrCtx)
 985                 // as it will be called later by MarlinTileGenerator.dispose()
 986                 r = null;
 987             }
 988         } finally {
 989             if (r != null) {
 990                 // dispose renderer and recycle the RendererContext instance:
 991                 r.dispose();
 992             }
 993         }
 994 
 995         // Return null to cancel AA tile generation (nothing to render)
 996         return ptg;
 997     }
 998 
 999     /**
1000      * Returns the minimum pen width that the antialiasing rasterizer
1001      * can represent without dropouts occuring.
1002      * @since 1.7
1003      */
1004     @Override
1005     public float getMinimumAAPenSize() {
1006         return MIN_PEN_SIZE;
1007     }
1008 
1009     static {
1010         if (PathIterator.WIND_NON_ZERO != WIND_NON_ZERO ||
1011             PathIterator.WIND_EVEN_ODD != WIND_EVEN_ODD ||
1012             BasicStroke.JOIN_MITER != JOIN_MITER ||
1013             BasicStroke.JOIN_ROUND != JOIN_ROUND ||
1014             BasicStroke.JOIN_BEVEL != JOIN_BEVEL ||
1015             BasicStroke.CAP_BUTT != CAP_BUTT ||
1016             BasicStroke.CAP_ROUND != CAP_ROUND ||
1017             BasicStroke.CAP_SQUARE != CAP_SQUARE)
1018         {
1019             throw new InternalError("mismatched renderer constants");
1020         }
1021     }
1022 
1023     // --- DRendererContext handling ---
1024     // use ThreadLocal or ConcurrentLinkedQueue to get one DRendererContext
1025     private static final boolean USE_THREAD_LOCAL;
1026 
1027     // reference type stored in either TL or CLQ
1028     static final int REF_TYPE;
1029 
1030     // Per-thread DRendererContext
1031     private static final ReentrantContextProvider&lt;DRendererContext&gt; RDR_CTX_PROVIDER;
1032 
1033     // Static initializer to use TL or CLQ mode
1034     static {
1035         USE_THREAD_LOCAL = MarlinProperties.isUseThreadLocal();
1036 
1037         // Soft reference by default:
1038         final String refType = AccessController.doPrivileged(
1039                             new GetPropertyAction("sun.java2d.renderer.useRef",
1040                             "soft"));
1041         switch (refType) {
1042             default:
1043             case "soft":
1044                 REF_TYPE = ReentrantContextProvider.REF_SOFT;
1045                 break;
1046             case "weak":
1047                 REF_TYPE = ReentrantContextProvider.REF_WEAK;
1048                 break;
1049             case "hard":
1050                 REF_TYPE = ReentrantContextProvider.REF_HARD;
1051                 break;
1052         }
1053 
1054         if (USE_THREAD_LOCAL) {
1055             RDR_CTX_PROVIDER = new ReentrantContextProviderTL&lt;DRendererContext&gt;(REF_TYPE)
1056                 {
1057                     @Override
1058                     protected DRendererContext newContext() {
1059                         return DRendererContext.createContext();
1060                     }
1061                 };
1062         } else {
1063             RDR_CTX_PROVIDER = new ReentrantContextProviderCLQ&lt;DRendererContext&gt;(REF_TYPE)
1064                 {
1065                     @Override
1066                     protected DRendererContext newContext() {
1067                         return DRendererContext.createContext();
1068                     }
1069                 };
1070         }
1071     }
1072 
1073     private static boolean SETTINGS_LOGGED = !ENABLE_LOGS;
1074 
1075     private static void logSettings(final String reClass) {
1076         // log information at startup
1077         if (SETTINGS_LOGGED) {
1078             return;
1079         }
1080         SETTINGS_LOGGED = true;
1081 
1082         String refType;
1083         switch (REF_TYPE) {
1084             default:
1085             case ReentrantContextProvider.REF_HARD:
1086                 refType = "hard";
1087                 break;
1088             case ReentrantContextProvider.REF_SOFT:
1089                 refType = "soft";
1090                 break;
1091             case ReentrantContextProvider.REF_WEAK:
1092                 refType = "weak";
1093                 break;
1094         }
1095 
1096         logInfo("=========================================================="
1097                 + "=====================");
1098 
1099         logInfo("Marlin software rasterizer           = ENABLED");
1100         logInfo("Version                              = ["
1101                 + Version.getVersion() + "]");
1102         logInfo("sun.java2d.renderer                  = "
1103                 + reClass);
1104         logInfo("sun.java2d.renderer.useThreadLocal   = "
1105                 + USE_THREAD_LOCAL);
1106         logInfo("sun.java2d.renderer.useRef           = "
1107                 + refType);
1108 
1109         logInfo("sun.java2d.renderer.edges            = "
1110                 + MarlinConst.INITIAL_EDGES_COUNT);
1111         logInfo("sun.java2d.renderer.pixelWidth       = "
1112                 + MarlinConst.INITIAL_PIXEL_WIDTH);
1113         logInfo("sun.java2d.renderer.pixelHeight      = "
1114                 + MarlinConst.INITIAL_PIXEL_HEIGHT);
1115 
1116         logInfo("sun.java2d.renderer.subPixel_log2_X  = "
1117                 + MarlinConst.SUBPIXEL_LG_POSITIONS_X);
1118         logInfo("sun.java2d.renderer.subPixel_log2_Y  = "
1119                 + MarlinConst.SUBPIXEL_LG_POSITIONS_Y);
1120 
1121         logInfo("sun.java2d.renderer.tileSize_log2    = "
1122                 + MarlinConst.TILE_H_LG);
1123         logInfo("sun.java2d.renderer.tileWidth_log2   = "
1124                 + MarlinConst.TILE_W_LG);
1125         logInfo("sun.java2d.renderer.blockSize_log2   = "
1126                 + MarlinConst.BLOCK_SIZE_LG);
1127 
1128         // RLE / blockFlags settings
1129 
1130         logInfo("sun.java2d.renderer.forceRLE         = "
1131                 + MarlinProperties.isForceRLE());
1132         logInfo("sun.java2d.renderer.forceNoRLE       = "
1133                 + MarlinProperties.isForceNoRLE());
1134         logInfo("sun.java2d.renderer.useTileFlags     = "
1135                 + MarlinProperties.isUseTileFlags());
1136         logInfo("sun.java2d.renderer.useTileFlags.useHeuristics = "
1137                 + MarlinProperties.isUseTileFlagsWithHeuristics());
1138         logInfo("sun.java2d.renderer.rleMinWidth      = "
1139                 + MarlinCache.RLE_MIN_WIDTH);
1140 
1141         // optimisation parameters
1142         logInfo("sun.java2d.renderer.useSimplifier    = "
1143                 + MarlinConst.USE_SIMPLIFIER);
1144         logInfo("sun.java2d.renderer.usePathSimplifier= "
1145                 + MarlinConst.USE_PATH_SIMPLIFIER);
1146         logInfo("sun.java2d.renderer.pathSimplifier.pixTol = "
1147                 + MarlinProperties.getPathSimplifierPixelTolerance());
1148 
1149         logInfo("sun.java2d.renderer.clip             = "
1150                 + MarlinProperties.isDoClip());
1151         logInfo("sun.java2d.renderer.clip.runtime.enable = "
1152                 + MarlinProperties.isDoClipRuntimeFlag());
1153 
1154         logInfo("sun.java2d.renderer.clip.subdivider  = "
1155                 + MarlinProperties.isDoClipSubdivider());
1156         logInfo("sun.java2d.renderer.clip.subdivider.minLength = "
1157                 + MarlinProperties.getSubdividerMinLength());
1158 
1159         // debugging parameters
1160         logInfo("sun.java2d.renderer.doStats          = "
1161                 + MarlinConst.DO_STATS);
1162         logInfo("sun.java2d.renderer.doMonitors       = "
1163                 + MarlinConst.DO_MONITORS);
1164         logInfo("sun.java2d.renderer.doChecks         = "
1165                 + MarlinConst.DO_CHECKS);
1166 
1167         // logging parameters
1168         logInfo("sun.java2d.renderer.useLogger        = "
1169                 + MarlinConst.USE_LOGGER);
1170         logInfo("sun.java2d.renderer.logCreateContext = "
1171                 + MarlinConst.LOG_CREATE_CONTEXT);
1172         logInfo("sun.java2d.renderer.logUnsafeMalloc  = "
1173                 + MarlinConst.LOG_UNSAFE_MALLOC);
1174 
1175         // quality settings
1176         logInfo("sun.java2d.renderer.curve_len_err    = "
1177                 + MarlinProperties.getCurveLengthError());
1178         logInfo("sun.java2d.renderer.cubic_dec_d2     = "
1179                 + MarlinProperties.getCubicDecD2());
1180         logInfo("sun.java2d.renderer.cubic_inc_d1     = "
1181                 + MarlinProperties.getCubicIncD1());
1182         logInfo("sun.java2d.renderer.quad_dec_d2      = "
1183                 + MarlinProperties.getQuadDecD2());
1184 
1185         logInfo("Renderer settings:");
1186         logInfo("CUB_DEC_BND  = " + DRenderer.CUB_DEC_BND);
1187         logInfo("CUB_INC_BND  = " + DRenderer.CUB_INC_BND);
1188         logInfo("QUAD_DEC_BND = " + DRenderer.QUAD_DEC_BND);
1189 
1190         logInfo("INITIAL_EDGES_CAPACITY               = "
1191                 + MarlinConst.INITIAL_EDGES_CAPACITY);
1192         logInfo("INITIAL_CROSSING_COUNT               = "
1193                 + DRenderer.INITIAL_CROSSING_COUNT);
1194 
1195         logInfo("=========================================================="
1196                 + "=====================");
1197     }
1198 
1199     /**
1200      * Get the DRendererContext instance dedicated to the current thread
1201      * @return DRendererContext instance
1202      */
1203     @SuppressWarnings({"unchecked"})
1204     static DRendererContext getRendererContext() {
1205         final DRendererContext rdrCtx = RDR_CTX_PROVIDER.acquire();
1206         if (DO_MONITORS) {
1207             rdrCtx.stats.mon_pre_getAATileGenerator.start();
1208         }
1209         return rdrCtx;
1210     }
1211 
1212     /**
1213      * Reset and return the given DRendererContext instance for reuse
1214      * @param rdrCtx DRendererContext instance
1215      */
1216     static void returnRendererContext(final DRendererContext rdrCtx) {
1217         rdrCtx.dispose();
1218 
1219         if (DO_MONITORS) {
1220             rdrCtx.stats.mon_pre_getAATileGenerator.stop();
1221         }
1222         RDR_CTX_PROVIDER.release(rdrCtx);
1223     }
1224 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="6" type="hidden" /></form></body></html>
