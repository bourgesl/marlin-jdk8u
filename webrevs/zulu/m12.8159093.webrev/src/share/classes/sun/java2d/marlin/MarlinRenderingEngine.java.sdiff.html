<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>jdk Sdiff src/share/classes/sun/java2d/marlin </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../../../src/share/classes/sun/java2d/marlin/MarlinConst.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../src/share/classes/sun/java2d/marlin/MarlinTileGenerator.java.sdiff.html' target='_top'>next &gt</a></center>
<h2>src/share/classes/sun/java2d/marlin/MarlinRenderingEngine.java</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-13691">13691</a> : <a href="https://bugs.openjdk.java.net/browse/JDK-8159093">8159093</a>: Fix coding conventions in Marlin renderer
Summary: capital letters for constants and use rdrCtx.stats (field)
Reviewed-by: flar, prr</pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
  68      * The specified {@code src} {@link Shape} is widened according
  69      * to the specified attribute parameters as per the
  70      * {@link BasicStroke} specification.
  71      *
  72      * @param src the source path to be widened
  73      * @param width the width of the widened path as per {@code BasicStroke}
  74      * @param caps the end cap decorations as per {@code BasicStroke}
  75      * @param join the segment join decorations as per {@code BasicStroke}
  76      * @param miterlimit the miter limit as per {@code BasicStroke}
  77      * @param dashes the dash length array as per {@code BasicStroke}
  78      * @param dashphase the initial dash phase as per {@code BasicStroke}
  79      * @return the widened path stored in a new {@code Shape} object
  80      * @since 1.7
  81      */
  82     @Override
  83     public Shape createStrokedShape(Shape src,
  84                                     float width,
  85                                     int caps,
  86                                     int join,
  87                                     float miterlimit,
<span class="changed">  88                                     float dashes[],</span>
  89                                     float dashphase)
  90     {
  91         final RendererContext rdrCtx = getRendererContext();
  92         try {
  93             // initialize a large copyable Path2D to avoid a lot of array growing:
  94             final Path2D.Float p2d =
  95                     (rdrCtx.p2d == null) ?
  96                     (rdrCtx.p2d = new Path2D.Float(Path2D.WIND_NON_ZERO,
  97                                                    INITIAL_MEDIUM_ARRAY))
  98                     : rdrCtx.p2d;
  99             // reset
 100             p2d.reset();
 101 
 102             strokeTo(rdrCtx,
 103                      src,
 104                      null,
 105                      width,
 106                      NormMode.OFF,
 107                      caps,
 108                      join,

</pre><hr></hr><pre>
 261              */
 262 
 263             double hypot = Math.sqrt(EB*EB + (EA-EC)*(EA-EC));
 264             // sqrt omitted, compare to squared limits below.
 265             double widthsquared = ((EA + EC + hypot)/2.0);
 266 
 267             widthScale = (float)Math.sqrt(widthsquared);
 268         }
 269 
 270         return (lw / widthScale);
 271     }
 272 
 273     final void strokeTo(final RendererContext rdrCtx,
 274                         Shape src,
 275                         AffineTransform at,
 276                         float width,
 277                         NormMode normalize,
 278                         int caps,
 279                         int join,
 280                         float miterlimit,
<span class="changed"> 281                         float dashes[],</span>
 282                         float dashphase,
 283                         PathConsumer2D pc2d)
 284     {
 285         // We use strokerat so that in Stroker and Dasher we can work only
 286         // with the pre-transformation coordinates. This will repeat a lot of
 287         // computations done in the path iterator, but the alternative is to
 288         // work with transformed paths and compute untransformed coordinates
 289         // as needed. This would be faster but I do not think the complexity
 290         // of working with both untransformed and transformed coordinates in
 291         // the same code is worth it.
 292         // However, if a path's width is constant after a transformation,
 293         // we can skip all this untransforming.
 294 
 295         // As pathTo() will check transformed coordinates for invalid values
 296         // (NaN / Infinity) to ignore such points, it is necessary to apply the
 297         // transformation before the path processing.
 298         AffineTransform strokerat = null;
 299 
 300         int dashLen = -1;
 301         boolean recycleDashes = false;

</pre><hr></hr><pre>
 323                 pc2d.pathDone();
 324                 return;
 325             }
 326 
 327             // If the transform is a constant multiple of an orthogonal transformation
 328             // then every length is just multiplied by a constant, so we just
 329             // need to transform input paths to stroker and tell stroker
 330             // the scaled width. This condition is satisfied if
 331             // a*b == -c*d &amp;&amp; a*a+c*c == b*b+d*d. In the actual check below, we
 332             // leave a bit of room for error.
 333             if (nearZero(a*b + c*d) &amp;&amp; nearZero(a*a + c*c - (b*b + d*d))) {
 334                 final float scale = (float) Math.sqrt(a*a + c*c);
 335 
 336                 if (dashes != null) {
 337                     recycleDashes = true;
 338                     dashLen = dashes.length;
 339                     final float[] newDashes;
 340                     if (dashLen &lt;= INITIAL_ARRAY) {
 341                         newDashes = rdrCtx.dasher.dashes_initial;
 342                     } else {
<span class="changed"> 343                         if (doStats) {</span>
<span class="changed"> 344                             RendererContext.stats.stat_array_dasher_dasher</span>
 345                                 .add(dashLen);
 346                         }
 347                         newDashes = rdrCtx.getDirtyFloatArray(dashLen);
 348                     }
 349                     System.arraycopy(dashes, 0, newDashes, 0, dashLen);
 350                     dashes = newDashes;
 351                     for (int i = 0; i &lt; dashLen; i++) {
 352                         dashes[i] *= scale;
 353                     }
 354                     dashphase *= scale;
 355                 }
 356                 width *= scale;
 357 
 358                 // by now strokerat == null. Input paths to
 359                 // stroker (and maybe dasher) will have the full transform at
 360                 // applied to them and nothing will happen to the output paths.
 361             } else {
 362                 strokerat = at;
 363 
 364                 // by now strokerat == at. Input paths to
 365                 // stroker (and maybe dasher) will have the full transform at
 366                 // applied to them, then they will be normalized, and then
 367                 // the inverse of *only the non translation part of at* will
 368                 // be applied to the normalized paths. This won't cause problems
 369                 // in stroker, because, suppose at = T*A, where T is just the
 370                 // translation part of at, and A is the rest. T*A has already
 371                 // been applied to Stroker/Dasher's input. Then Ainv will be
 372                 // applied. Ainv*T*A is not equal to T, but it is a translation,
 373                 // which means that none of stroker's assumptions about its
 374                 // input will be violated. After all this, A will be applied
 375                 // to stroker's output.
 376             }
 377         } else {
 378             // either at is null or it's the identity. In either case
 379             // we don't transform the path.
 380             at = null;
 381         }
 382 
<span class="changed"> 383         if (useSimplifier) {</span>
 384             // Use simplifier after stroker before Renderer
 385             // to remove collinear segments (notably due to cap square)
 386             pc2d = rdrCtx.simplifier.init(pc2d);
 387         }
 388 
 389         final TransformingPathConsumer2D transformerPC2D = rdrCtx.transformerPC2D;
 390         pc2d = transformerPC2D.deltaTransformConsumer(pc2d, strokerat);
 391 
 392         pc2d = rdrCtx.stroker.init(pc2d, width, caps, join, miterlimit);
 393 
 394         if (dashes != null) {
 395             if (!recycleDashes) {
 396                 dashLen = dashes.length;
 397             }
 398             pc2d = rdrCtx.dasher.init(pc2d, dashes, dashLen, dashphase,
 399                                       recycleDashes);
 400         }
 401         pc2d = transformerPC2D.inverseDeltaTransformConsumer(pc2d, strokerat);
 402 
 403         final PathIterator pi = getNormalizingPathIterator(rdrCtx, normalize,

</pre><hr></hr><pre>
 457         NormalizingPathIterator(final float[] tmp) {
 458             this.tmp = tmp;
 459         }
 460 
 461         final NormalizingPathIterator init(final PathIterator src) {
 462             this.src = src;
 463             return this; // fluent API
 464         }
 465 
 466         /**
 467          * Disposes this path iterator:
 468          * clean up before reusing this instance
 469          */
 470         final void dispose() {
 471             // free source PathIterator:
 472             this.src = null;
 473         }
 474 
 475         @Override
 476         public final int currentSegment(final float[] coords) {
<span class="removed"> 477             if (doMonitors) {</span>
<span class="removed"> 478                 RendererContext.stats.mon_npi_currentSegment.start();</span>
<span class="removed"> 479             }</span>
 480             int lastCoord;
 481             final int type = src.currentSegment(coords);
 482 
 483             switch(type) {
 484                 case PathIterator.SEG_MOVETO:
 485                 case PathIterator.SEG_LINETO:
 486                     lastCoord = 0;
 487                     break;
 488                 case PathIterator.SEG_QUADTO:
 489                     lastCoord = 2;
 490                     break;
 491                 case PathIterator.SEG_CUBICTO:
 492                     lastCoord = 4;
 493                     break;
 494                 case PathIterator.SEG_CLOSE:
 495                     // we don't want to deal with this case later. We just exit now
 496                     curx_adjust = movx_adjust;
 497                     cury_adjust = movy_adjust;
<span class="removed"> 498 </span>
<span class="removed"> 499                     if (doMonitors) {</span>
<span class="removed"> 500                         RendererContext.stats.mon_npi_currentSegment.stop();</span>
<span class="removed"> 501                     }</span>
 502                     return type;
 503                 default:
 504                     throw new InternalError("Unrecognized curve type");
 505             }
 506 
<span class="removed"> 507             // TODO: handle NaN, Inf and overflow</span>
<span class="removed"> 508 </span>
 509             // normalize endpoint
 510             float coord, x_adjust, y_adjust;
 511 
 512             coord = coords[lastCoord];
 513             x_adjust = normCoord(coord); // new coord
 514             coords[lastCoord] = x_adjust;
 515             x_adjust -= coord;
 516 
 517             coord = coords[lastCoord + 1];
 518             y_adjust = normCoord(coord); // new coord
 519             coords[lastCoord + 1] = y_adjust;
 520             y_adjust -= coord;
 521 
 522             // now that the end points are done, normalize the control points
 523             switch(type) {
 524                 case PathIterator.SEG_MOVETO:
 525                     movx_adjust = x_adjust;
 526                     movy_adjust = y_adjust;
 527                     break;
 528                 case PathIterator.SEG_LINETO:
 529                     break;
 530                 case PathIterator.SEG_QUADTO:
 531                     coords[0] += (curx_adjust + x_adjust) / 2f;
 532                     coords[1] += (cury_adjust + y_adjust) / 2f;
 533                     break;
 534                 case PathIterator.SEG_CUBICTO:
 535                     coords[0] += curx_adjust;
 536                     coords[1] += cury_adjust;
 537                     coords[2] += x_adjust;
 538                     coords[3] += y_adjust;
 539                     break;
 540                 case PathIterator.SEG_CLOSE:
 541                     // handled earlier
 542                 default:
 543             }
 544             curx_adjust = x_adjust;
 545             cury_adjust = y_adjust;
<span class="removed"> 546 </span>
<span class="removed"> 547             if (doMonitors) {</span>
<span class="removed"> 548                 RendererContext.stats.mon_npi_currentSegment.stop();</span>
<span class="removed"> 549             }</span>
 550             return type;
 551         }
 552 
 553         abstract float normCoord(final float coord);
 554 
 555         @Override
 556         public final int currentSegment(final double[] coords) {
 557             final float[] _tmp = tmp; // dirty
 558             int type = this.currentSegment(_tmp);
 559             for (int i = 0; i &lt; 6; i++) {
 560                 coords[i] = _tmp[i];
 561             }
 562             return type;
 563         }
 564 
 565         @Override
 566         public final int getWindingRule() {
 567             return src.getWindingRule();
 568         }
 569 

</pre><hr></hr><pre>
 773      *           stroke attributes
 774      * @param clip the current clip in effect in device coordinates
 775      * @param bs if non-null, a {@code BasicStroke} whose attributes
 776      *           should be applied to this operation
 777      * @param thin true if the transformed stroke attributes are smaller
 778      *             than the minimum dropout pen width
 779      * @param normalize true if the {@code VALUE_STROKE_NORMALIZE}
 780      *                  {@code RenderingHint} is in effect
 781      * @param bbox returns the bounds of the iteration
 782      * @return the {@code AATileGenerator} instance to be consulted
 783      *         for tile coverages, or null if there is no output to render
 784      * @since 1.7
 785      */
 786     @Override
 787     public AATileGenerator getAATileGenerator(Shape s,
 788                                               AffineTransform at,
 789                                               Region clip,
 790                                               BasicStroke bs,
 791                                               boolean thin,
 792                                               boolean normalize,
<span class="changed"> 793                                               int bbox[])</span>
 794     {
 795         MarlinTileGenerator ptg = null;
 796         Renderer r = null;
 797 
 798         final RendererContext rdrCtx = getRendererContext();
 799         try {
 800             // Test if at is identity:
 801             final AffineTransform _at = (at != null &amp;&amp; !at.isIdentity()) ? at
 802                                         : null;
 803 
 804             final NormMode norm = (normalize) ? NormMode.ON_WITH_AA : NormMode.OFF;
 805 
 806             if (bs == null) {
 807                 // fill shape:
 808                 final PathIterator pi = getNormalizingPathIterator(rdrCtx, norm,
 809                                             s.getPathIterator(_at));
 810 

 811                 r = rdrCtx.renderer.init(clip.getLoX(), clip.getLoY(),
 812                                          clip.getWidth(), clip.getHeight(),
 813                                          pi.getWindingRule());
 814 
 815                 // TODO: subdivide quad/cubic curves into monotonic curves ?
 816                 pathTo(rdrCtx, pi, r);
 817             } else {
 818                 // draw shape with given stroke:
 819                 r = rdrCtx.renderer.init(clip.getLoX(), clip.getLoY(),
 820                                          clip.getWidth(), clip.getHeight(),
 821                                          PathIterator.WIND_NON_ZERO);
 822 
 823                 strokeTo(rdrCtx, s, _at, bs, thin, norm, true, r);
 824             }
 825             if (r.endRendering()) {
 826                 ptg = rdrCtx.ptg.init();
 827                 ptg.getBbox(bbox);
 828                 // note: do not returnRendererContext(rdrCtx)
 829                 // as it will be called later by MarlinTileGenerator.dispose()
 830                 r = null;
 831             }
 832         } finally {
 833             if (r != null) {
 834                 // dispose renderer:
 835                 r.dispose();
 836                 // recycle the RendererContext instance
 837                 MarlinRenderingEngine.returnRendererContext(rdrCtx);
 838             }
 839         }
 840 
 841         // Return null to cancel AA tile generation (nothing to render)
 842         return ptg;
 843     }
 844 
 845     @Override
 846     public final AATileGenerator getAATileGenerator(double x, double y,
 847                                                     double dx1, double dy1,
 848                                                     double dx2, double dy2,
 849                                                     double lw1, double lw2,
 850                                                     Region clip,
<span class="changed"> 851                                                     int bbox[])</span>
 852     {
 853         // REMIND: Deal with large coordinates!
 854         double ldx1, ldy1, ldx2, ldy2;
 855         boolean innerpgram = (lw1 &gt; 0.0 &amp;&amp; lw2 &gt; 0.0);
 856 
 857         if (innerpgram) {
 858             ldx1 = dx1 * lw1;
 859             ldy1 = dy1 * lw1;
 860             ldx2 = dx2 * lw2;
 861             ldy2 = dy2 * lw2;
 862             x -= (ldx1 + ldx2) / 2.0;
 863             y -= (ldy1 + ldy2) / 2.0;
 864             dx1 += ldx1;
 865             dy1 += ldy1;
 866             dx2 += ldx2;
 867             dy2 += ldy2;
 868             if (lw1 &gt; 1.0 &amp;&amp; lw2 &gt; 1.0) {
 869                 // Inner parallelogram was entirely consumed by stroke...
 870                 innerpgram = false;
 871             }

</pre><hr></hr><pre>
 932     public float getMinimumAAPenSize() {
 933         return MIN_PEN_SIZE;
 934     }
 935 
 936     static {
 937         if (PathIterator.WIND_NON_ZERO != Renderer.WIND_NON_ZERO ||
 938             PathIterator.WIND_EVEN_ODD != Renderer.WIND_EVEN_ODD ||
 939             BasicStroke.JOIN_MITER != Stroker.JOIN_MITER ||
 940             BasicStroke.JOIN_ROUND != Stroker.JOIN_ROUND ||
 941             BasicStroke.JOIN_BEVEL != Stroker.JOIN_BEVEL ||
 942             BasicStroke.CAP_BUTT != Stroker.CAP_BUTT ||
 943             BasicStroke.CAP_ROUND != Stroker.CAP_ROUND ||
 944             BasicStroke.CAP_SQUARE != Stroker.CAP_SQUARE)
 945         {
 946             throw new InternalError("mismatched renderer constants");
 947         }
 948     }
 949 
 950     // --- RendererContext handling ---
 951     // use ThreadLocal or ConcurrentLinkedQueue to get one RendererContext
<span class="changed"> 952     private static final boolean useThreadLocal;</span>
 953 
 954     // reference type stored in either TL or CLQ
 955     static final int REF_TYPE;
 956 
 957     // Per-thread RendererContext
<span class="changed"> 958     private static final ReentrantContextProvider&lt;RendererContext&gt; rdrCtxProvider;</span>
 959 
 960     // Static initializer to use TL or CLQ mode
 961     static {
<span class="changed"> 962         useThreadLocal = MarlinProperties.isUseThreadLocal();</span>
 963 
 964         // Soft reference by default:
 965         final String refType = AccessController.doPrivileged(
 966                             new GetPropertyAction("sun.java2d.renderer.useRef",
 967                             "soft"));
 968         switch (refType) {
 969             default:
 970             case "soft":
 971                 REF_TYPE = ReentrantContextProvider.REF_SOFT;
 972                 break;
 973             case "weak":
 974                 REF_TYPE = ReentrantContextProvider.REF_WEAK;
 975                 break;
 976             case "hard":
 977                 REF_TYPE = ReentrantContextProvider.REF_HARD;
 978                 break;
 979         }
 980 
<span class="changed"> 981         if (useThreadLocal) {</span>
<span class="changed"> 982             rdrCtxProvider = new ReentrantContextProviderTL&lt;RendererContext&gt;(REF_TYPE)</span>
 983                 {
 984                     @Override
 985                     protected RendererContext newContext() {
 986                         return RendererContext.createContext();
 987                     }
 988                 };
 989         } else {
<span class="changed"> 990             rdrCtxProvider = new ReentrantContextProviderCLQ&lt;RendererContext&gt;(REF_TYPE)</span>
 991                 {
 992                     @Override
 993                     protected RendererContext newContext() {
 994                         return RendererContext.createContext();
 995                     }
 996                 };
 997         }
 998     }
 999 
<span class="changed">1000     private static boolean settingsLogged = !enableLogs;</span>
1001 
1002     private static void logSettings(final String reClass) {
1003         // log information at startup
<span class="changed">1004         if (settingsLogged) {</span>
1005             return;
1006         }
<span class="changed">1007         settingsLogged = true;</span>
1008 
1009         String refType;
1010         switch (REF_TYPE) {
1011             default:
1012             case ReentrantContextProvider.REF_HARD:
1013                 refType = "hard";
1014                 break;
1015             case ReentrantContextProvider.REF_SOFT:
1016                 refType = "soft";
1017                 break;
1018             case ReentrantContextProvider.REF_WEAK:
1019                 refType = "weak";
1020                 break;
1021         }
1022 
1023         logInfo("=========================================================="
1024                 + "=====================");
1025 
1026         logInfo("Marlin software rasterizer           = ENABLED");
1027         logInfo("Version                              = ["
1028                 + Version.getVersion() + "]");
1029         logInfo("sun.java2d.renderer                  = "
1030                 + reClass);
1031         logInfo("sun.java2d.renderer.useThreadLocal   = "
<span class="changed">1032                 + useThreadLocal);</span>
1033         logInfo("sun.java2d.renderer.useRef           = "
1034                 + refType);
1035 
1036         logInfo("sun.java2d.renderer.pixelsize        = "
1037                 + MarlinConst.INITIAL_PIXEL_DIM);
1038         logInfo("sun.java2d.renderer.subPixel_log2_X  = "
1039                 + MarlinConst.SUBPIXEL_LG_POSITIONS_X);
1040         logInfo("sun.java2d.renderer.subPixel_log2_Y  = "
1041                 + MarlinConst.SUBPIXEL_LG_POSITIONS_Y);
1042         logInfo("sun.java2d.renderer.tileSize_log2    = "
1043                 + MarlinConst.TILE_SIZE_LG);
1044 
1045         logInfo("sun.java2d.renderer.blockSize_log2   = "
1046                 + MarlinConst.BLOCK_SIZE_LG);
1047 
1048         logInfo("sun.java2d.renderer.blockSize_log2   = "
1049                 + MarlinConst.BLOCK_SIZE_LG);
1050 
1051         // RLE / blockFlags settings
1052 
1053         logInfo("sun.java2d.renderer.forceRLE         = "
1054                 + MarlinProperties.isForceRLE());
1055         logInfo("sun.java2d.renderer.forceNoRLE       = "
1056                 + MarlinProperties.isForceNoRLE());
1057         logInfo("sun.java2d.renderer.useTileFlags     = "
1058                 + MarlinProperties.isUseTileFlags());
1059         logInfo("sun.java2d.renderer.useTileFlags.useHeuristics = "
1060                 + MarlinProperties.isUseTileFlagsWithHeuristics());
1061         logInfo("sun.java2d.renderer.rleMinWidth      = "
1062                 + MarlinCache.RLE_MIN_WIDTH);
1063 
1064         // optimisation parameters
1065         logInfo("sun.java2d.renderer.useSimplifier    = "
<span class="changed">1066                 + MarlinConst.useSimplifier);</span>
1067 
1068         // debugging parameters
1069         logInfo("sun.java2d.renderer.doStats          = "
<span class="changed">1070                 + MarlinConst.doStats);</span>
1071         logInfo("sun.java2d.renderer.doMonitors       = "
<span class="changed">1072                 + MarlinConst.doMonitors);</span>
1073         logInfo("sun.java2d.renderer.doChecks         = "
<span class="changed">1074                 + MarlinConst.doChecks);</span>
1075 
1076         // logging parameters
1077         logInfo("sun.java2d.renderer.useLogger        = "
<span class="changed">1078                 + MarlinConst.useLogger);</span>
1079         logInfo("sun.java2d.renderer.logCreateContext = "
<span class="changed">1080                 + MarlinConst.logCreateContext);</span>
1081         logInfo("sun.java2d.renderer.logUnsafeMalloc  = "
<span class="changed">1082                 + MarlinConst.logUnsafeMalloc);</span>
1083 
1084         // quality settings
1085         logInfo("Renderer settings:");
1086         logInfo("CUB_COUNT_LG = " + Renderer.CUB_COUNT_LG);
1087         logInfo("CUB_DEC_BND  = " + Renderer.CUB_DEC_BND);
1088         logInfo("CUB_INC_BND  = " + Renderer.CUB_INC_BND);
1089         logInfo("QUAD_DEC_BND = " + Renderer.QUAD_DEC_BND);
1090 
1091         logInfo("=========================================================="
1092                 + "=====================");
1093     }
1094 
1095     /**
1096      * Get the RendererContext instance dedicated to the current thread
1097      * @return RendererContext instance
1098      */
1099     @SuppressWarnings({"unchecked"})
1100     static RendererContext getRendererContext() {
<span class="changed">1101         final RendererContext rdrCtx = rdrCtxProvider.acquire();</span>
<span class="changed">1102         if (doMonitors) {</span>
<span class="changed">1103             RendererContext.stats.mon_pre_getAATileGenerator.start();</span>
1104         }
1105         return rdrCtx;
1106     }
1107 
1108     /**
1109      * Reset and return the given RendererContext instance for reuse
1110      * @param rdrCtx RendererContext instance
1111      */
1112     static void returnRendererContext(final RendererContext rdrCtx) {
1113         rdrCtx.dispose();
1114 
<span class="changed">1115         if (doMonitors) {</span>
<span class="changed">1116             RendererContext.stats.mon_pre_getAATileGenerator.stop();</span>
1117         }
<span class="changed">1118         rdrCtxProvider.release(rdrCtx);</span>
1119     }
1120 }
</pre></td><td><pre>

</pre><hr></hr><pre>
  68      * The specified {@code src} {@link Shape} is widened according
  69      * to the specified attribute parameters as per the
  70      * {@link BasicStroke} specification.
  71      *
  72      * @param src the source path to be widened
  73      * @param width the width of the widened path as per {@code BasicStroke}
  74      * @param caps the end cap decorations as per {@code BasicStroke}
  75      * @param join the segment join decorations as per {@code BasicStroke}
  76      * @param miterlimit the miter limit as per {@code BasicStroke}
  77      * @param dashes the dash length array as per {@code BasicStroke}
  78      * @param dashphase the initial dash phase as per {@code BasicStroke}
  79      * @return the widened path stored in a new {@code Shape} object
  80      * @since 1.7
  81      */
  82     @Override
  83     public Shape createStrokedShape(Shape src,
  84                                     float width,
  85                                     int caps,
  86                                     int join,
  87                                     float miterlimit,
<span class="changed">  88                                     float[] dashes,</span>
  89                                     float dashphase)
  90     {
  91         final RendererContext rdrCtx = getRendererContext();
  92         try {
  93             // initialize a large copyable Path2D to avoid a lot of array growing:
  94             final Path2D.Float p2d =
  95                     (rdrCtx.p2d == null) ?
  96                     (rdrCtx.p2d = new Path2D.Float(Path2D.WIND_NON_ZERO,
  97                                                    INITIAL_MEDIUM_ARRAY))
  98                     : rdrCtx.p2d;
  99             // reset
 100             p2d.reset();
 101 
 102             strokeTo(rdrCtx,
 103                      src,
 104                      null,
 105                      width,
 106                      NormMode.OFF,
 107                      caps,
 108                      join,

</pre><hr></hr><pre>
 261              */
 262 
 263             double hypot = Math.sqrt(EB*EB + (EA-EC)*(EA-EC));
 264             // sqrt omitted, compare to squared limits below.
 265             double widthsquared = ((EA + EC + hypot)/2.0);
 266 
 267             widthScale = (float)Math.sqrt(widthsquared);
 268         }
 269 
 270         return (lw / widthScale);
 271     }
 272 
 273     final void strokeTo(final RendererContext rdrCtx,
 274                         Shape src,
 275                         AffineTransform at,
 276                         float width,
 277                         NormMode normalize,
 278                         int caps,
 279                         int join,
 280                         float miterlimit,
<span class="changed"> 281                         float[] dashes,</span>
 282                         float dashphase,
 283                         PathConsumer2D pc2d)
 284     {
 285         // We use strokerat so that in Stroker and Dasher we can work only
 286         // with the pre-transformation coordinates. This will repeat a lot of
 287         // computations done in the path iterator, but the alternative is to
 288         // work with transformed paths and compute untransformed coordinates
 289         // as needed. This would be faster but I do not think the complexity
 290         // of working with both untransformed and transformed coordinates in
 291         // the same code is worth it.
 292         // However, if a path's width is constant after a transformation,
 293         // we can skip all this untransforming.
 294 
 295         // As pathTo() will check transformed coordinates for invalid values
 296         // (NaN / Infinity) to ignore such points, it is necessary to apply the
 297         // transformation before the path processing.
 298         AffineTransform strokerat = null;
 299 
 300         int dashLen = -1;
 301         boolean recycleDashes = false;

</pre><hr></hr><pre>
 323                 pc2d.pathDone();
 324                 return;
 325             }
 326 
 327             // If the transform is a constant multiple of an orthogonal transformation
 328             // then every length is just multiplied by a constant, so we just
 329             // need to transform input paths to stroker and tell stroker
 330             // the scaled width. This condition is satisfied if
 331             // a*b == -c*d &amp;&amp; a*a+c*c == b*b+d*d. In the actual check below, we
 332             // leave a bit of room for error.
 333             if (nearZero(a*b + c*d) &amp;&amp; nearZero(a*a + c*c - (b*b + d*d))) {
 334                 final float scale = (float) Math.sqrt(a*a + c*c);
 335 
 336                 if (dashes != null) {
 337                     recycleDashes = true;
 338                     dashLen = dashes.length;
 339                     final float[] newDashes;
 340                     if (dashLen &lt;= INITIAL_ARRAY) {
 341                         newDashes = rdrCtx.dasher.dashes_initial;
 342                     } else {
<span class="changed"> 343                         if (DO_STATS) {</span>
<span class="changed"> 344                             rdrCtx.stats.stat_array_dasher_dasher</span>
 345                                 .add(dashLen);
 346                         }
 347                         newDashes = rdrCtx.getDirtyFloatArray(dashLen);
 348                     }
 349                     System.arraycopy(dashes, 0, newDashes, 0, dashLen);
 350                     dashes = newDashes;
 351                     for (int i = 0; i &lt; dashLen; i++) {
 352                         dashes[i] *= scale;
 353                     }
 354                     dashphase *= scale;
 355                 }
 356                 width *= scale;
 357 
 358                 // by now strokerat == null. Input paths to
 359                 // stroker (and maybe dasher) will have the full transform at
 360                 // applied to them and nothing will happen to the output paths.
 361             } else {
 362                 strokerat = at;
 363 
 364                 // by now strokerat == at. Input paths to
 365                 // stroker (and maybe dasher) will have the full transform at
 366                 // applied to them, then they will be normalized, and then
 367                 // the inverse of *only the non translation part of at* will
 368                 // be applied to the normalized paths. This won't cause problems
 369                 // in stroker, because, suppose at = T*A, where T is just the
 370                 // translation part of at, and A is the rest. T*A has already
 371                 // been applied to Stroker/Dasher's input. Then Ainv will be
 372                 // applied. Ainv*T*A is not equal to T, but it is a translation,
 373                 // which means that none of stroker's assumptions about its
 374                 // input will be violated. After all this, A will be applied
 375                 // to stroker's output.
 376             }
 377         } else {
 378             // either at is null or it's the identity. In either case
 379             // we don't transform the path.
 380             at = null;
 381         }
 382 
<span class="changed"> 383         if (USE_SIMPLIFIER) {</span>
 384             // Use simplifier after stroker before Renderer
 385             // to remove collinear segments (notably due to cap square)
 386             pc2d = rdrCtx.simplifier.init(pc2d);
 387         }
 388 
 389         final TransformingPathConsumer2D transformerPC2D = rdrCtx.transformerPC2D;
 390         pc2d = transformerPC2D.deltaTransformConsumer(pc2d, strokerat);
 391 
 392         pc2d = rdrCtx.stroker.init(pc2d, width, caps, join, miterlimit);
 393 
 394         if (dashes != null) {
 395             if (!recycleDashes) {
 396                 dashLen = dashes.length;
 397             }
 398             pc2d = rdrCtx.dasher.init(pc2d, dashes, dashLen, dashphase,
 399                                       recycleDashes);
 400         }
 401         pc2d = transformerPC2D.inverseDeltaTransformConsumer(pc2d, strokerat);
 402 
 403         final PathIterator pi = getNormalizingPathIterator(rdrCtx, normalize,

</pre><hr></hr><pre>
 457         NormalizingPathIterator(final float[] tmp) {
 458             this.tmp = tmp;
 459         }
 460 
 461         final NormalizingPathIterator init(final PathIterator src) {
 462             this.src = src;
 463             return this; // fluent API
 464         }
 465 
 466         /**
 467          * Disposes this path iterator:
 468          * clean up before reusing this instance
 469          */
 470         final void dispose() {
 471             // free source PathIterator:
 472             this.src = null;
 473         }
 474 
 475         @Override
 476         public final int currentSegment(final float[] coords) {



 477             int lastCoord;
 478             final int type = src.currentSegment(coords);
 479 
 480             switch(type) {
 481                 case PathIterator.SEG_MOVETO:
 482                 case PathIterator.SEG_LINETO:
 483                     lastCoord = 0;
 484                     break;
 485                 case PathIterator.SEG_QUADTO:
 486                     lastCoord = 2;
 487                     break;
 488                 case PathIterator.SEG_CUBICTO:
 489                     lastCoord = 4;
 490                     break;
 491                 case PathIterator.SEG_CLOSE:
 492                     // we don't want to deal with this case later. We just exit now
 493                     curx_adjust = movx_adjust;
 494                     cury_adjust = movy_adjust;




 495                     return type;
 496                 default:
 497                     throw new InternalError("Unrecognized curve type");
 498             }
 499 


 500             // normalize endpoint
 501             float coord, x_adjust, y_adjust;
 502 
 503             coord = coords[lastCoord];
 504             x_adjust = normCoord(coord); // new coord
 505             coords[lastCoord] = x_adjust;
 506             x_adjust -= coord;
 507 
 508             coord = coords[lastCoord + 1];
 509             y_adjust = normCoord(coord); // new coord
 510             coords[lastCoord + 1] = y_adjust;
 511             y_adjust -= coord;
 512 
 513             // now that the end points are done, normalize the control points
 514             switch(type) {
 515                 case PathIterator.SEG_MOVETO:
 516                     movx_adjust = x_adjust;
 517                     movy_adjust = y_adjust;
 518                     break;
 519                 case PathIterator.SEG_LINETO:
 520                     break;
 521                 case PathIterator.SEG_QUADTO:
 522                     coords[0] += (curx_adjust + x_adjust) / 2f;
 523                     coords[1] += (cury_adjust + y_adjust) / 2f;
 524                     break;
 525                 case PathIterator.SEG_CUBICTO:
 526                     coords[0] += curx_adjust;
 527                     coords[1] += cury_adjust;
 528                     coords[2] += x_adjust;
 529                     coords[3] += y_adjust;
 530                     break;
 531                 case PathIterator.SEG_CLOSE:
 532                     // handled earlier
 533                 default:
 534             }
 535             curx_adjust = x_adjust;
 536             cury_adjust = y_adjust;




 537             return type;
 538         }
 539 
 540         abstract float normCoord(final float coord);
 541 
 542         @Override
 543         public final int currentSegment(final double[] coords) {
 544             final float[] _tmp = tmp; // dirty
 545             int type = this.currentSegment(_tmp);
 546             for (int i = 0; i &lt; 6; i++) {
 547                 coords[i] = _tmp[i];
 548             }
 549             return type;
 550         }
 551 
 552         @Override
 553         public final int getWindingRule() {
 554             return src.getWindingRule();
 555         }
 556 

</pre><hr></hr><pre>
 760      *           stroke attributes
 761      * @param clip the current clip in effect in device coordinates
 762      * @param bs if non-null, a {@code BasicStroke} whose attributes
 763      *           should be applied to this operation
 764      * @param thin true if the transformed stroke attributes are smaller
 765      *             than the minimum dropout pen width
 766      * @param normalize true if the {@code VALUE_STROKE_NORMALIZE}
 767      *                  {@code RenderingHint} is in effect
 768      * @param bbox returns the bounds of the iteration
 769      * @return the {@code AATileGenerator} instance to be consulted
 770      *         for tile coverages, or null if there is no output to render
 771      * @since 1.7
 772      */
 773     @Override
 774     public AATileGenerator getAATileGenerator(Shape s,
 775                                               AffineTransform at,
 776                                               Region clip,
 777                                               BasicStroke bs,
 778                                               boolean thin,
 779                                               boolean normalize,
<span class="changed"> 780                                               int[] bbox)</span>
 781     {
 782         MarlinTileGenerator ptg = null;
 783         Renderer r = null;
 784 
 785         final RendererContext rdrCtx = getRendererContext();
 786         try {
 787             // Test if at is identity:
 788             final AffineTransform _at = (at != null &amp;&amp; !at.isIdentity()) ? at
 789                                         : null;
 790 
 791             final NormMode norm = (normalize) ? NormMode.ON_WITH_AA : NormMode.OFF;
 792 
 793             if (bs == null) {
 794                 // fill shape:
 795                 final PathIterator pi = getNormalizingPathIterator(rdrCtx, norm,
 796                                             s.getPathIterator(_at));
 797 
<span class="new"> 798                 // note: Winding rule may be EvenOdd ONLY for fill operations !</span>
 799                 r = rdrCtx.renderer.init(clip.getLoX(), clip.getLoY(),
 800                                          clip.getWidth(), clip.getHeight(),
 801                                          pi.getWindingRule());
 802 
 803                 // TODO: subdivide quad/cubic curves into monotonic curves ?
 804                 pathTo(rdrCtx, pi, r);
 805             } else {
 806                 // draw shape with given stroke:
 807                 r = rdrCtx.renderer.init(clip.getLoX(), clip.getLoY(),
 808                                          clip.getWidth(), clip.getHeight(),
 809                                          PathIterator.WIND_NON_ZERO);
 810 
 811                 strokeTo(rdrCtx, s, _at, bs, thin, norm, true, r);
 812             }
 813             if (r.endRendering()) {
 814                 ptg = rdrCtx.ptg.init();
 815                 ptg.getBbox(bbox);
 816                 // note: do not returnRendererContext(rdrCtx)
 817                 // as it will be called later by MarlinTileGenerator.dispose()
 818                 r = null;
 819             }
 820         } finally {
 821             if (r != null) {
 822                 // dispose renderer:
 823                 r.dispose();
 824                 // recycle the RendererContext instance
 825                 MarlinRenderingEngine.returnRendererContext(rdrCtx);
 826             }
 827         }
 828 
 829         // Return null to cancel AA tile generation (nothing to render)
 830         return ptg;
 831     }
 832 
 833     @Override
 834     public final AATileGenerator getAATileGenerator(double x, double y,
 835                                                     double dx1, double dy1,
 836                                                     double dx2, double dy2,
 837                                                     double lw1, double lw2,
 838                                                     Region clip,
<span class="changed"> 839                                                     int[] bbox)</span>
 840     {
 841         // REMIND: Deal with large coordinates!
 842         double ldx1, ldy1, ldx2, ldy2;
 843         boolean innerpgram = (lw1 &gt; 0.0 &amp;&amp; lw2 &gt; 0.0);
 844 
 845         if (innerpgram) {
 846             ldx1 = dx1 * lw1;
 847             ldy1 = dy1 * lw1;
 848             ldx2 = dx2 * lw2;
 849             ldy2 = dy2 * lw2;
 850             x -= (ldx1 + ldx2) / 2.0;
 851             y -= (ldy1 + ldy2) / 2.0;
 852             dx1 += ldx1;
 853             dy1 += ldy1;
 854             dx2 += ldx2;
 855             dy2 += ldy2;
 856             if (lw1 &gt; 1.0 &amp;&amp; lw2 &gt; 1.0) {
 857                 // Inner parallelogram was entirely consumed by stroke...
 858                 innerpgram = false;
 859             }

</pre><hr></hr><pre>
 920     public float getMinimumAAPenSize() {
 921         return MIN_PEN_SIZE;
 922     }
 923 
 924     static {
 925         if (PathIterator.WIND_NON_ZERO != Renderer.WIND_NON_ZERO ||
 926             PathIterator.WIND_EVEN_ODD != Renderer.WIND_EVEN_ODD ||
 927             BasicStroke.JOIN_MITER != Stroker.JOIN_MITER ||
 928             BasicStroke.JOIN_ROUND != Stroker.JOIN_ROUND ||
 929             BasicStroke.JOIN_BEVEL != Stroker.JOIN_BEVEL ||
 930             BasicStroke.CAP_BUTT != Stroker.CAP_BUTT ||
 931             BasicStroke.CAP_ROUND != Stroker.CAP_ROUND ||
 932             BasicStroke.CAP_SQUARE != Stroker.CAP_SQUARE)
 933         {
 934             throw new InternalError("mismatched renderer constants");
 935         }
 936     }
 937 
 938     // --- RendererContext handling ---
 939     // use ThreadLocal or ConcurrentLinkedQueue to get one RendererContext
<span class="changed"> 940     private static final boolean USE_THREAD_LOCAL;</span>
 941 
 942     // reference type stored in either TL or CLQ
 943     static final int REF_TYPE;
 944 
 945     // Per-thread RendererContext
<span class="changed"> 946     private static final ReentrantContextProvider&lt;RendererContext&gt; RDR_CTX_PROVIDER;</span>
 947 
 948     // Static initializer to use TL or CLQ mode
 949     static {
<span class="changed"> 950         USE_THREAD_LOCAL = MarlinProperties.isUseThreadLocal();</span>
 951 
 952         // Soft reference by default:
 953         final String refType = AccessController.doPrivileged(
 954                             new GetPropertyAction("sun.java2d.renderer.useRef",
 955                             "soft"));
 956         switch (refType) {
 957             default:
 958             case "soft":
 959                 REF_TYPE = ReentrantContextProvider.REF_SOFT;
 960                 break;
 961             case "weak":
 962                 REF_TYPE = ReentrantContextProvider.REF_WEAK;
 963                 break;
 964             case "hard":
 965                 REF_TYPE = ReentrantContextProvider.REF_HARD;
 966                 break;
 967         }
 968 
<span class="changed"> 969         if (USE_THREAD_LOCAL) {</span>
<span class="changed"> 970             RDR_CTX_PROVIDER = new ReentrantContextProviderTL&lt;RendererContext&gt;(REF_TYPE)</span>
 971                 {
 972                     @Override
 973                     protected RendererContext newContext() {
 974                         return RendererContext.createContext();
 975                     }
 976                 };
 977         } else {
<span class="changed"> 978             RDR_CTX_PROVIDER = new ReentrantContextProviderCLQ&lt;RendererContext&gt;(REF_TYPE)</span>
 979                 {
 980                     @Override
 981                     protected RendererContext newContext() {
 982                         return RendererContext.createContext();
 983                     }
 984                 };
 985         }
 986     }
 987 
<span class="changed"> 988     private static boolean SETTINGS_LOGGED = !ENABLE_LOGS;</span>
 989 
 990     private static void logSettings(final String reClass) {
 991         // log information at startup
<span class="changed"> 992         if (SETTINGS_LOGGED) {</span>
 993             return;
 994         }
<span class="changed"> 995         SETTINGS_LOGGED = true;</span>
 996 
 997         String refType;
 998         switch (REF_TYPE) {
 999             default:
1000             case ReentrantContextProvider.REF_HARD:
1001                 refType = "hard";
1002                 break;
1003             case ReentrantContextProvider.REF_SOFT:
1004                 refType = "soft";
1005                 break;
1006             case ReentrantContextProvider.REF_WEAK:
1007                 refType = "weak";
1008                 break;
1009         }
1010 
1011         logInfo("=========================================================="
1012                 + "=====================");
1013 
1014         logInfo("Marlin software rasterizer           = ENABLED");
1015         logInfo("Version                              = ["
1016                 + Version.getVersion() + "]");
1017         logInfo("sun.java2d.renderer                  = "
1018                 + reClass);
1019         logInfo("sun.java2d.renderer.useThreadLocal   = "
<span class="changed">1020                 + USE_THREAD_LOCAL);</span>
1021         logInfo("sun.java2d.renderer.useRef           = "
1022                 + refType);
1023 
1024         logInfo("sun.java2d.renderer.pixelsize        = "
1025                 + MarlinConst.INITIAL_PIXEL_DIM);
1026         logInfo("sun.java2d.renderer.subPixel_log2_X  = "
1027                 + MarlinConst.SUBPIXEL_LG_POSITIONS_X);
1028         logInfo("sun.java2d.renderer.subPixel_log2_Y  = "
1029                 + MarlinConst.SUBPIXEL_LG_POSITIONS_Y);
1030         logInfo("sun.java2d.renderer.tileSize_log2    = "
1031                 + MarlinConst.TILE_SIZE_LG);
1032 
1033         logInfo("sun.java2d.renderer.blockSize_log2   = "
1034                 + MarlinConst.BLOCK_SIZE_LG);
1035 
1036         logInfo("sun.java2d.renderer.blockSize_log2   = "
1037                 + MarlinConst.BLOCK_SIZE_LG);
1038 
1039         // RLE / blockFlags settings
1040 
1041         logInfo("sun.java2d.renderer.forceRLE         = "
1042                 + MarlinProperties.isForceRLE());
1043         logInfo("sun.java2d.renderer.forceNoRLE       = "
1044                 + MarlinProperties.isForceNoRLE());
1045         logInfo("sun.java2d.renderer.useTileFlags     = "
1046                 + MarlinProperties.isUseTileFlags());
1047         logInfo("sun.java2d.renderer.useTileFlags.useHeuristics = "
1048                 + MarlinProperties.isUseTileFlagsWithHeuristics());
1049         logInfo("sun.java2d.renderer.rleMinWidth      = "
1050                 + MarlinCache.RLE_MIN_WIDTH);
1051 
1052         // optimisation parameters
1053         logInfo("sun.java2d.renderer.useSimplifier    = "
<span class="changed">1054                 + MarlinConst.USE_SIMPLIFIER);</span>
1055 
1056         // debugging parameters
1057         logInfo("sun.java2d.renderer.doStats          = "
<span class="changed">1058                 + MarlinConst.DO_STATS);</span>
1059         logInfo("sun.java2d.renderer.doMonitors       = "
<span class="changed">1060                 + MarlinConst.DO_MONITORS);</span>
1061         logInfo("sun.java2d.renderer.doChecks         = "
<span class="changed">1062                 + MarlinConst.DO_CHECKS);</span>
1063 
1064         // logging parameters
1065         logInfo("sun.java2d.renderer.useLogger        = "
<span class="changed">1066                 + MarlinConst.USE_LOGGER);</span>
1067         logInfo("sun.java2d.renderer.logCreateContext = "
<span class="changed">1068                 + MarlinConst.LOG_CREATE_CONTEXT);</span>
1069         logInfo("sun.java2d.renderer.logUnsafeMalloc  = "
<span class="changed">1070                 + MarlinConst.LOG_UNSAFE_MALLOC);</span>
1071 
1072         // quality settings
1073         logInfo("Renderer settings:");
1074         logInfo("CUB_COUNT_LG = " + Renderer.CUB_COUNT_LG);
1075         logInfo("CUB_DEC_BND  = " + Renderer.CUB_DEC_BND);
1076         logInfo("CUB_INC_BND  = " + Renderer.CUB_INC_BND);
1077         logInfo("QUAD_DEC_BND = " + Renderer.QUAD_DEC_BND);
1078 
1079         logInfo("=========================================================="
1080                 + "=====================");
1081     }
1082 
1083     /**
1084      * Get the RendererContext instance dedicated to the current thread
1085      * @return RendererContext instance
1086      */
1087     @SuppressWarnings({"unchecked"})
1088     static RendererContext getRendererContext() {
<span class="changed">1089         final RendererContext rdrCtx = RDR_CTX_PROVIDER.acquire();</span>
<span class="changed">1090         if (DO_MONITORS) {</span>
<span class="changed">1091             rdrCtx.stats.mon_pre_getAATileGenerator.start();</span>
1092         }
1093         return rdrCtx;
1094     }
1095 
1096     /**
1097      * Reset and return the given RendererContext instance for reuse
1098      * @param rdrCtx RendererContext instance
1099      */
1100     static void returnRendererContext(final RendererContext rdrCtx) {
1101         rdrCtx.dispose();
1102 
<span class="changed">1103         if (DO_MONITORS) {</span>
<span class="changed">1104             rdrCtx.stats.mon_pre_getAATileGenerator.stop();</span>
1105         }
<span class="changed">1106         RDR_CTX_PROVIDER.release(rdrCtx);</span>
1107     }
1108 }
</pre></td>
</tr></table>
<center><a href='../../../../../../src/share/classes/sun/java2d/marlin/MarlinConst.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../src/share/classes/sun/java2d/marlin/MarlinTileGenerator.java.sdiff.html' target='_top'>next &gt</a></center>
</body></html>
