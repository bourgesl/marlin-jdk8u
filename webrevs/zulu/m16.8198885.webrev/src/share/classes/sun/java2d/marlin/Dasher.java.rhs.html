<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-13695">13695</a> : <a href="https://bugs.openjdk.java.net/browse/JDK-8198885">8198885</a>: upgrade Marlin (java2d) to 0.9.1
Summary: clipping implemented in Dasher (curve subdivision at clip edges) + higher quality(curve, subpixels) + new path simplifier
Reviewed-by: prr, serb</pre><hr></hr>
<pre>
   1 /*
<a name="1" id="anc1"></a><span class="changed">   2  * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the "Classpath" exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.java2d.marlin;
  27 
  28 import java.util.Arrays;
  29 import sun.awt.geom.PathConsumer2D;
<a name="2" id="anc2"></a><span class="new">  30 import sun.java2d.marlin.TransformingPathConsumer2D.CurveBasicMonotonizer;</span>
<span class="new">  31 import sun.java2d.marlin.TransformingPathConsumer2D.CurveClipSplitter;</span>
  32 
  33 /**
  34  * The &lt;code&gt;Dasher&lt;/code&gt; class takes a series of linear commands
  35  * (&lt;code&gt;moveTo&lt;/code&gt;, &lt;code&gt;lineTo&lt;/code&gt;, &lt;code&gt;close&lt;/code&gt; and
  36  * &lt;code&gt;end&lt;/code&gt;) and breaks them into smaller segments according to a
  37  * dash pattern array and a starting dash phase.
  38  *
  39  * &lt;p&gt; Issues: in J2Se, a zero length dash segment as drawn as a very
  40  * short dash, whereas Pisces does not draw anything.  The PostScript
  41  * semantics are unclear.
  42  *
  43  */
  44 final class Dasher implements PathConsumer2D, MarlinConst {
  45 
<a name="3" id="anc3"></a><span class="changed">  46     /* huge circle with radius ~ 2E9 only needs 12 subdivision levels */</span>
<span class="changed">  47     static final int REC_LIMIT = 16;</span>
<span class="changed">  48     static final float CURVE_LEN_ERR = MarlinProperties.getCurveLengthError(); // 0.01</span>
  49     static final float MIN_T_INC = 1.0f / (1 &lt;&lt; REC_LIMIT);
  50 
  51     // More than 24 bits of mantissa means we can no longer accurately
  52     // measure the number of times cycled through the dash array so we
  53     // punt and override the phase to just be 0 past that point.
  54     static final float MAX_CYCLES = 16000000.0f;
  55 
  56     private PathConsumer2D out;
  57     private float[] dash;
  58     private int dashLen;
  59     private float startPhase;
  60     private boolean startDashOn;
  61     private int startIdx;
  62 
  63     private boolean starting;
  64     private boolean needsMoveTo;
  65 
  66     private int idx;
  67     private boolean dashOn;
  68     private float phase;
  69 
<a name="4" id="anc4"></a><span class="changed">  70     // The starting point of the path</span>
<span class="changed">  71     private float sx0, sy0;</span>
<span class="changed">  72     // the current point</span>
<span class="changed">  73     private float cx0, cy0;</span>
  74 
  75     // temporary storage for the current curve
  76     private final float[] curCurvepts;
  77 
  78     // per-thread renderer context
  79     final RendererContext rdrCtx;
  80 
  81     // flag to recycle dash array copy
  82     boolean recycleDashes;
  83 
<a name="5" id="anc5"></a><span class="new">  84     // We don't emit the first dash right away. If we did, caps would be</span>
<span class="new">  85     // drawn on it, but we need joins to be drawn if there's a closePath()</span>
<span class="new">  86     // So, we store the path elements that make up the first dash in the</span>
<span class="new">  87     // buffer below.</span>
<span class="new">  88     private float[] firstSegmentsBuffer; // dynamic array</span>
<span class="new">  89     private int firstSegidx;</span>
<span class="new">  90 </span>
  91     // dashes ref (dirty)
  92     final FloatArrayCache.Reference dashes_ref;
  93     // firstSegmentsBuffer ref (dirty)
  94     final FloatArrayCache.Reference firstSegmentsBuffer_ref;
  95 
<a name="6" id="anc6"></a><span class="new">  96     // Bounds of the drawing region, at pixel precision.</span>
<span class="new">  97     private float[] clipRect;</span>
<span class="new">  98 </span>
<span class="new">  99     // the outcode of the current point</span>
<span class="new"> 100     private int cOutCode = 0;</span>
<span class="new"> 101 </span>
<span class="new"> 102     private boolean subdivide = DO_CLIP_SUBDIVIDER;</span>
<span class="new"> 103 </span>
<span class="new"> 104     private final LengthIterator li = new LengthIterator();</span>
<span class="new"> 105 </span>
<span class="new"> 106     private final CurveClipSplitter curveSplitter;</span>
<span class="new"> 107 </span>
<span class="new"> 108     private float cycleLen;</span>
<span class="new"> 109     private boolean outside;</span>
<span class="new"> 110     private float totalSkipLen;</span>
<span class="new"> 111 </span>
 112     /**
 113      * Constructs a &lt;code&gt;Dasher&lt;/code&gt;.
 114      * @param rdrCtx per-thread renderer context
 115      */
 116     Dasher(final RendererContext rdrCtx) {
 117         this.rdrCtx = rdrCtx;
 118 
 119         dashes_ref = rdrCtx.newDirtyFloatArrayRef(INITIAL_ARRAY); // 1K
 120 
 121         firstSegmentsBuffer_ref = rdrCtx.newDirtyFloatArrayRef(INITIAL_ARRAY); // 1K
 122         firstSegmentsBuffer     = firstSegmentsBuffer_ref.initial;
 123 
 124         // we need curCurvepts to be able to contain 2 curves because when
 125         // dashing curves, we need to subdivide it
 126         curCurvepts = new float[8 * 2];
<a name="7" id="anc7"></a><span class="new"> 127 </span>
<span class="new"> 128         this.curveSplitter = rdrCtx.curveClipSplitter;</span>
 129     }
 130 
 131     /**
 132      * Initialize the &lt;code&gt;Dasher&lt;/code&gt;.
 133      *
 134      * @param out an output &lt;code&gt;PathConsumer2D&lt;/code&gt;.
 135      * @param dash an array of &lt;code&gt;float&lt;/code&gt;s containing the dash pattern
 136      * @param dashLen length of the given dash array
 137      * @param phase a &lt;code&gt;float&lt;/code&gt; containing the dash phase
 138      * @param recycleDashes true to indicate to recycle the given dash array
 139      * @return this instance
 140      */
 141     Dasher init(final PathConsumer2D out, float[] dash, int dashLen,
 142                 float phase, boolean recycleDashes)
 143     {
 144         this.out = out;
 145 
 146         // Normalize so 0 &lt;= phase &lt; dash[0]
 147         int sidx = 0;
 148         dashOn = true;
<a name="8" id="anc8"></a><span class="new"> 149 </span>
 150         float sum = 0.0f;
 151         for (float d : dash) {
 152             sum += d;
 153         }
<a name="9" id="anc9"></a><span class="new"> 154         this.cycleLen = sum;</span>
<span class="new"> 155 </span>
 156         float cycles = phase / sum;
 157         if (phase &lt; 0.0f) {
 158             if (-cycles &gt;= MAX_CYCLES) {
 159                 phase = 0.0f;
 160             } else {
 161                 int fullcycles = FloatMath.floor_int(-cycles);
 162                 if ((fullcycles &amp; dash.length &amp; 1) != 0) {
 163                     dashOn = !dashOn;
 164                 }
 165                 phase += fullcycles * sum;
 166                 while (phase &lt; 0.0f) {
 167                     if (--sidx &lt; 0) {
 168                         sidx = dash.length - 1;
 169                     }
 170                     phase += dash[sidx];
 171                     dashOn = !dashOn;
 172                 }
 173             }
 174         } else if (phase &gt; 0.0f) {
 175             if (cycles &gt;= MAX_CYCLES) {
 176                 phase = 0.0f;
 177             } else {
 178                 int fullcycles = FloatMath.floor_int(cycles);
 179                 if ((fullcycles &amp; dash.length &amp; 1) != 0) {
 180                     dashOn = !dashOn;
 181                 }
 182                 phase -= fullcycles * sum;
 183                 float d;
 184                 while (phase &gt;= (d = dash[sidx])) {
 185                     phase -= d;
 186                     sidx = (sidx + 1) % dash.length;
 187                     dashOn = !dashOn;
 188                 }
 189             }
 190         }
 191 
 192         this.dash = dash;
 193         this.dashLen = dashLen;
 194         this.phase = phase;
 195         this.startPhase = phase;
 196         this.startDashOn = dashOn;
 197         this.startIdx = sidx;
 198         this.starting = true;
 199         this.needsMoveTo = false;
 200         this.firstSegidx = 0;
 201 
 202         this.recycleDashes = recycleDashes;
 203 
<a name="10" id="anc10"></a><span class="new"> 204         if (rdrCtx.doClip) {</span>
<span class="new"> 205             this.clipRect = rdrCtx.clipRect;</span>
<span class="new"> 206         } else {</span>
<span class="new"> 207             this.clipRect = null;</span>
<span class="new"> 208             this.cOutCode = 0;</span>
<span class="new"> 209         }</span>
 210         return this; // fluent API
 211     }
 212 
 213     /**
 214      * Disposes this dasher:
 215      * clean up before reusing this instance
 216      */
 217     void dispose() {
 218         if (DO_CLEAN_DIRTY) {
 219             // Force zero-fill dirty arrays:
 220             Arrays.fill(curCurvepts, 0.0f);
 221         }
 222         // Return arrays:
 223         if (recycleDashes) {
 224             dash = dashes_ref.putArray(dash);
 225         }
 226         firstSegmentsBuffer = firstSegmentsBuffer_ref.putArray(firstSegmentsBuffer);
 227     }
 228 
 229     float[] copyDashArray(final float[] dashes) {
 230         final int len = dashes.length;
 231         final float[] newDashes;
 232         if (len &lt;= MarlinConst.INITIAL_ARRAY) {
 233             newDashes = dashes_ref.initial;
 234         } else {
 235             if (DO_STATS) {
 236                 rdrCtx.stats.stat_array_dasher_dasher.add(len);
 237             }
 238             newDashes = dashes_ref.getArray(len);
 239         }
 240         System.arraycopy(dashes, 0, newDashes, 0, len);
 241         return newDashes;
 242     }
 243 
 244     @Override
 245     public void moveTo(final float x0, final float y0) {
 246         if (firstSegidx != 0) {
<a name="11" id="anc11"></a><span class="changed"> 247             out.moveTo(sx0, sy0);</span>
 248             emitFirstSegments();
 249         }
<a name="12" id="anc12"></a><span class="changed"> 250         this.needsMoveTo = true;</span>
 251         this.idx = startIdx;
 252         this.dashOn = this.startDashOn;
 253         this.phase = this.startPhase;
<a name="13" id="anc13"></a><span class="changed"> 254         this.cx0 = x0;</span>
<span class="changed"> 255         this.cy0 = y0;</span>
<span class="changed"> 256 </span>
<span class="changed"> 257         // update starting point:</span>
<span class="changed"> 258         this.sx0 = x0;</span>
<span class="changed"> 259         this.sy0 = y0;</span>
 260         this.starting = true;
<a name="14" id="anc14"></a><span class="new"> 261 </span>
<span class="new"> 262         if (clipRect != null) {</span>
<span class="new"> 263             final int outcode = Helpers.outcode(x0, y0, clipRect);</span>
<span class="new"> 264             this.cOutCode = outcode;</span>
<span class="new"> 265             this.outside = false;</span>
<span class="new"> 266             this.totalSkipLen = 0.0f;</span>
<span class="new"> 267         }</span>
 268     }
 269 
 270     private void emitSeg(float[] buf, int off, int type) {
 271         switch (type) {
 272         case 8:
<a name="15" id="anc15"></a><span class="changed"> 273             out.curveTo(buf[off    ], buf[off + 1],</span>
<span class="changed"> 274                         buf[off + 2], buf[off + 3],</span>
<span class="changed"> 275                         buf[off + 4], buf[off + 5]);</span>
 276             return;
 277         case 6:
<a name="16" id="anc16"></a><span class="changed"> 278             out.quadTo(buf[off    ], buf[off + 1],</span>
<span class="changed"> 279                        buf[off + 2], buf[off + 3]);</span>
 280             return;
 281         case 4:
<a name="17" id="anc17"></a><span class="changed"> 282             out.lineTo(buf[off], buf[off + 1]);</span>
 283             return;
 284         default:
 285         }
 286     }
 287 
 288     private void emitFirstSegments() {
 289         final float[] fSegBuf = firstSegmentsBuffer;
 290 
 291         for (int i = 0, len = firstSegidx; i &lt; len; ) {
 292             int type = (int)fSegBuf[i];
 293             emitSeg(fSegBuf, i + 1, type);
 294             i += (type - 1);
 295         }
 296         firstSegidx = 0;
 297     }
<a name="18" id="anc18"></a>





 298 
 299     // precondition: pts must be in relative coordinates (relative to x0,y0)
 300     private void goTo(final float[] pts, final int off, final int type,
 301                       final boolean on)
 302     {
 303         final int index = off + type;
 304         final float x = pts[index - 4];
 305         final float y = pts[index - 3];
 306 
 307         if (on) {
 308             if (starting) {
 309                 goTo_starting(pts, off, type);
 310             } else {
 311                 if (needsMoveTo) {
 312                     needsMoveTo = false;
<a name="19" id="anc19"></a><span class="changed"> 313                     out.moveTo(cx0, cy0);</span>
 314                 }
 315                 emitSeg(pts, off, type);
 316             }
 317         } else {
 318             if (starting) {
 319                 // low probability test (hotspot)
 320                 starting = false;
 321             }
 322             needsMoveTo = true;
 323         }
<a name="20" id="anc20"></a><span class="changed"> 324         this.cx0 = x;</span>
<span class="changed"> 325         this.cy0 = y;</span>
 326     }
 327 
 328     private void goTo_starting(final float[] pts, final int off, final int type) {
 329         int len = type - 1; // - 2 + 1
 330         int segIdx = firstSegidx;
 331         float[] buf = firstSegmentsBuffer;
 332 
 333         if (segIdx + len  &gt; buf.length) {
 334             if (DO_STATS) {
 335                 rdrCtx.stats.stat_array_dasher_firstSegmentsBuffer
 336                     .add(segIdx + len);
 337             }
 338             firstSegmentsBuffer = buf
 339                 = firstSegmentsBuffer_ref.widenArray(buf, segIdx,
 340                                                      segIdx + len);
 341         }
 342         buf[segIdx++] = type;
 343         len--;
 344         // small arraycopy (2, 4 or 6) but with offset:
 345         System.arraycopy(pts, off, buf, segIdx, len);
 346         firstSegidx = segIdx + len;
 347     }
 348 
 349     @Override
 350     public void lineTo(final float x1, final float y1) {
<a name="21" id="anc21"></a><span class="changed"> 351         final int outcode0 = this.cOutCode;</span>
<span class="changed"> 352 </span>
<span class="changed"> 353         if (clipRect != null) {</span>
<span class="changed"> 354             final int outcode1 = Helpers.outcode(x1, y1, clipRect);</span>
<span class="changed"> 355 </span>
<span class="changed"> 356             // Should clip</span>
<span class="changed"> 357             final int orCode = (outcode0 | outcode1);</span>
<span class="changed"> 358 </span>
<span class="changed"> 359             if (orCode != 0) {</span>
<span class="changed"> 360                 final int sideCode = outcode0 &amp; outcode1;</span>
<span class="changed"> 361 </span>
<span class="changed"> 362                 // basic rejection criteria:</span>
<span class="changed"> 363                 if (sideCode == 0) {</span>
<span class="changed"> 364                     // ovelap clip:</span>
<span class="changed"> 365                     if (subdivide) {</span>
<span class="changed"> 366                         // avoid reentrance</span>
<span class="changed"> 367                         subdivide = false;</span>
<span class="changed"> 368                         // subdivide curve =&gt; callback with subdivided parts:</span>
<span class="changed"> 369                         boolean ret = curveSplitter.splitLine(cx0, cy0, x1, y1,</span>
<span class="changed"> 370                                                               orCode, this);</span>
<span class="changed"> 371                         // reentrance is done:</span>
<span class="changed"> 372                         subdivide = true;</span>
<span class="changed"> 373                         if (ret) {</span>
<span class="changed"> 374                             return;</span>
<span class="changed"> 375                         }</span>
<span class="changed"> 376                     }</span>
<span class="changed"> 377                     // already subdivided so render it</span>
<span class="changed"> 378                 } else {</span>
<span class="changed"> 379                     this.cOutCode = outcode1;</span>
<span class="changed"> 380                     skipLineTo(x1, y1);</span>
<span class="changed"> 381                     return;</span>
<span class="changed"> 382                 }</span>
<span class="changed"> 383             }</span>
<span class="changed"> 384 </span>
<span class="changed"> 385             this.cOutCode = outcode1;</span>
<span class="changed"> 386 </span>
<span class="changed"> 387             if (this.outside) {</span>
<span class="changed"> 388                 this.outside = false;</span>
<span class="changed"> 389                 // Adjust current index, phase &amp; dash:</span>
<span class="changed"> 390                 skipLen();</span>
<span class="changed"> 391             }</span>
<span class="changed"> 392         }</span>
<span class="changed"> 393         _lineTo(x1, y1);</span>
<span class="changed"> 394     }</span>
<span class="changed"> 395 </span>
<span class="changed"> 396     private void _lineTo(final float x1, final float y1) {</span>
<span class="changed"> 397         final float dx = x1 - cx0;</span>
<span class="changed"> 398         final float dy = y1 - cy0;</span>
 399 
<a name="22" id="anc22"></a><span class="changed"> 400         float len = dx * dx + dy * dy;</span>
 401         if (len == 0.0f) {
 402             return;
 403         }
 404         len = (float) Math.sqrt(len);
 405 
 406         // The scaling factors needed to get the dx and dy of the
 407         // transformed dash segments.
 408         final float cx = dx / len;
 409         final float cy = dy / len;
 410 
 411         final float[] _curCurvepts = curCurvepts;
 412         final float[] _dash = dash;
 413         final int _dashLen = this.dashLen;
 414 
 415         int _idx = idx;
 416         boolean _dashOn = dashOn;
 417         float _phase = phase;
 418 
<a name="23" id="anc23"></a><span class="changed"> 419         float leftInThisDashSegment, d;</span>

 420 
 421         while (true) {
 422             d = _dash[_idx];
 423             leftInThisDashSegment = d - _phase;
 424 
 425             if (len &lt;= leftInThisDashSegment) {
 426                 _curCurvepts[0] = x1;
 427                 _curCurvepts[1] = y1;
 428 
 429                 goTo(_curCurvepts, 0, 4, _dashOn);
 430 
 431                 // Advance phase within current dash segment
 432                 _phase += len;
 433 
 434                 // TODO: compare float values using epsilon:
 435                 if (len == leftInThisDashSegment) {
 436                     _phase = 0.0f;
 437                     _idx = (_idx + 1) % _dashLen;
 438                     _dashOn = !_dashOn;
 439                 }
<a name="24" id="anc24"></a><span class="new"> 440                 break;</span>
<span class="new"> 441             }</span>
 442 
<a name="25" id="anc25"></a><span class="new"> 443             if (_phase == 0.0f) {</span>
<span class="new"> 444                 _curCurvepts[0] = cx0 + d * cx;</span>
<span class="new"> 445                 _curCurvepts[1] = cy0 + d * cy;</span>
<span class="new"> 446             } else {</span>
<span class="new"> 447                 _curCurvepts[0] = cx0 + leftInThisDashSegment * cx;</span>
<span class="new"> 448                 _curCurvepts[1] = cy0 + leftInThisDashSegment * cy;</span>
<span class="new"> 449             }</span>
<span class="new"> 450 </span>
<span class="new"> 451             goTo(_curCurvepts, 0, 4, _dashOn);</span>
<span class="new"> 452 </span>
<span class="new"> 453             len -= leftInThisDashSegment;</span>
<span class="new"> 454             // Advance to next dash segment</span>
<span class="new"> 455             _idx = (_idx + 1) % _dashLen;</span>
<span class="new"> 456             _dashOn = !_dashOn;</span>
<span class="new"> 457             _phase = 0.0f;</span>
<span class="new"> 458         }</span>
 459         // Save local state:
 460         idx = _idx;
 461         dashOn = _dashOn;
 462         phase = _phase;
<a name="26" id="anc26"></a>
 463     }
 464 
<a name="27" id="anc27"></a><span class="changed"> 465     private void skipLineTo(final float x1, final float y1) {</span>
<span class="changed"> 466         final float dx = x1 - cx0;</span>
<span class="changed"> 467         final float dy = y1 - cy0;</span>
 468 
<a name="28" id="anc28"></a><span class="changed"> 469         float len = dx * dx + dy * dy;</span>
<span class="changed"> 470         if (len != 0.0f) {</span>
<span class="changed"> 471             len = (float)Math.sqrt(len);</span>




 472         }
 473 
<a name="29" id="anc29"></a><span class="changed"> 474         // Accumulate skipped length:</span>
<span class="changed"> 475         this.outside = true;</span>
<span class="changed"> 476         this.totalSkipLen += len;</span>
<span class="changed"> 477 </span>
<span class="changed"> 478         // Fix initial move:</span>
<span class="changed"> 479         this.needsMoveTo = true;</span>
<span class="changed"> 480         this.starting = false;</span>
<span class="changed"> 481 </span>
<span class="changed"> 482         this.cx0 = x1;</span>
<span class="changed"> 483         this.cy0 = y1;</span>
<span class="changed"> 484     }</span>
<span class="changed"> 485 </span>
<span class="changed"> 486     public void skipLen() {</span>
<span class="changed"> 487         float len = this.totalSkipLen;</span>
<span class="changed"> 488         this.totalSkipLen = 0.0f;</span>
<span class="changed"> 489 </span>
<span class="changed"> 490         final float[] _dash = dash;</span>
<span class="changed"> 491         final int _dashLen = this.dashLen;</span>
<span class="changed"> 492 </span>
<span class="changed"> 493         int _idx = idx;</span>
<span class="changed"> 494         boolean _dashOn = dashOn;</span>
<span class="changed"> 495         float _phase = phase;</span>
<span class="changed"> 496 </span>
<span class="changed"> 497         // -2 to ensure having 2 iterations of the post-loop</span>
<span class="changed"> 498         // to compensate the remaining phase</span>
<span class="changed"> 499         final long fullcycles = (long)Math.floor(len / cycleLen) - 2L;</span>
<span class="changed"> 500 </span>
<span class="changed"> 501         if (fullcycles &gt; 0L) {</span>
<span class="changed"> 502             len -= cycleLen * fullcycles;</span>
<span class="changed"> 503 </span>
<span class="changed"> 504             final long iterations = fullcycles * _dashLen;</span>
<span class="changed"> 505             _idx = (int) (iterations + _idx) % _dashLen;</span>
<span class="changed"> 506             _dashOn = (iterations + (_dashOn ? 1L : 0L) &amp; 1L) == 1L;</span>
<span class="changed"> 507         }</span>
<span class="changed"> 508 </span>
<span class="changed"> 509         float leftInThisDashSegment, d;</span>
<span class="changed"> 510 </span>
<span class="changed"> 511         while (true) {</span>
<span class="changed"> 512             d = _dash[_idx];</span>
<span class="changed"> 513             leftInThisDashSegment = d - _phase;</span>
<span class="changed"> 514 </span>
<span class="changed"> 515             if (len &lt;= leftInThisDashSegment) {</span>
<span class="changed"> 516                 // Advance phase within current dash segment</span>
<span class="changed"> 517                 _phase += len;</span>
<span class="changed"> 518 </span>
<span class="changed"> 519                 // TODO: compare float values using epsilon:</span>
<span class="changed"> 520                 if (len == leftInThisDashSegment) {</span>
<span class="changed"> 521                     _phase = 0.0f;</span>
<span class="changed"> 522                     _idx = (_idx + 1) % _dashLen;</span>
<span class="changed"> 523                     _dashOn = !_dashOn;</span>
<span class="changed"> 524                 }</span>
<span class="changed"> 525                 break;</span>
<span class="changed"> 526             }</span>
 527 
 528             len -= leftInThisDashSegment;
 529             // Advance to next dash segment
 530             _idx = (_idx + 1) % _dashLen;
 531             _dashOn = !_dashOn;
 532             _phase = 0.0f;
 533         }
<a name="30" id="anc30"></a><span class="new"> 534         // Save local state:</span>
<span class="new"> 535         idx = _idx;</span>
<span class="new"> 536         dashOn = _dashOn;</span>
<span class="new"> 537         phase = _phase;</span>
 538     }
 539 
<a name="31" id="anc31"></a>


 540     // preconditions: curCurvepts must be an array of length at least 2 * type,
 541     // that contains the curve we want to dash in the first type elements
 542     private void somethingTo(final int type) {
<a name="32" id="anc32"></a><span class="changed"> 543         final float[] _curCurvepts = curCurvepts;</span>
<span class="changed"> 544         if (pointCurve(_curCurvepts, type)) {</span>
 545             return;
 546         }
 547         final LengthIterator _li = li;
<a name="33" id="anc33"></a>
 548         final float[] _dash = dash;
 549         final int _dashLen = this.dashLen;
 550 
 551         _li.initializeIterationOnCurve(_curCurvepts, type);
 552 
 553         int _idx = idx;
 554         boolean _dashOn = dashOn;
 555         float _phase = phase;
 556 
 557         // initially the current curve is at curCurvepts[0...type]
 558         int curCurveoff = 0;
<a name="34" id="anc34"></a><span class="changed"> 559         float prevT = 0.0f;</span>
 560         float t;
 561         float leftInThisDashSegment = _dash[_idx] - _phase;
 562 
 563         while ((t = _li.next(leftInThisDashSegment)) &lt; 1.0f) {
 564             if (t != 0.0f) {
<a name="35" id="anc35"></a><span class="changed"> 565                 Helpers.subdivideAt((t - prevT) / (1.0f - prevT),</span>
 566                                     _curCurvepts, curCurveoff,
<a name="36" id="anc36"></a><span class="changed"> 567                                     _curCurvepts, 0, type);</span>
<span class="changed"> 568                 prevT = t;</span>

 569                 goTo(_curCurvepts, 2, type, _dashOn);
 570                 curCurveoff = type;
 571             }
 572             // Advance to next dash segment
 573             _idx = (_idx + 1) % _dashLen;
 574             _dashOn = !_dashOn;
 575             _phase = 0.0f;
 576             leftInThisDashSegment = _dash[_idx];
 577         }
 578 
 579         goTo(_curCurvepts, curCurveoff + 2, type, _dashOn);
 580 
 581         _phase += _li.lastSegLen();
 582         if (_phase &gt;= _dash[_idx]) {
 583             _phase = 0.0f;
 584             _idx = (_idx + 1) % _dashLen;
 585             _dashOn = !_dashOn;
 586         }
 587         // Save local state:
 588         idx = _idx;
 589         dashOn = _dashOn;
 590         phase = _phase;
 591 
 592         // reset LengthIterator:
 593         _li.reset();
 594     }
 595 
<a name="37" id="anc37"></a><span class="changed"> 596     private void skipSomethingTo(final int type) {</span>
<span class="changed"> 597         final float[] _curCurvepts = curCurvepts;</span>
<span class="changed"> 598         if (pointCurve(_curCurvepts, type)) {</span>
<span class="changed"> 599             return;</span>
<span class="changed"> 600         }</span>
<span class="changed"> 601         final LengthIterator _li = li;</span>
<span class="changed"> 602 </span>
<span class="changed"> 603         _li.initializeIterationOnCurve(_curCurvepts, type);</span>
<span class="changed"> 604 </span>
<span class="changed"> 605         // In contrary to somethingTo(),</span>
<span class="changed"> 606         // just estimate properly the curve length:</span>
<span class="changed"> 607         final float len = _li.totalLength();</span>
<span class="changed"> 608 </span>
<span class="changed"> 609         // Accumulate skipped length:</span>
<span class="changed"> 610         this.outside = true;</span>
<span class="changed"> 611         this.totalSkipLen += len;</span>
<span class="changed"> 612 </span>
<span class="changed"> 613         // Fix initial move:</span>
<span class="changed"> 614         this.needsMoveTo = true;</span>
<span class="changed"> 615         this.starting = false;</span>
<span class="changed"> 616     }</span>
<span class="changed"> 617 </span>
<span class="changed"> 618     private static boolean pointCurve(final float[] curve, final int type) {</span>
 619         for (int i = 2; i &lt; type; i++) {
 620             if (curve[i] != curve[i-2]) {
 621                 return false;
 622             }
 623         }
 624         return true;
 625     }
 626 
 627     // Objects of this class are used to iterate through curves. They return
 628     // t values where the left side of the curve has a specified length.
 629     // It does this by subdividing the input curve until a certain error
 630     // condition has been met. A recursive subdivision procedure would
 631     // return as many as 1&lt;&lt;limit curves, but this is an iterator and we
 632     // don't need all the curves all at once, so what we carry out a
 633     // lazy inorder traversal of the recursion tree (meaning we only move
 634     // through the tree when we need the next subdivided curve). This saves
 635     // us a lot of memory because at any one time we only need to store
 636     // limit+1 curves - one for each level of the tree + 1.
 637     // NOTE: the way we do things here is not enough to traverse a general
 638     // tree; however, the trees we are interested in have the property that
 639     // every non leaf node has exactly 2 children
 640     static final class LengthIterator {
<a name="38" id="anc38"></a>
 641         // Holds the curves at various levels of the recursion. The root
 642         // (i.e. the original curve) is at recCurveStack[0] (but then it
 643         // gets subdivided, the left half is put at 1, so most of the time
 644         // only the right half of the original curve is at 0)
 645         private final float[][] recCurveStack; // dirty
<a name="39" id="anc39"></a><span class="changed"> 646         // sidesRight[i] indicates whether the node at level i+1 in the path from</span>
 647         // the root to the current leaf is a left or right child of its parent.
<a name="40" id="anc40"></a><span class="changed"> 648         private final boolean[] sidesRight; // dirty</span>
 649         private int curveType;
 650         // lastT and nextT delimit the current leaf.
 651         private float nextT;
 652         private float lenAtNextT;
 653         private float lastT;
 654         private float lenAtLastT;
 655         private float lenAtLastSplit;
 656         private float lastSegLen;
 657         // the current level in the recursion tree. 0 is the root. limit
 658         // is the deepest possible leaf.
 659         private int recLevel;
 660         private boolean done;
 661 
 662         // the lengths of the lines of the control polygon. Only its first
 663         // curveType/2 - 1 elements are valid. This is an optimization. See
 664         // next() for more detail.
 665         private final float[] curLeafCtrlPolyLengths = new float[3];
 666 
 667         LengthIterator() {
 668             this.recCurveStack = new float[REC_LIMIT + 1][8];
<a name="41" id="anc41"></a><span class="changed"> 669             this.sidesRight = new boolean[REC_LIMIT];</span>
 670             // if any methods are called without first initializing this object
 671             // on a curve, we want it to fail ASAP.
 672             this.nextT = Float.MAX_VALUE;
 673             this.lenAtNextT = Float.MAX_VALUE;
 674             this.lenAtLastSplit = Float.MIN_VALUE;
 675             this.recLevel = Integer.MIN_VALUE;
 676             this.lastSegLen = Float.MAX_VALUE;
 677             this.done = true;
 678         }
 679 
 680         /**
 681          * Reset this LengthIterator.
 682          */
 683         void reset() {
 684             // keep data dirty
 685             // as it appears not useful to reset data:
 686             if (DO_CLEAN_DIRTY) {
 687                 final int recLimit = recCurveStack.length - 1;
 688                 for (int i = recLimit; i &gt;= 0; i--) {
 689                     Arrays.fill(recCurveStack[i], 0.0f);
 690                 }
<a name="42" id="anc42"></a><span class="changed"> 691                 Arrays.fill(sidesRight, false);</span>
 692                 Arrays.fill(curLeafCtrlPolyLengths, 0.0f);
 693                 Arrays.fill(nextRoots, 0.0f);
 694                 Arrays.fill(flatLeafCoefCache, 0.0f);
 695                 flatLeafCoefCache[2] = -1.0f;
 696             }
 697         }
 698 
<a name="43" id="anc43"></a><span class="changed"> 699         void initializeIterationOnCurve(final float[] pts, final int type) {</span>
 700             // optimize arraycopy (8 values faster than 6 = type):
 701             System.arraycopy(pts, 0, recCurveStack[0], 0, 8);
 702             this.curveType = type;
 703             this.recLevel = 0;
 704             this.lastT = 0.0f;
 705             this.lenAtLastT = 0.0f;
 706             this.nextT = 0.0f;
 707             this.lenAtNextT = 0.0f;
 708             goLeft(); // initializes nextT and lenAtNextT properly
 709             this.lenAtLastSplit = 0.0f;
 710             if (recLevel &gt; 0) {
<a name="44" id="anc44"></a><span class="changed"> 711                 this.sidesRight[0] = false;</span>
 712                 this.done = false;
 713             } else {
 714                 // the root of the tree is a leaf so we're done.
<a name="45" id="anc45"></a><span class="changed"> 715                 this.sidesRight[0] = true;</span>
 716                 this.done = true;
 717             }
 718             this.lastSegLen = 0.0f;
 719         }
 720 
 721         // 0 == false, 1 == true, -1 == invalid cached value.
 722         private int cachedHaveLowAcceleration = -1;
 723 
<a name="46" id="anc46"></a><span class="changed"> 724         private boolean haveLowAcceleration(final float err) {</span>
 725             if (cachedHaveLowAcceleration == -1) {
 726                 final float len1 = curLeafCtrlPolyLengths[0];
 727                 final float len2 = curLeafCtrlPolyLengths[1];
 728                 // the test below is equivalent to !within(len1/len2, 1, err).
 729                 // It is using a multiplication instead of a division, so it
 730                 // should be a bit faster.
 731                 if (!Helpers.within(len1, len2, err * len2)) {
 732                     cachedHaveLowAcceleration = 0;
 733                     return false;
 734                 }
 735                 if (curveType == 8) {
 736                     final float len3 = curLeafCtrlPolyLengths[2];
 737                     // if len1 is close to 2 and 2 is close to 3, that probably
 738                     // means 1 is close to 3 so the second part of this test might
 739                     // not be needed, but it doesn't hurt to include it.
 740                     final float errLen3 = err * len3;
 741                     if (!(Helpers.within(len2, len3, errLen3) &amp;&amp;
 742                           Helpers.within(len1, len3, errLen3))) {
 743                         cachedHaveLowAcceleration = 0;
 744                         return false;
 745                     }
 746                 }
 747                 cachedHaveLowAcceleration = 1;
 748                 return true;
 749             }
 750 
 751             return (cachedHaveLowAcceleration == 1);
 752         }
 753 
 754         // we want to avoid allocations/gc so we keep this array so we
 755         // can put roots in it,
 756         private final float[] nextRoots = new float[4];
 757 
 758         // caches the coefficients of the current leaf in its flattened
 759         // form (see inside next() for what that means). The cache is
 760         // invalid when it's third element is negative, since in any
 761         // valid flattened curve, this would be &gt;= 0.
 762         private final float[] flatLeafCoefCache = new float[]{0.0f, 0.0f, -1.0f, 0.0f};
 763 
 764         // returns the t value where the remaining curve should be split in
 765         // order for the left subdivided curve to have length len. If len
 766         // is &gt;= than the length of the uniterated curve, it returns 1.
 767         float next(final float len) {
 768             final float targetLength = lenAtLastSplit + len;
 769             while (lenAtNextT &lt; targetLength) {
 770                 if (done) {
 771                     lastSegLen = lenAtNextT - lenAtLastSplit;
 772                     return 1.0f;
 773                 }
 774                 goToNextLeaf();
 775             }
 776             lenAtLastSplit = targetLength;
 777             final float leaflen = lenAtNextT - lenAtLastT;
 778             float t = (targetLength - lenAtLastT) / leaflen;
 779 
 780             // cubicRootsInAB is a fairly expensive call, so we just don't do it
 781             // if the acceleration in this section of the curve is small enough.
 782             if (!haveLowAcceleration(0.05f)) {
 783                 // We flatten the current leaf along the x axis, so that we're
 784                 // left with a, b, c which define a 1D Bezier curve. We then
 785                 // solve this to get the parameter of the original leaf that
 786                 // gives us the desired length.
 787                 final float[] _flatLeafCoefCache = flatLeafCoefCache;
 788 
 789                 if (_flatLeafCoefCache[2] &lt; 0.0f) {
 790                     float x =     curLeafCtrlPolyLengths[0],
 791                           y = x + curLeafCtrlPolyLengths[1];
 792                     if (curveType == 8) {
 793                         float z = y + curLeafCtrlPolyLengths[2];
 794                         _flatLeafCoefCache[0] = 3.0f * (x - y) + z;
 795                         _flatLeafCoefCache[1] = 3.0f * (y - 2.0f * x);
 796                         _flatLeafCoefCache[2] = 3.0f * x;
 797                         _flatLeafCoefCache[3] = -z;
 798                     } else if (curveType == 6) {
 799                         _flatLeafCoefCache[0] = 0.0f;
 800                         _flatLeafCoefCache[1] = y - 2.0f * x;
 801                         _flatLeafCoefCache[2] = 2.0f * x;
 802                         _flatLeafCoefCache[3] = -y;
 803                     }
 804                 }
 805                 float a = _flatLeafCoefCache[0];
 806                 float b = _flatLeafCoefCache[1];
 807                 float c = _flatLeafCoefCache[2];
 808                 float d = t * _flatLeafCoefCache[3];
 809 
 810                 // we use cubicRootsInAB here, because we want only roots in 0, 1,
 811                 // and our quadratic root finder doesn't filter, so it's just a
 812                 // matter of convenience.
<a name="47" id="anc47"></a><span class="changed"> 813                 final int n = Helpers.cubicRootsInAB(a, b, c, d, nextRoots, 0, 0.0f, 1.0f);</span>
 814                 if (n == 1 &amp;&amp; !Float.isNaN(nextRoots[0])) {
 815                     t = nextRoots[0];
 816                 }
 817             }
 818             // t is relative to the current leaf, so we must make it a valid parameter
 819             // of the original curve.
 820             t = t * (nextT - lastT) + lastT;
 821             if (t &gt;= 1.0f) {
 822                 t = 1.0f;
 823                 done = true;
 824             }
 825             // even if done = true, if we're here, that means targetLength
 826             // is equal to, or very, very close to the total length of the
 827             // curve, so lastSegLen won't be too high. In cases where len
 828             // overshoots the curve, this method will exit in the while
 829             // loop, and lastSegLen will still be set to the right value.
 830             lastSegLen = len;
 831             return t;
 832         }
 833 
<a name="48" id="anc48"></a><span class="new"> 834         float totalLength() {</span>
<span class="new"> 835             while (!done) {</span>
<span class="new"> 836                 goToNextLeaf();</span>
<span class="new"> 837             }</span>
<span class="new"> 838             // reset LengthIterator:</span>
<span class="new"> 839             reset();</span>
<span class="new"> 840 </span>
<span class="new"> 841             return lenAtNextT;</span>
<span class="new"> 842         }</span>
<span class="new"> 843 </span>
 844         float lastSegLen() {
 845             return lastSegLen;
 846         }
 847 
 848         // go to the next leaf (in an inorder traversal) in the recursion tree
 849         // preconditions: must be on a leaf, and that leaf must not be the root.
 850         private void goToNextLeaf() {
 851             // We must go to the first ancestor node that has an unvisited
 852             // right child.
<a name="49" id="anc49"></a><span class="new"> 853             final boolean[] _sides = sidesRight;</span>
 854             int _recLevel = recLevel;
<a name="50" id="anc50"></a>

 855             _recLevel--;
<a name="51" id="anc51"></a><span class="changed"> 856 </span>
<span class="changed"> 857             while(_sides[_recLevel]) {</span>
 858                 if (_recLevel == 0) {
 859                     recLevel = 0;
 860                     done = true;
 861                     return;
 862                 }
 863                 _recLevel--;
 864             }
 865 
<a name="52" id="anc52"></a><span class="changed"> 866             _sides[_recLevel] = true;</span>
 867             // optimize arraycopy (8 values faster than 6 = type):
<a name="53" id="anc53"></a><span class="changed"> 868             System.arraycopy(recCurveStack[_recLevel++], 0,</span>
<span class="changed"> 869                              recCurveStack[_recLevel], 0, 8);</span>


 870             recLevel = _recLevel;
 871             goLeft();
 872         }
 873 
 874         // go to the leftmost node from the current node. Return its length.
 875         private void goLeft() {
<a name="54" id="anc54"></a><span class="changed"> 876             final float len = onLeaf();</span>
 877             if (len &gt;= 0.0f) {
 878                 lastT = nextT;
 879                 lenAtLastT = lenAtNextT;
 880                 nextT += (1 &lt;&lt; (REC_LIMIT - recLevel)) * MIN_T_INC;
 881                 lenAtNextT += len;
 882                 // invalidate caches
 883                 flatLeafCoefCache[2] = -1.0f;
 884                 cachedHaveLowAcceleration = -1;
 885             } else {
<a name="55" id="anc55"></a><span class="changed"> 886                 Helpers.subdivide(recCurveStack[recLevel],</span>
<span class="changed"> 887                                   recCurveStack[recLevel + 1],</span>
<span class="changed"> 888                                   recCurveStack[recLevel], curveType);</span>
<span class="changed"> 889 </span>
<span class="changed"> 890                 sidesRight[recLevel] = false;</span>
 891                 recLevel++;
 892                 goLeft();
 893             }
 894         }
 895 
 896         // this is a bit of a hack. It returns -1 if we're not on a leaf, and
 897         // the length of the leaf if we are on a leaf.
 898         private float onLeaf() {
 899             final float[] curve = recCurveStack[recLevel];
 900             final int _curveType = curveType;
 901             float polyLen = 0.0f;
 902 
 903             float x0 = curve[0], y0 = curve[1];
 904             for (int i = 2; i &lt; _curveType; i += 2) {
<a name="56" id="anc56"></a><span class="changed"> 905                 final float x1 = curve[i], y1 = curve[i + 1];</span>
 906                 final float len = Helpers.linelen(x0, y0, x1, y1);
 907                 polyLen += len;
 908                 curLeafCtrlPolyLengths[(i &gt;&gt; 1) - 1] = len;
 909                 x0 = x1;
 910                 y0 = y1;
 911             }
 912 
<a name="57" id="anc57"></a><span class="changed"> 913             final float lineLen = Helpers.linelen(curve[0], curve[1], x0, y0);</span>
<span class="changed"> 914 </span>
<span class="changed"> 915             if ((polyLen - lineLen) &lt; CURVE_LEN_ERR || recLevel == REC_LIMIT) {</span>

 916                 return (polyLen + lineLen) / 2.0f;
 917             }
 918             return -1.0f;
 919         }
 920     }
 921 
 922     @Override
 923     public void curveTo(final float x1, final float y1,
 924                         final float x2, final float y2,
 925                         final float x3, final float y3)
 926     {
<a name="58" id="anc58"></a><span class="new"> 927         final int outcode0 = this.cOutCode;</span>
<span class="new"> 928 </span>
<span class="new"> 929         if (clipRect != null) {</span>
<span class="new"> 930             final int outcode1 = Helpers.outcode(x1, y1, clipRect);</span>
<span class="new"> 931             final int outcode2 = Helpers.outcode(x2, y2, clipRect);</span>
<span class="new"> 932             final int outcode3 = Helpers.outcode(x3, y3, clipRect);</span>
<span class="new"> 933 </span>
<span class="new"> 934             // Should clip</span>
<span class="new"> 935             final int orCode = (outcode0 | outcode1 | outcode2 | outcode3);</span>
<span class="new"> 936             if (orCode != 0) {</span>
<span class="new"> 937                 final int sideCode = outcode0 &amp; outcode1 &amp; outcode2 &amp; outcode3;</span>
<span class="new"> 938 </span>
<span class="new"> 939                 // basic rejection criteria:</span>
<span class="new"> 940                 if (sideCode == 0) {</span>
<span class="new"> 941                     // ovelap clip:</span>
<span class="new"> 942                     if (subdivide) {</span>
<span class="new"> 943                         // avoid reentrance</span>
<span class="new"> 944                         subdivide = false;</span>
<span class="new"> 945                         // subdivide curve =&gt; callback with subdivided parts:</span>
<span class="new"> 946                         boolean ret = curveSplitter.splitCurve(cx0, cy0, x1, y1, x2, y2, x3, y3,</span>
<span class="new"> 947                                                                orCode, this);</span>
<span class="new"> 948                         // reentrance is done:</span>
<span class="new"> 949                         subdivide = true;</span>
<span class="new"> 950                         if (ret) {</span>
<span class="new"> 951                             return;</span>
<span class="new"> 952                         }</span>
<span class="new"> 953                     }</span>
<span class="new"> 954                     // already subdivided so render it</span>
<span class="new"> 955                 } else {</span>
<span class="new"> 956                     this.cOutCode = outcode3;</span>
<span class="new"> 957                     skipCurveTo(x1, y1, x2, y2, x3, y3);</span>
<span class="new"> 958                     return;</span>
<span class="new"> 959                 }</span>
<span class="new"> 960             }</span>
<span class="new"> 961 </span>
<span class="new"> 962             this.cOutCode = outcode3;</span>
<span class="new"> 963 </span>
<span class="new"> 964             if (this.outside) {</span>
<span class="new"> 965                 this.outside = false;</span>
<span class="new"> 966                 // Adjust current index, phase &amp; dash:</span>
<span class="new"> 967                 skipLen();</span>
<span class="new"> 968             }</span>
<span class="new"> 969         }</span>
<span class="new"> 970         _curveTo(x1, y1, x2, y2, x3, y3);</span>
<span class="new"> 971     }</span>
<span class="new"> 972 </span>
<span class="new"> 973     private void _curveTo(final float x1, final float y1,</span>
<span class="new"> 974                           final float x2, final float y2,</span>
<span class="new"> 975                           final float x3, final float y3)</span>
<span class="new"> 976     {</span>
<span class="new"> 977         final float[] _curCurvepts = curCurvepts;</span>
<span class="new"> 978 </span>
<span class="new"> 979         // monotonize curve:</span>
<span class="new"> 980         final CurveBasicMonotonizer monotonizer</span>
<span class="new"> 981             = rdrCtx.monotonizer.curve(cx0, cy0, x1, y1, x2, y2, x3, y3);</span>
<span class="new"> 982 </span>
<span class="new"> 983         final int nSplits = monotonizer.nbSplits;</span>
<span class="new"> 984         final float[] mid = monotonizer.middle;</span>
<span class="new"> 985 </span>
<span class="new"> 986         for (int i = 0, off = 0; i &lt;= nSplits; i++, off += 6) {</span>
<span class="new"> 987             // optimize arraycopy (8 values faster than 6 = type):</span>
<span class="new"> 988             System.arraycopy(mid, off, _curCurvepts, 0, 8);</span>
<span class="new"> 989 </span>
<span class="new"> 990             somethingTo(8);</span>
<span class="new"> 991         }</span>
<span class="new"> 992     }</span>
<span class="new"> 993 </span>
<span class="new"> 994     private void skipCurveTo(final float x1, final float y1,</span>
<span class="new"> 995                              final float x2, final float y2,</span>
<span class="new"> 996                              final float x3, final float y3)</span>
<span class="new"> 997     {</span>
 998         final float[] _curCurvepts = curCurvepts;
<a name="59" id="anc59"></a><span class="changed"> 999         _curCurvepts[0] = cx0; _curCurvepts[1] = cy0;</span>
1000         _curCurvepts[2] = x1;  _curCurvepts[3] = y1;
1001         _curCurvepts[4] = x2;  _curCurvepts[5] = y2;
1002         _curCurvepts[6] = x3;  _curCurvepts[7] = y3;
<a name="60" id="anc60"></a><span class="changed">1003 </span>
<span class="changed">1004         skipSomethingTo(8);</span>
<span class="changed">1005 </span>
<span class="changed">1006         this.cx0 = x3;</span>
<span class="changed">1007         this.cy0 = y3;</span>
1008     }
1009 
1010     @Override
1011     public void quadTo(final float x1, final float y1,
1012                        final float x2, final float y2)
1013     {
<a name="61" id="anc61"></a><span class="new">1014         final int outcode0 = this.cOutCode;</span>
<span class="new">1015 </span>
<span class="new">1016         if (clipRect != null) {</span>
<span class="new">1017             final int outcode1 = Helpers.outcode(x1, y1, clipRect);</span>
<span class="new">1018             final int outcode2 = Helpers.outcode(x2, y2, clipRect);</span>
<span class="new">1019 </span>
<span class="new">1020             // Should clip</span>
<span class="new">1021             final int orCode = (outcode0 | outcode1 | outcode2);</span>
<span class="new">1022             if (orCode != 0) {</span>
<span class="new">1023                 final int sideCode = outcode0 &amp; outcode1 &amp; outcode2;</span>
<span class="new">1024 </span>
<span class="new">1025                 // basic rejection criteria:</span>
<span class="new">1026                 if (sideCode == 0) {</span>
<span class="new">1027                     // ovelap clip:</span>
<span class="new">1028                     if (subdivide) {</span>
<span class="new">1029                         // avoid reentrance</span>
<span class="new">1030                         subdivide = false;</span>
<span class="new">1031                         // subdivide curve =&gt; call lineTo() with subdivided curves:</span>
<span class="new">1032                         boolean ret = curveSplitter.splitQuad(cx0, cy0, x1, y1,</span>
<span class="new">1033                                                               x2, y2, orCode, this);</span>
<span class="new">1034                         // reentrance is done:</span>
<span class="new">1035                         subdivide = true;</span>
<span class="new">1036                         if (ret) {</span>
<span class="new">1037                             return;</span>
<span class="new">1038                         }</span>
<span class="new">1039                     }</span>
<span class="new">1040                     // already subdivided so render it</span>
<span class="new">1041                 } else {</span>
<span class="new">1042                     this.cOutCode = outcode2;</span>
<span class="new">1043                     skipQuadTo(x1, y1, x2, y2);</span>
<span class="new">1044                     return;</span>
<span class="new">1045                 }</span>
<span class="new">1046             }</span>
<span class="new">1047 </span>
<span class="new">1048             this.cOutCode = outcode2;</span>
<span class="new">1049 </span>
<span class="new">1050             if (this.outside) {</span>
<span class="new">1051                 this.outside = false;</span>
<span class="new">1052                 // Adjust current index, phase &amp; dash:</span>
<span class="new">1053                 skipLen();</span>
<span class="new">1054             }</span>
<span class="new">1055         }</span>
<span class="new">1056         _quadTo(x1, y1, x2, y2);</span>
<span class="new">1057     }</span>
<span class="new">1058 </span>
<span class="new">1059     private void _quadTo(final float x1, final float y1,</span>
<span class="new">1060                          final float x2, final float y2)</span>
<span class="new">1061     {</span>
1062         final float[] _curCurvepts = curCurvepts;
<a name="62" id="anc62"></a><span class="changed">1063 </span>
<span class="changed">1064         // monotonize quad:</span>
<span class="changed">1065         final CurveBasicMonotonizer monotonizer</span>
<span class="changed">1066             = rdrCtx.monotonizer.quad(cx0, cy0, x1, y1, x2, y2);</span>
<span class="changed">1067 </span>
<span class="changed">1068         final int nSplits = monotonizer.nbSplits;</span>
<span class="changed">1069         final float[] mid = monotonizer.middle;</span>
<span class="changed">1070 </span>
<span class="changed">1071         for (int i = 0, off = 0; i &lt;= nSplits; i++, off += 4) {</span>
<span class="changed">1072             // optimize arraycopy (8 values faster than 6 = type):</span>
<span class="changed">1073             System.arraycopy(mid, off, _curCurvepts, 0, 8);</span>
<span class="changed">1074 </span>
<span class="changed">1075             somethingTo(6);</span>
<span class="changed">1076         }</span>
<span class="changed">1077     }</span>
<span class="changed">1078 </span>
<span class="changed">1079     private void skipQuadTo(final float x1, final float y1,</span>
<span class="changed">1080                             final float x2, final float y2)</span>
<span class="changed">1081     {</span>
<span class="changed">1082         final float[] _curCurvepts = curCurvepts;</span>
<span class="changed">1083         _curCurvepts[0] = cx0; _curCurvepts[1] = cy0;</span>
1084         _curCurvepts[2] = x1;  _curCurvepts[3] = y1;
1085         _curCurvepts[4] = x2;  _curCurvepts[5] = y2;
<a name="63" id="anc63"></a><span class="changed">1086 </span>
<span class="changed">1087         skipSomethingTo(6);</span>
<span class="changed">1088 </span>
<span class="changed">1089         this.cx0 = x2;</span>
<span class="changed">1090         this.cy0 = y2;</span>
1091     }
1092 
1093     @Override
1094     public void closePath() {
<a name="64" id="anc64"></a><span class="changed">1095         if (cx0 != sx0 || cy0 != sy0) {</span>
<span class="changed">1096             lineTo(sx0, sy0);</span>
<span class="changed">1097         }</span>
1098         if (firstSegidx != 0) {
1099             if (!dashOn || needsMoveTo) {
<a name="65" id="anc65"></a><span class="changed">1100                 out.moveTo(sx0, sy0);</span>
1101             }
1102             emitFirstSegments();
1103         }
<a name="66" id="anc66"></a><span class="changed">1104         moveTo(sx0, sy0);</span>
1105     }
1106 
1107     @Override
1108     public void pathDone() {
1109         if (firstSegidx != 0) {
<a name="67" id="anc67"></a><span class="changed">1110             out.moveTo(sx0, sy0);</span>
1111             emitFirstSegments();
1112         }
1113         out.pathDone();
1114 
1115         // Dispose this instance:
1116         dispose();
1117     }
1118 
1119     @Override
1120     public long getNativeConsumer() {
1121         throw new InternalError("Dasher does not use a native consumer");
1122     }
1123 }
1124 
<a name="68" id="anc68"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="68" type="hidden" /></form></body></html>
