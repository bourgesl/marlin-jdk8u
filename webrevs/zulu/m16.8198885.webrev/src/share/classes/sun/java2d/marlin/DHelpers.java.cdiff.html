<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>jdk Cdiff src/share/classes/sun/java2d/marlin/DHelpers.java</title>
</head>
<body id="SUNWwebrev">
<center><a href='../../../../../../src/share/classes/sun/java2d/marlin/DDasher.java.cdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../src/share/classes/sun/java2d/marlin/DMarlinRenderingEngine.java.cdiff.html' target='_top'>next &gt</a></center>
<h2>src/share/classes/sun/java2d/marlin/DHelpers.java</h2>
        <a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-13695">13695</a> : <a href="https://bugs.openjdk.java.net/browse/JDK-8198885">8198885</a>: upgrade Marlin (java2d) to 0.9.1
Summary: clipping implemented in Dasher (curve subdivision at clip edges) + higher quality(curve, subpixels) + new path simplifier
Reviewed-by: prr, serb</pre>
        <pre>
<hr /><span class="oldmarker">*** 1,7 ****</span>
  /*
<span class="changed">!  * Copyright (c) 2007, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="newmarker">--- 1,7 ----</span>
  /*
<span class="changed">!  * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<hr /><span class="oldmarker">*** 23,33 ****</span>
   * questions.
   */
  
  package sun.java2d.marlin;
  
<span class="removed">- import static java.lang.Math.PI;</span>
  import java.util.Arrays;
  import sun.java2d.marlin.stats.Histogram;
  import sun.java2d.marlin.stats.StatLong;
  
  final class DHelpers implements MarlinConst {
<span class="newmarker">--- 23,32 ----</span>
<hr /><span class="oldmarker">*** 39,55 ****</span>
      static boolean within(final double x, final double y, final double err) {
          final double d = y - x;
          return (d &lt;= err &amp;&amp; d &gt;= -err);
      }
  
<span class="changed">!     static int quadraticRoots(final double a, final double b,</span>
<span class="changed">!                               final double c, double[] zeroes, final int off)</span>
      {
          int ret = off;
<span class="removed">-         double t;</span>
          if (a != 0.0d) {
<span class="changed">!             final double dis = b*b - 4*a*c;</span>
              if (dis &gt; 0.0d) {
                  final double sqrtDis = Math.sqrt(dis);
                  // depending on the sign of b we use a slightly different
                  // algorithm than the traditional one to find one of the roots
                  // so we can avoid adding numbers of different signs (which
<span class="newmarker">--- 38,66 ----</span>
      static boolean within(final double x, final double y, final double err) {
          final double d = y - x;
          return (d &lt;= err &amp;&amp; d &gt;= -err);
      }
  
<span class="changed">!     static double evalCubic(final double a, final double b,</span>
<span class="changed">!                             final double c, final double d,</span>
<span class="changed">!                             final double t)</span>
<span class="changed">!     {</span>
<span class="changed">!         return t * (t * (t * a + b) + c) + d;</span>
<span class="changed">!     }</span>
<span class="changed">! </span>
<span class="changed">!     static double evalQuad(final double a, final double b,</span>
<span class="changed">!                            final double c, final double t)</span>
<span class="changed">!     {</span>
<span class="changed">!         return t * (t * a + b) + c;</span>
<span class="changed">!     }</span>
<span class="changed">! </span>
<span class="changed">!     static int quadraticRoots(final double a, final double b, final double c,</span>
<span class="changed">!                               final double[] zeroes, final int off)</span>
      {
          int ret = off;
          if (a != 0.0d) {
<span class="changed">!             final double dis = b*b - 4.0d * a * c;</span>
              if (dis &gt; 0.0d) {
                  final double sqrtDis = Math.sqrt(dis);
                  // depending on the sign of b we use a slightly different
                  // algorithm than the traditional one to find one of the roots
                  // so we can avoid adding numbers of different signs (which
<hr /><span class="oldmarker">*** 60,97 ****</span>
                  } else {
                      zeroes[ret++] = (-b + sqrtDis) / (2.0d * a);
                      zeroes[ret++] = (2.0d * c) / (-b + sqrtDis);
                  }
              } else if (dis == 0.0d) {
<span class="changed">!                 t = (-b) / (2.0d * a);</span>
<span class="changed">!                 zeroes[ret++] = t;</span>
<span class="changed">!             }</span>
<span class="changed">!         } else {</span>
<span class="changed">!             if (b != 0.0d) {</span>
<span class="changed">!                 t = (-c) / b;</span>
<span class="changed">!                 zeroes[ret++] = t;</span>
              }
          }
          return ret - off;
      }
  
      // find the roots of g(t) = d*t^3 + a*t^2 + b*t + c in [A,B)
<span class="changed">!     static int cubicRootsInAB(double d, double a, double b, double c,</span>
<span class="changed">!                               double[] pts, final int off,</span>
                                final double A, final double B)
      {
          if (d == 0.0d) {
<span class="changed">!             int num = quadraticRoots(a, b, c, pts, off);</span>
              return filterOutNotInAB(pts, off, num, A, B) - off;
          }
          // From Graphics Gems:
<span class="changed">!         // http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c</span>
          // (also from awt.geom.CubicCurve2D. But here we don't need as
          // much accuracy and we don't want to create arrays so we use
          // our own customized version).
  
          // normal form: x^3 + ax^2 + bx + c = 0
          a /= d;
          b /= d;
          c /= d;
  
          //  substitute x = y - A/3 to eliminate quadratic term:
<span class="newmarker">--- 71,108 ----</span>
                  } else {
                      zeroes[ret++] = (-b + sqrtDis) / (2.0d * a);
                      zeroes[ret++] = (2.0d * c) / (-b + sqrtDis);
                  }
              } else if (dis == 0.0d) {
<span class="changed">!                 zeroes[ret++] = -b / (2.0d * a);</span>
              }
<span class="new">+         } else if (b != 0.0d) {</span>
<span class="new">+             zeroes[ret++] = -c / b;</span>
          }
          return ret - off;
      }
  
      // find the roots of g(t) = d*t^3 + a*t^2 + b*t + c in [A,B)
<span class="changed">!     static int cubicRootsInAB(final double d, double a, double b, double c,</span>
<span class="changed">!                               final double[] pts, final int off,</span>
                                final double A, final double B)
      {
          if (d == 0.0d) {
<span class="changed">!             final int num = quadraticRoots(a, b, c, pts, off);</span>
              return filterOutNotInAB(pts, off, num, A, B) - off;
          }
          // From Graphics Gems:
<span class="changed">!         // https://github.com/erich666/GraphicsGems/blob/master/gems/Roots3And4.c</span>
          // (also from awt.geom.CubicCurve2D. But here we don't need as
          // much accuracy and we don't want to create arrays so we use
          // our own customized version).
  
          // normal form: x^3 + ax^2 + bx + c = 0
<span class="new">+ </span>
<span class="new">+         /*</span>
<span class="new">+          * TODO: cleanup all that code after reading Roots3And4.c</span>
<span class="new">+          */</span>
          a /= d;
          b /= d;
          c /= d;
  
          //  substitute x = y - A/3 to eliminate quadratic term:
<hr /><span class="oldmarker">*** 100,166 ****</span>
          // Since we actually need P/3 and Q/2 for all of the
          // calculations that follow, we will calculate
          // p = P/3
          // q = Q/2
          // instead and use those values for simplicity of the code.
<span class="changed">!         double sq_A = a * a;</span>
<span class="changed">!         double p = (1.0d/3.0d) * ((-1.0d/3.0d) * sq_A + b);</span>
<span class="changed">!         double q = (1.0d/2.0d) * ((2.0d/27.0d) * a * sq_A - (1.0d/3.0d) * a * b + c);</span>
  
          // use Cardano's formula
  
<span class="changed">!         double cb_p = p * p * p;</span>
<span class="changed">!         double D = q * q + cb_p;</span>
  
          int num;
          if (D &lt; 0.0d) {
              // see: http://en.wikipedia.org/wiki/Cubic_function#Trigonometric_.28and_hyperbolic.29_method
<span class="changed">!             final double phi = (1.0d/3.0d) * Math.acos(-q / Math.sqrt(-cb_p));</span>
              final double t = 2.0d * Math.sqrt(-p);
  
<span class="changed">!             pts[ off+0 ] = ( t * Math.cos(phi));</span>
<span class="changed">!             pts[ off+1 ] = (-t * Math.cos(phi + (PI / 3.0d)));</span>
<span class="changed">!             pts[ off+2 ] = (-t * Math.cos(phi - (PI / 3.0d)));</span>
              num = 3;
          } else {
              final double sqrt_D = Math.sqrt(D);
              final double u =   Math.cbrt(sqrt_D - q);
              final double v = - Math.cbrt(sqrt_D + q);
  
<span class="changed">!             pts[ off ] = (u + v);</span>
              num = 1;
  
              if (within(D, 0.0d, 1e-8d)) {
<span class="changed">!                 pts[off+1] = -(pts[off] / 2.0d);</span>
                  num = 2;
              }
          }
  
<span class="removed">-         final double sub = (1.0d/3.0d) * a;</span>
<span class="removed">- </span>
<span class="removed">-         for (int i = 0; i &lt; num; ++i) {</span>
<span class="removed">-             pts[ off+i ] -= sub;</span>
<span class="removed">-         }</span>
<span class="removed">- </span>
          return filterOutNotInAB(pts, off, num, A, B) - off;
      }
  
<span class="removed">-     static double evalCubic(final double a, final double b,</span>
<span class="removed">-                            final double c, final double d,</span>
<span class="removed">-                            final double t)</span>
<span class="removed">-     {</span>
<span class="removed">-         return t * (t * (t * a + b) + c) + d;</span>
<span class="removed">-     }</span>
<span class="removed">- </span>
<span class="removed">-     static double evalQuad(final double a, final double b,</span>
<span class="removed">-                           final double c, final double t)</span>
<span class="removed">-     {</span>
<span class="removed">-         return t * (t * a + b) + c;</span>
<span class="removed">-     }</span>
<span class="removed">- </span>
      // returns the index 1 past the last valid element remaining after filtering
<span class="changed">!     static int filterOutNotInAB(double[] nums, final int off, final int len,</span>
                                  final double a, final double b)
      {
          int ret = off;
          for (int i = off, end = off + len; i &lt; end; i++) {
              if (nums[i] &gt;= a &amp;&amp; nums[i] &lt; b) {
<span class="newmarker">--- 111,159 ----</span>
          // Since we actually need P/3 and Q/2 for all of the
          // calculations that follow, we will calculate
          // p = P/3
          // q = Q/2
          // instead and use those values for simplicity of the code.
<span class="changed">!         final double sub = (1.0d / 3.0d) * a;</span>
<span class="changed">!         final double sq_A = a * a;</span>
<span class="changed">!         final double p = (1.0d / 3.0d) * ((-1.0d / 3.0d) * sq_A + b);</span>
<span class="changed">!         final double q = (1.0d / 2.0d) * ((2.0d / 27.0d) * a * sq_A - sub * b + c);</span>
  
          // use Cardano's formula
  
<span class="changed">!         final double cb_p = p * p * p;</span>
<span class="changed">!         final double D = q * q + cb_p;</span>
  
          int num;
          if (D &lt; 0.0d) {
              // see: http://en.wikipedia.org/wiki/Cubic_function#Trigonometric_.28and_hyperbolic.29_method
<span class="changed">!             final double phi = (1.0d / 3.0d) * Math.acos(-q / Math.sqrt(-cb_p));</span>
              final double t = 2.0d * Math.sqrt(-p);
  
<span class="changed">!             pts[off    ] = ( t * Math.cos(phi) - sub);</span>
<span class="changed">!             pts[off + 1] = (-t * Math.cos(phi + (Math.PI / 3.0d)) - sub);</span>
<span class="changed">!             pts[off + 2] = (-t * Math.cos(phi - (Math.PI / 3.0d)) - sub);</span>
              num = 3;
          } else {
              final double sqrt_D = Math.sqrt(D);
              final double u =   Math.cbrt(sqrt_D - q);
              final double v = - Math.cbrt(sqrt_D + q);
  
<span class="changed">!             pts[off    ] = (u + v - sub);</span>
              num = 1;
  
              if (within(D, 0.0d, 1e-8d)) {
<span class="changed">!                 pts[off + 1] = ((-1.0d / 2.0d) * (u + v) - sub);</span>
                  num = 2;
              }
          }
  
          return filterOutNotInAB(pts, off, num, A, B) - off;
      }
  
      // returns the index 1 past the last valid element remaining after filtering
<span class="changed">!     static int filterOutNotInAB(final double[] nums, final int off, final int len,</span>
                                  final double a, final double b)
      {
          int ret = off;
          for (int i = off, end = off + len; i &lt; end; i++) {
              if (nums[i] &gt;= a &amp;&amp; nums[i] &lt; b) {
<hr /><span class="oldmarker">*** 168,206 ****</span>
              }
          }
          return ret;
      }
  
<span class="changed">!     static double linelen(double x1, double y1, double x2, double y2) {</span>
<span class="changed">!         final double dx = x2 - x1;</span>
<span class="changed">!         final double dy = y2 - y1;</span>
<span class="changed">!         return Math.sqrt(dx*dx + dy*dy);</span>
      }
  
<span class="changed">!     static void subdivide(double[] src, int srcoff, double[] left, int leftoff,</span>
<span class="changed">!                           double[] right, int rightoff, int type)</span>
<span class="changed">!     {</span>
          switch(type) {
          case 6:
<span class="changed">!             DHelpers.subdivideQuad(src, srcoff, left, leftoff, right, rightoff);</span>
<span class="changed">!             return;</span>
          case 8:
<span class="changed">!             DHelpers.subdivideCubic(src, srcoff, left, leftoff, right, rightoff);</span>
              return;
          default:
              throw new InternalError("Unsupported curve type");
          }
      }
  
<span class="changed">!     static void isort(double[] a, int off, int len) {</span>
<span class="changed">!         for (int i = off + 1, end = off + len; i &lt; end; i++) {</span>
<span class="changed">!             double ai = a[i];</span>
<span class="changed">!             int j = i - 1;</span>
<span class="changed">!             for (; j &gt;= off &amp;&amp; a[j] &gt; ai; j--) {</span>
<span class="changed">!                 a[j+1] = a[j];</span>
              }
<span class="changed">!             a[j+1] = ai;</span>
          }
      }
  
      // Most of these are copied from classes in java.awt.geom because we need
      // both single and double precision variants of these functions, and Line2D,
<span class="newmarker">--- 161,353 ----</span>
              }
          }
          return ret;
      }
  
<span class="changed">!     static double fastLineLen(final double x0, final double y0,</span>
<span class="changed">!                               final double x1, final double y1)</span>
<span class="changed">!     {</span>
<span class="changed">!         final double dx = x1 - x0;</span>
<span class="changed">!         final double dy = y1 - y0;</span>
<span class="changed">! </span>
<span class="changed">!         // use manhattan norm:</span>
<span class="changed">!         return Math.abs(dx) + Math.abs(dy);</span>
      }
  
<span class="changed">!     static double linelen(final double x0, final double y0,</span>
<span class="changed">!                           final double x1, final double y1)</span>
<span class="changed">!     {</span>
<span class="changed">!         final double dx = x1 - x0;</span>
<span class="changed">!         final double dy = y1 - y0;</span>
<span class="changed">!         return Math.sqrt(dx * dx + dy * dy);</span>
<span class="changed">!     }</span>
<span class="changed">! </span>
<span class="changed">!     static double fastQuadLen(final double x0, final double y0,</span>
<span class="changed">!                               final double x1, final double y1,</span>
<span class="changed">!                               final double x2, final double y2)</span>
<span class="changed">!     {</span>
<span class="changed">!         final double dx1 = x1 - x0;</span>
<span class="changed">!         final double dx2 = x2 - x1;</span>
<span class="changed">!         final double dy1 = y1 - y0;</span>
<span class="changed">!         final double dy2 = y2 - y1;</span>
<span class="changed">! </span>
<span class="changed">!         // use manhattan norm:</span>
<span class="changed">!         return Math.abs(dx1) + Math.abs(dx2)</span>
<span class="changed">!              + Math.abs(dy1) + Math.abs(dy2);</span>
<span class="changed">!     }</span>
<span class="changed">! </span>
<span class="changed">!     static double quadlen(final double x0, final double y0,</span>
<span class="changed">!                           final double x1, final double y1,</span>
<span class="changed">!                           final double x2, final double y2)</span>
<span class="changed">!     {</span>
<span class="changed">!         return (linelen(x0, y0, x1, y1)</span>
<span class="changed">!                 + linelen(x1, y1, x2, y2)</span>
<span class="changed">!                 + linelen(x0, y0, x2, y2)) / 2.0d;</span>
<span class="changed">!     }</span>
<span class="changed">! </span>
<span class="changed">!     static double fastCurvelen(final double x0, final double y0,</span>
<span class="changed">!                                final double x1, final double y1,</span>
<span class="changed">!                                final double x2, final double y2,</span>
<span class="changed">!                                final double x3, final double y3)</span>
<span class="changed">!     {</span>
<span class="changed">!         final double dx1 = x1 - x0;</span>
<span class="changed">!         final double dx2 = x2 - x1;</span>
<span class="changed">!         final double dx3 = x3 - x2;</span>
<span class="changed">!         final double dy1 = y1 - y0;</span>
<span class="changed">!         final double dy2 = y2 - y1;</span>
<span class="changed">!         final double dy3 = y3 - y2;</span>
<span class="changed">! </span>
<span class="changed">!         // use manhattan norm:</span>
<span class="changed">!         return Math.abs(dx1) + Math.abs(dx2) + Math.abs(dx3)</span>
<span class="changed">!              + Math.abs(dy1) + Math.abs(dy2) + Math.abs(dy3);</span>
<span class="changed">!     }</span>
<span class="changed">! </span>
<span class="changed">!     static double curvelen(final double x0, final double y0,</span>
<span class="changed">!                            final double x1, final double y1,</span>
<span class="changed">!                            final double x2, final double y2,</span>
<span class="changed">!                            final double x3, final double y3)</span>
<span class="changed">!     {</span>
<span class="changed">!         return (linelen(x0, y0, x1, y1)</span>
<span class="changed">!               + linelen(x1, y1, x2, y2)</span>
<span class="changed">!               + linelen(x2, y2, x3, y3)</span>
<span class="changed">!               + linelen(x0, y0, x3, y3)) / 2.0d;</span>
<span class="changed">!     }</span>
<span class="changed">! </span>
<span class="changed">!     // finds values of t where the curve in pts should be subdivided in order</span>
<span class="changed">!     // to get good offset curves a distance of w away from the middle curve.</span>
<span class="changed">!     // Stores the points in ts, and returns how many of them there were.</span>
<span class="changed">!     static int findSubdivPoints(final DCurve c, final double[] pts,</span>
<span class="changed">!                                 final double[] ts, final int type,</span>
<span class="changed">!                                 final double w2)</span>
<span class="changed">!     {</span>
<span class="changed">!         final double x12 = pts[2] - pts[0];</span>
<span class="changed">!         final double y12 = pts[3] - pts[1];</span>
<span class="changed">!         // if the curve is already parallel to either axis we gain nothing</span>
<span class="changed">!         // from rotating it.</span>
<span class="changed">!         if ((y12 != 0.0d &amp;&amp; x12 != 0.0d)) {</span>
<span class="changed">!             // we rotate it so that the first vector in the control polygon is</span>
<span class="changed">!             // parallel to the x-axis. This will ensure that rotated quarter</span>
<span class="changed">!             // circles won't be subdivided.</span>
<span class="changed">!             final double hypot = Math.sqrt(x12 * x12 + y12 * y12);</span>
<span class="changed">!             final double cos = x12 / hypot;</span>
<span class="changed">!             final double sin = y12 / hypot;</span>
<span class="changed">!             final double x1 = cos * pts[0] + sin * pts[1];</span>
<span class="changed">!             final double y1 = cos * pts[1] - sin * pts[0];</span>
<span class="changed">!             final double x2 = cos * pts[2] + sin * pts[3];</span>
<span class="changed">!             final double y2 = cos * pts[3] - sin * pts[2];</span>
<span class="changed">!             final double x3 = cos * pts[4] + sin * pts[5];</span>
<span class="changed">!             final double y3 = cos * pts[5] - sin * pts[4];</span>
<span class="changed">! </span>
              switch(type) {
<span class="new">+             case 8:</span>
<span class="new">+                 final double x4 = cos * pts[6] + sin * pts[7];</span>
<span class="new">+                 final double y4 = cos * pts[7] - sin * pts[6];</span>
<span class="new">+                 c.set(x1, y1, x2, y2, x3, y3, x4, y4);</span>
<span class="new">+                 break;</span>
              case 6:
<span class="changed">!                 c.set(x1, y1, x2, y2, x3, y3);</span>
<span class="changed">!                 break;</span>
<span class="changed">!             default:</span>
<span class="changed">!             }</span>
<span class="changed">!         } else {</span>
<span class="changed">!             c.set(pts, type);</span>
<span class="changed">!         }</span>
<span class="changed">! </span>
<span class="changed">!         int ret = 0;</span>
<span class="changed">!         // we subdivide at values of t such that the remaining rotated</span>
<span class="changed">!         // curves are monotonic in x and y.</span>
<span class="changed">!         ret += c.dxRoots(ts, ret);</span>
<span class="changed">!         ret += c.dyRoots(ts, ret);</span>
<span class="changed">! </span>
<span class="changed">!         // subdivide at inflection points.</span>
<span class="changed">!         if (type == 8) {</span>
<span class="changed">!             // quadratic curves can't have inflection points</span>
<span class="changed">!             ret += c.infPoints(ts, ret);</span>
<span class="changed">!         }</span>
<span class="changed">! </span>
<span class="changed">!         // now we must subdivide at points where one of the offset curves will have</span>
<span class="changed">!         // a cusp. This happens at ts where the radius of curvature is equal to w.</span>
<span class="changed">!         ret += c.rootsOfROCMinusW(ts, ret, w2, 0.0001d);</span>
<span class="changed">! </span>
<span class="changed">!         ret = filterOutNotInAB(ts, 0, ret, 0.0001d, 0.9999d);</span>
<span class="changed">!         isort(ts, ret);</span>
<span class="changed">!         return ret;</span>
<span class="changed">!     }</span>
<span class="changed">! </span>
<span class="changed">!     // finds values of t where the curve in pts should be subdivided in order</span>
<span class="changed">!     // to get intersections with the given clip rectangle.</span>
<span class="changed">!     // Stores the points in ts, and returns how many of them there were.</span>
<span class="changed">!     static int findClipPoints(final DCurve curve, final double[] pts,</span>
<span class="changed">!                               final double[] ts, final int type,</span>
<span class="changed">!                               final int outCodeOR,</span>
<span class="changed">!                               final double[] clipRect)</span>
<span class="changed">!     {</span>
<span class="changed">!         curve.set(pts, type);</span>
<span class="changed">! </span>
<span class="changed">!         // clip rectangle (ymin, ymax, xmin, xmax)</span>
<span class="changed">!         int ret = 0;</span>
<span class="changed">! </span>
<span class="changed">!         if ((outCodeOR &amp; OUTCODE_LEFT) != 0) {</span>
<span class="changed">!             ret += curve.xPoints(ts, ret, clipRect[2]);</span>
<span class="changed">!         }</span>
<span class="changed">!         if ((outCodeOR &amp; OUTCODE_RIGHT) != 0) {</span>
<span class="changed">!             ret += curve.xPoints(ts, ret, clipRect[3]);</span>
<span class="changed">!         }</span>
<span class="changed">!         if ((outCodeOR &amp; OUTCODE_TOP) != 0) {</span>
<span class="changed">!             ret += curve.yPoints(ts, ret, clipRect[0]);</span>
<span class="changed">!         }</span>
<span class="changed">!         if ((outCodeOR &amp; OUTCODE_BOTTOM) != 0) {</span>
<span class="changed">!             ret += curve.yPoints(ts, ret, clipRect[1]);</span>
<span class="changed">!         }</span>
<span class="changed">!         isort(ts, ret);</span>
<span class="changed">!         return ret;</span>
<span class="changed">!     }</span>
<span class="changed">! </span>
<span class="changed">!     static void subdivide(final double[] src,</span>
<span class="changed">!                           final double[] left, final double[] right,</span>
<span class="changed">!                           final int type)</span>
<span class="changed">!     {</span>
<span class="changed">!         switch(type) {</span>
          case 8:
<span class="changed">!             subdivideCubic(src, left, right);</span>
<span class="changed">!             return;</span>
<span class="changed">!         case 6:</span>
<span class="changed">!             subdivideQuad(src, left, right);</span>
              return;
          default:
              throw new InternalError("Unsupported curve type");
          }
      }
  
<span class="changed">!     static void isort(final double[] a, final int len) {</span>
<span class="changed">!         for (int i = 1, j; i &lt; len; i++) {</span>
<span class="changed">!             final double ai = a[i];</span>
<span class="changed">!             j = i - 1;</span>
<span class="changed">!             for (; j &gt;= 0 &amp;&amp; a[j] &gt; ai; j--) {</span>
<span class="changed">!                 a[j + 1] = a[j];</span>
              }
<span class="changed">!             a[j + 1] = ai;</span>
          }
      }
  
      // Most of these are copied from classes in java.awt.geom because we need
      // both single and double precision variants of these functions, and Line2D,
<hr /><span class="oldmarker">*** 219,428 ****</span>
       * it is possible to pass the same array for &lt;code&gt;left&lt;/code&gt;
       * and &lt;code&gt;right&lt;/code&gt; and to use offsets, such as &lt;code&gt;rightoff&lt;/code&gt;
       * equals (&lt;code&gt;leftoff&lt;/code&gt; + 6), in order
       * to avoid allocating extra storage for this common point.
       * @param src the array holding the coordinates for the source curve
<span class="removed">-      * @param srcoff the offset into the array of the beginning of the</span>
<span class="removed">-      * the 6 source coordinates</span>
       * @param left the array for storing the coordinates for the first
       * half of the subdivided curve
<span class="removed">-      * @param leftoff the offset into the array of the beginning of the</span>
<span class="removed">-      * the 6 left coordinates</span>
       * @param right the array for storing the coordinates for the second
       * half of the subdivided curve
<span class="removed">-      * @param rightoff the offset into the array of the beginning of the</span>
<span class="removed">-      * the 6 right coordinates</span>
       * @since 1.7
       */
<span class="changed">!     static void subdivideCubic(double[] src, int srcoff,</span>
<span class="changed">!                                double[] left, int leftoff,</span>
<span class="changed">!                                double[] right, int rightoff)</span>
<span class="changed">!     {</span>
<span class="changed">!         double x1 = src[srcoff + 0];</span>
<span class="changed">!         double y1 = src[srcoff + 1];</span>
<span class="changed">!         double ctrlx1 = src[srcoff + 2];</span>
<span class="changed">!         double ctrly1 = src[srcoff + 3];</span>
<span class="changed">!         double ctrlx2 = src[srcoff + 4];</span>
<span class="changed">!         double ctrly2 = src[srcoff + 5];</span>
<span class="changed">!         double x2 = src[srcoff + 6];</span>
<span class="changed">!         double y2 = src[srcoff + 7];</span>
<span class="changed">!         if (left != null) {</span>
<span class="changed">!             left[leftoff + 0] = x1;</span>
<span class="changed">!             left[leftoff + 1] = y1;</span>
<span class="changed">!         }</span>
<span class="changed">!         if (right != null) {</span>
<span class="changed">!             right[rightoff + 6] = x2;</span>
<span class="changed">!             right[rightoff + 7] = y2;</span>
<span class="changed">!         }</span>
<span class="changed">!         x1 = (x1 + ctrlx1) / 2.0d;</span>
<span class="changed">!         y1 = (y1 + ctrly1) / 2.0d;</span>
<span class="changed">!         x2 = (x2 + ctrlx2) / 2.0d;</span>
<span class="changed">!         y2 = (y2 + ctrly2) / 2.0d;</span>
<span class="changed">!         double centerx = (ctrlx1 + ctrlx2) / 2.0d;</span>
<span class="changed">!         double centery = (ctrly1 + ctrly2) / 2.0d;</span>
<span class="changed">!         ctrlx1 = (x1 + centerx) / 2.0d;</span>
<span class="changed">!         ctrly1 = (y1 + centery) / 2.0d;</span>
<span class="changed">!         ctrlx2 = (x2 + centerx) / 2.0d;</span>
<span class="changed">!         ctrly2 = (y2 + centery) / 2.0d;</span>
<span class="changed">!         centerx = (ctrlx1 + ctrlx2) / 2.0d;</span>
<span class="changed">!         centery = (ctrly1 + ctrly2) / 2.0d;</span>
<span class="changed">!         if (left != null) {</span>
<span class="changed">!             left[leftoff + 2] = x1;</span>
<span class="changed">!             left[leftoff + 3] = y1;</span>
<span class="changed">!             left[leftoff + 4] = ctrlx1;</span>
<span class="changed">!             left[leftoff + 5] = ctrly1;</span>
<span class="changed">!             left[leftoff + 6] = centerx;</span>
<span class="changed">!             left[leftoff + 7] = centery;</span>
<span class="changed">!         }</span>
<span class="changed">!         if (right != null) {</span>
<span class="changed">!             right[rightoff + 0] = centerx;</span>
<span class="changed">!             right[rightoff + 1] = centery;</span>
<span class="changed">!             right[rightoff + 2] = ctrlx2;</span>
<span class="changed">!             right[rightoff + 3] = ctrly2;</span>
<span class="changed">!             right[rightoff + 4] = x2;</span>
<span class="changed">!             right[rightoff + 5] = y2;</span>
<span class="changed">!         }</span>
<span class="changed">!     }</span>
<span class="changed">! </span>
<span class="changed">! </span>
<span class="changed">!     static void subdivideCubicAt(double t, double[] src, int srcoff,</span>
<span class="changed">!                                  double[] left, int leftoff,</span>
<span class="changed">!                                  double[] right, int rightoff)</span>
<span class="changed">!     {</span>
<span class="changed">!         double x1 = src[srcoff + 0];</span>
<span class="changed">!         double y1 = src[srcoff + 1];</span>
<span class="changed">!         double ctrlx1 = src[srcoff + 2];</span>
<span class="changed">!         double ctrly1 = src[srcoff + 3];</span>
<span class="changed">!         double ctrlx2 = src[srcoff + 4];</span>
<span class="changed">!         double ctrly2 = src[srcoff + 5];</span>
<span class="changed">!         double x2 = src[srcoff + 6];</span>
<span class="changed">!         double y2 = src[srcoff + 7];</span>
<span class="changed">!         if (left != null) {</span>
<span class="changed">!             left[leftoff + 0] = x1;</span>
<span class="changed">!             left[leftoff + 1] = y1;</span>
<span class="changed">!         }</span>
<span class="changed">!         if (right != null) {</span>
<span class="changed">!             right[rightoff + 6] = x2;</span>
<span class="changed">!             right[rightoff + 7] = y2;</span>
<span class="changed">!         }</span>
<span class="changed">!         x1 = x1 + t * (ctrlx1 - x1);</span>
<span class="changed">!         y1 = y1 + t * (ctrly1 - y1);</span>
<span class="changed">!         x2 = ctrlx2 + t * (x2 - ctrlx2);</span>
<span class="changed">!         y2 = ctrly2 + t * (y2 - ctrly2);</span>
<span class="changed">!         double centerx = ctrlx1 + t * (ctrlx2 - ctrlx1);</span>
<span class="changed">!         double centery = ctrly1 + t * (ctrly2 - ctrly1);</span>
<span class="changed">!         ctrlx1 = x1 + t * (centerx - x1);</span>
<span class="changed">!         ctrly1 = y1 + t * (centery - y1);</span>
<span class="changed">!         ctrlx2 = centerx + t * (x2 - centerx);</span>
<span class="changed">!         ctrly2 = centery + t * (y2 - centery);</span>
<span class="changed">!         centerx = ctrlx1 + t * (ctrlx2 - ctrlx1);</span>
<span class="changed">!         centery = ctrly1 + t * (ctrly2 - ctrly1);</span>
<span class="changed">!         if (left != null) {</span>
<span class="changed">!             left[leftoff + 2] = x1;</span>
<span class="changed">!             left[leftoff + 3] = y1;</span>
<span class="changed">!             left[leftoff + 4] = ctrlx1;</span>
<span class="changed">!             left[leftoff + 5] = ctrly1;</span>
<span class="changed">!             left[leftoff + 6] = centerx;</span>
<span class="changed">!             left[leftoff + 7] = centery;</span>
<span class="changed">!         }</span>
<span class="changed">!         if (right != null) {</span>
<span class="changed">!             right[rightoff + 0] = centerx;</span>
<span class="changed">!             right[rightoff + 1] = centery;</span>
<span class="changed">!             right[rightoff + 2] = ctrlx2;</span>
<span class="changed">!             right[rightoff + 3] = ctrly2;</span>
<span class="changed">!             right[rightoff + 4] = x2;</span>
<span class="changed">!             right[rightoff + 5] = y2;</span>
<span class="changed">!         }</span>
<span class="changed">!     }</span>
<span class="changed">! </span>
<span class="changed">!     static void subdivideQuad(double[] src, int srcoff,</span>
<span class="changed">!                               double[] left, int leftoff,</span>
<span class="changed">!                               double[] right, int rightoff)</span>
<span class="changed">!     {</span>
<span class="changed">!         double x1 = src[srcoff + 0];</span>
<span class="changed">!         double y1 = src[srcoff + 1];</span>
<span class="changed">!         double ctrlx = src[srcoff + 2];</span>
<span class="changed">!         double ctrly = src[srcoff + 3];</span>
<span class="changed">!         double x2 = src[srcoff + 4];</span>
<span class="changed">!         double y2 = src[srcoff + 5];</span>
<span class="changed">!         if (left != null) {</span>
<span class="changed">!             left[leftoff + 0] = x1;</span>
<span class="changed">!             left[leftoff + 1] = y1;</span>
<span class="changed">!         }</span>
<span class="changed">!         if (right != null) {</span>
<span class="changed">!             right[rightoff + 4] = x2;</span>
<span class="changed">!             right[rightoff + 5] = y2;</span>
<span class="changed">!         }</span>
<span class="changed">!         x1 = (x1 + ctrlx) / 2.0d;</span>
<span class="changed">!         y1 = (y1 + ctrly) / 2.0d;</span>
<span class="changed">!         x2 = (x2 + ctrlx) / 2.0d;</span>
<span class="changed">!         y2 = (y2 + ctrly) / 2.0d;</span>
<span class="changed">!         ctrlx = (x1 + x2) / 2.0d;</span>
<span class="changed">!         ctrly = (y1 + y2) / 2.0d;</span>
<span class="changed">!         if (left != null) {</span>
<span class="changed">!             left[leftoff + 2] = x1;</span>
<span class="changed">!             left[leftoff + 3] = y1;</span>
<span class="changed">!             left[leftoff + 4] = ctrlx;</span>
<span class="changed">!             left[leftoff + 5] = ctrly;</span>
<span class="changed">!         }</span>
<span class="changed">!         if (right != null) {</span>
<span class="changed">!             right[rightoff + 0] = ctrlx;</span>
<span class="changed">!             right[rightoff + 1] = ctrly;</span>
<span class="changed">!             right[rightoff + 2] = x2;</span>
<span class="changed">!             right[rightoff + 3] = y2;</span>
<span class="changed">!         }</span>
<span class="changed">!     }</span>
<span class="changed">! </span>
<span class="changed">!     static void subdivideQuadAt(double t, double[] src, int srcoff,</span>
<span class="changed">!                                 double[] left, int leftoff,</span>
<span class="changed">!                                 double[] right, int rightoff)</span>
<span class="changed">!     {</span>
<span class="changed">!         double x1 = src[srcoff + 0];</span>
<span class="changed">!         double y1 = src[srcoff + 1];</span>
<span class="changed">!         double ctrlx = src[srcoff + 2];</span>
<span class="changed">!         double ctrly = src[srcoff + 3];</span>
<span class="changed">!         double x2 = src[srcoff + 4];</span>
<span class="changed">!         double y2 = src[srcoff + 5];</span>
<span class="changed">!         if (left != null) {</span>
<span class="changed">!             left[leftoff + 0] = x1;</span>
<span class="changed">!             left[leftoff + 1] = y1;</span>
<span class="changed">!         }</span>
<span class="changed">!         if (right != null) {</span>
<span class="changed">!             right[rightoff + 4] = x2;</span>
<span class="changed">!             right[rightoff + 5] = y2;</span>
<span class="changed">!         }</span>
<span class="changed">!         x1 = x1 + t * (ctrlx - x1);</span>
<span class="changed">!         y1 = y1 + t * (ctrly - y1);</span>
<span class="changed">!         x2 = ctrlx + t * (x2 - ctrlx);</span>
<span class="changed">!         y2 = ctrly + t * (y2 - ctrly);</span>
<span class="changed">!         ctrlx = x1 + t * (x2 - x1);</span>
<span class="changed">!         ctrly = y1 + t * (y2 - y1);</span>
<span class="changed">!         if (left != null) {</span>
<span class="changed">!             left[leftoff + 2] = x1;</span>
<span class="changed">!             left[leftoff + 3] = y1;</span>
<span class="changed">!             left[leftoff + 4] = ctrlx;</span>
<span class="changed">!             left[leftoff + 5] = ctrly;</span>
<span class="changed">!         }</span>
<span class="changed">!         if (right != null) {</span>
<span class="changed">!             right[rightoff + 0] = ctrlx;</span>
<span class="changed">!             right[rightoff + 1] = ctrly;</span>
<span class="changed">!             right[rightoff + 2] = x2;</span>
<span class="changed">!             right[rightoff + 3] = y2;</span>
<span class="changed">!         }</span>
<span class="changed">!     }</span>
<span class="changed">! </span>
<span class="changed">!     static void subdivideAt(double t, double[] src, int srcoff,</span>
<span class="changed">!                             double[] left, int leftoff,</span>
<span class="changed">!                             double[] right, int rightoff, int size)</span>
<span class="changed">!     {</span>
<span class="changed">!         switch(size) {</span>
<span class="changed">!         case 8:</span>
<span class="changed">!             subdivideCubicAt(t, src, srcoff, left, leftoff, right, rightoff);</span>
<span class="changed">!             return;</span>
<span class="changed">!         case 6:</span>
<span class="changed">!             subdivideQuadAt(t, src, srcoff, left, leftoff, right, rightoff);</span>
<span class="changed">!             return;</span>
          }
      }
  
      // From sun.java2d.loops.GeneralRenderer:
  
<span class="newmarker">--- 366,585 ----</span>
       * it is possible to pass the same array for &lt;code&gt;left&lt;/code&gt;
       * and &lt;code&gt;right&lt;/code&gt; and to use offsets, such as &lt;code&gt;rightoff&lt;/code&gt;
       * equals (&lt;code&gt;leftoff&lt;/code&gt; + 6), in order
       * to avoid allocating extra storage for this common point.
       * @param src the array holding the coordinates for the source curve
       * @param left the array for storing the coordinates for the first
       * half of the subdivided curve
       * @param right the array for storing the coordinates for the second
       * half of the subdivided curve
       * @since 1.7
       */
<span class="changed">!     static void subdivideCubic(final double[] src,</span>
<span class="changed">!                                final double[] left,</span>
<span class="changed">!                                final double[] right)</span>
<span class="changed">!     {</span>
<span class="changed">!         double  x1 = src[0];</span>
<span class="changed">!         double  y1 = src[1];</span>
<span class="changed">!         double cx1 = src[2];</span>
<span class="changed">!         double cy1 = src[3];</span>
<span class="changed">!         double cx2 = src[4];</span>
<span class="changed">!         double cy2 = src[5];</span>
<span class="changed">!         double  x2 = src[6];</span>
<span class="changed">!         double  y2 = src[7];</span>
<span class="changed">! </span>
<span class="changed">!         left[0]  = x1;</span>
<span class="changed">!         left[1]  = y1;</span>
<span class="changed">! </span>
<span class="changed">!         right[6] = x2;</span>
<span class="changed">!         right[7] = y2;</span>
<span class="changed">! </span>
<span class="changed">!         x1 = (x1 + cx1) / 2.0d;</span>
<span class="changed">!         y1 = (y1 + cy1) / 2.0d;</span>
<span class="changed">!         x2 = (x2 + cx2) / 2.0d;</span>
<span class="changed">!         y2 = (y2 + cy2) / 2.0d;</span>
<span class="changed">! </span>
<span class="changed">!         double cx = (cx1 + cx2) / 2.0d;</span>
<span class="changed">!         double cy = (cy1 + cy2) / 2.0d;</span>
<span class="changed">! </span>
<span class="changed">!         cx1 = (x1 + cx) / 2.0d;</span>
<span class="changed">!         cy1 = (y1 + cy) / 2.0d;</span>
<span class="changed">!         cx2 = (x2 + cx) / 2.0d;</span>
<span class="changed">!         cy2 = (y2 + cy) / 2.0d;</span>
<span class="changed">!         cx  = (cx1 + cx2) / 2.0d;</span>
<span class="changed">!         cy  = (cy1 + cy2) / 2.0d;</span>
<span class="changed">! </span>
<span class="changed">!         left[2] = x1;</span>
<span class="changed">!         left[3] = y1;</span>
<span class="changed">!         left[4] = cx1;</span>
<span class="changed">!         left[5] = cy1;</span>
<span class="changed">!         left[6] = cx;</span>
<span class="changed">!         left[7] = cy;</span>
<span class="changed">! </span>
<span class="changed">!         right[0] = cx;</span>
<span class="changed">!         right[1] = cy;</span>
<span class="changed">!         right[2] = cx2;</span>
<span class="changed">!         right[3] = cy2;</span>
<span class="changed">!         right[4] = x2;</span>
<span class="changed">!         right[5] = y2;</span>
<span class="changed">!     }</span>
<span class="changed">! </span>
<span class="changed">!     static void subdivideCubicAt(final double t,</span>
<span class="changed">!                                  final double[] src, final int offS,</span>
<span class="changed">!                                  final double[] pts, final int offL, final int offR)</span>
<span class="changed">!     {</span>
<span class="changed">!         double  x1 = src[offS    ];</span>
<span class="changed">!         double  y1 = src[offS + 1];</span>
<span class="changed">!         double cx1 = src[offS + 2];</span>
<span class="changed">!         double cy1 = src[offS + 3];</span>
<span class="changed">!         double cx2 = src[offS + 4];</span>
<span class="changed">!         double cy2 = src[offS + 5];</span>
<span class="changed">!         double  x2 = src[offS + 6];</span>
<span class="changed">!         double  y2 = src[offS + 7];</span>
<span class="changed">! </span>
<span class="changed">!         pts[offL    ] = x1;</span>
<span class="changed">!         pts[offL + 1] = y1;</span>
<span class="changed">! </span>
<span class="changed">!         pts[offR + 6] = x2;</span>
<span class="changed">!         pts[offR + 7] = y2;</span>
<span class="changed">! </span>
<span class="changed">!         x1 =  x1 + t * (cx1 - x1);</span>
<span class="changed">!         y1 =  y1 + t * (cy1 - y1);</span>
<span class="changed">!         x2 = cx2 + t * (x2 - cx2);</span>
<span class="changed">!         y2 = cy2 + t * (y2 - cy2);</span>
<span class="changed">! </span>
<span class="changed">!         double cx = cx1 + t * (cx2 - cx1);</span>
<span class="changed">!         double cy = cy1 + t * (cy2 - cy1);</span>
<span class="changed">! </span>
<span class="changed">!         cx1 =  x1 + t * (cx - x1);</span>
<span class="changed">!         cy1 =  y1 + t * (cy - y1);</span>
<span class="changed">!         cx2 =  cx + t * (x2 - cx);</span>
<span class="changed">!         cy2 =  cy + t * (y2 - cy);</span>
<span class="changed">!         cx  = cx1 + t * (cx2 - cx1);</span>
<span class="changed">!         cy  = cy1 + t * (cy2 - cy1);</span>
<span class="changed">! </span>
<span class="changed">!         pts[offL + 2] = x1;</span>
<span class="changed">!         pts[offL + 3] = y1;</span>
<span class="changed">!         pts[offL + 4] = cx1;</span>
<span class="changed">!         pts[offL + 5] = cy1;</span>
<span class="changed">!         pts[offL + 6] = cx;</span>
<span class="changed">!         pts[offL + 7] = cy;</span>
<span class="changed">! </span>
<span class="changed">!         pts[offR    ] = cx;</span>
<span class="changed">!         pts[offR + 1] = cy;</span>
<span class="changed">!         pts[offR + 2] = cx2;</span>
<span class="changed">!         pts[offR + 3] = cy2;</span>
<span class="changed">!         pts[offR + 4] = x2;</span>
<span class="changed">!         pts[offR + 5] = y2;</span>
<span class="changed">!     }</span>
<span class="changed">! </span>
<span class="changed">!     static void subdivideQuad(final double[] src,</span>
<span class="changed">!                               final double[] left,</span>
<span class="changed">!                               final double[] right)</span>
<span class="changed">!     {</span>
<span class="changed">!         double x1 = src[0];</span>
<span class="changed">!         double y1 = src[1];</span>
<span class="changed">!         double cx = src[2];</span>
<span class="changed">!         double cy = src[3];</span>
<span class="changed">!         double x2 = src[4];</span>
<span class="changed">!         double y2 = src[5];</span>
<span class="changed">! </span>
<span class="changed">!         left[0]  = x1;</span>
<span class="changed">!         left[1]  = y1;</span>
<span class="changed">! </span>
<span class="changed">!         right[4] = x2;</span>
<span class="changed">!         right[5] = y2;</span>
<span class="changed">! </span>
<span class="changed">!         x1 = (x1 + cx) / 2.0d;</span>
<span class="changed">!         y1 = (y1 + cy) / 2.0d;</span>
<span class="changed">!         x2 = (x2 + cx) / 2.0d;</span>
<span class="changed">!         y2 = (y2 + cy) / 2.0d;</span>
<span class="changed">!         cx = (x1 + x2) / 2.0d;</span>
<span class="changed">!         cy = (y1 + y2) / 2.0d;</span>
<span class="changed">! </span>
<span class="changed">!         left[2] = x1;</span>
<span class="changed">!         left[3] = y1;</span>
<span class="changed">!         left[4] = cx;</span>
<span class="changed">!         left[5] = cy;</span>
<span class="changed">! </span>
<span class="changed">!         right[0] = cx;</span>
<span class="changed">!         right[1] = cy;</span>
<span class="changed">!         right[2] = x2;</span>
<span class="changed">!         right[3] = y2;</span>
<span class="changed">!     }</span>
<span class="changed">! </span>
<span class="changed">!     static void subdivideQuadAt(final double t,</span>
<span class="changed">!                                 final double[] src, final int offS,</span>
<span class="changed">!                                 final double[] pts, final int offL, final int offR)</span>
<span class="changed">!     {</span>
<span class="changed">!         double x1 = src[offS    ];</span>
<span class="changed">!         double y1 = src[offS + 1];</span>
<span class="changed">!         double cx = src[offS + 2];</span>
<span class="changed">!         double cy = src[offS + 3];</span>
<span class="changed">!         double x2 = src[offS + 4];</span>
<span class="changed">!         double y2 = src[offS + 5];</span>
<span class="changed">! </span>
<span class="changed">!         pts[offL    ] = x1;</span>
<span class="changed">!         pts[offL + 1] = y1;</span>
<span class="changed">! </span>
<span class="changed">!         pts[offR + 4] = x2;</span>
<span class="changed">!         pts[offR + 5] = y2;</span>
<span class="changed">! </span>
<span class="changed">!         x1 = x1 + t * (cx - x1);</span>
<span class="changed">!         y1 = y1 + t * (cy - y1);</span>
<span class="changed">!         x2 = cx + t * (x2 - cx);</span>
<span class="changed">!         y2 = cy + t * (y2 - cy);</span>
<span class="changed">!         cx = x1 + t * (x2 - x1);</span>
<span class="changed">!         cy = y1 + t * (y2 - y1);</span>
<span class="changed">! </span>
<span class="changed">!         pts[offL + 2] = x1;</span>
<span class="changed">!         pts[offL + 3] = y1;</span>
<span class="changed">!         pts[offL + 4] = cx;</span>
<span class="changed">!         pts[offL + 5] = cy;</span>
<span class="changed">! </span>
<span class="changed">!         pts[offR    ] = cx;</span>
<span class="changed">!         pts[offR + 1] = cy;</span>
<span class="changed">!         pts[offR + 2] = x2;</span>
<span class="changed">!         pts[offR + 3] = y2;</span>
<span class="changed">!     }</span>
<span class="changed">! </span>
<span class="changed">!     static void subdivideLineAt(final double t,</span>
<span class="changed">!                                 final double[] src, final int offS,</span>
<span class="changed">!                                 final double[] pts, final int offL, final int offR)</span>
<span class="changed">!     {</span>
<span class="changed">!         double x1 = src[offS    ];</span>
<span class="changed">!         double y1 = src[offS + 1];</span>
<span class="changed">!         double x2 = src[offS + 2];</span>
<span class="changed">!         double y2 = src[offS + 3];</span>
<span class="changed">! </span>
<span class="changed">!         pts[offL    ] = x1;</span>
<span class="changed">!         pts[offL + 1] = y1;</span>
<span class="changed">! </span>
<span class="changed">!         pts[offR + 2] = x2;</span>
<span class="changed">!         pts[offR + 3] = y2;</span>
<span class="changed">! </span>
<span class="changed">!         x1 = x1 + t * (x2 - x1);</span>
<span class="changed">!         y1 = y1 + t * (y2 - y1);</span>
<span class="changed">! </span>
<span class="changed">!         pts[offL + 2] = x1;</span>
<span class="changed">!         pts[offL + 3] = y1;</span>
<span class="changed">! </span>
<span class="changed">!         pts[offR    ] = x1;</span>
<span class="changed">!         pts[offR + 1] = y1;</span>
<span class="changed">!     }</span>
<span class="changed">! </span>
<span class="changed">!     static void subdivideAt(final double t,</span>
<span class="changed">!                             final double[] src, final int offS,</span>
<span class="changed">!                             final double[] pts, final int offL, final int type)</span>
<span class="changed">!     {</span>
<span class="changed">!         // if instead of switch (perf + most probable cases first)</span>
<span class="changed">!         if (type == 8) {</span>
<span class="changed">!             subdivideCubicAt(t, src, offS, pts, offL, offL + type);</span>
<span class="changed">!         } else if (type == 4) {</span>
<span class="changed">!             subdivideLineAt(t, src, offS, pts, offL, offL + type);</span>
<span class="changed">!         } else {</span>
<span class="changed">!             subdivideQuadAt(t, src, offS, pts, offL, offL + type);</span>
          }
      }
  
      // From sun.java2d.loops.GeneralRenderer:
  
<hr /><span class="oldmarker">*** 606,621 ****</span>
                  case TYPE_LINETO:
                      io.lineTo(_curves[e], _curves[e+1]);
                      e += 2;
                      continue;
                  case TYPE_QUADTO:
<span class="changed">!                     io.quadTo(_curves[e+0], _curves[e+1],</span>
                                _curves[e+2], _curves[e+3]);
                      e += 4;
                      continue;
                  case TYPE_CUBICTO:
<span class="changed">!                     io.curveTo(_curves[e+0], _curves[e+1],</span>
                                 _curves[e+2], _curves[e+3],
                                 _curves[e+4], _curves[e+5]);
                      e += 6;
                      continue;
                  default:
<span class="newmarker">--- 763,778 ----</span>
                  case TYPE_LINETO:
                      io.lineTo(_curves[e], _curves[e+1]);
                      e += 2;
                      continue;
                  case TYPE_QUADTO:
<span class="changed">!                     io.quadTo(_curves[e],   _curves[e+1],</span>
                                _curves[e+2], _curves[e+3]);
                      e += 4;
                      continue;
                  case TYPE_CUBICTO:
<span class="changed">!                     io.curveTo(_curves[e],   _curves[e+1],</span>
                                 _curves[e+2], _curves[e+3],
                                 _curves[e+4], _curves[e+5]);
                      e += 6;
                      continue;
                  default:
<hr /><span class="oldmarker">*** 649,664 ****</span>
                      e -= 2;
                      io.lineTo(_curves[e], _curves[e+1]);
                      continue;
                  case TYPE_QUADTO:
                      e -= 4;
<span class="changed">!                     io.quadTo(_curves[e+0], _curves[e+1],</span>
                                _curves[e+2], _curves[e+3]);
                      continue;
                  case TYPE_CUBICTO:
                      e -= 6;
<span class="changed">!                     io.curveTo(_curves[e+0], _curves[e+1],</span>
                                 _curves[e+2], _curves[e+3],
                                 _curves[e+4], _curves[e+5]);
                      continue;
                  default:
                  }
<span class="newmarker">--- 806,821 ----</span>
                      e -= 2;
                      io.lineTo(_curves[e], _curves[e+1]);
                      continue;
                  case TYPE_QUADTO:
                      e -= 4;
<span class="changed">!                     io.quadTo(_curves[e],   _curves[e+1],</span>
                                _curves[e+2], _curves[e+3]);
                      continue;
                  case TYPE_CUBICTO:
                      e -= 6;
<span class="changed">!                     io.curveTo(_curves[e],   _curves[e+1],</span>
                                 _curves[e+2], _curves[e+3],
                                 _curves[e+4], _curves[e+5]);
                      continue;
                  default:
                  }
</pre>
<center><a href='../../../../../../src/share/classes/sun/java2d/marlin/DDasher.java.cdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../src/share/classes/sun/java2d/marlin/DMarlinRenderingEngine.java.cdiff.html' target='_top'>next &gt</a></center>
</body></html>

