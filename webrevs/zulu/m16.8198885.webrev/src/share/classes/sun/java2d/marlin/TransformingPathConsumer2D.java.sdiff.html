<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>jdk Sdiff src/share/classes/sun/java2d/marlin </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../../../src/share/classes/sun/java2d/marlin/Stroker.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../src/share/classes/sun/java2d/marlin/Version.java.sdiff.html' target='_top'>next &gt</a></center>
<h2>src/share/classes/sun/java2d/marlin/TransformingPathConsumer2D.java</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-13695">13695</a> : <a href="https://bugs.openjdk.java.net/browse/JDK-8198885">8198885</a>: upgrade Marlin (java2d) to 0.9.1
Summary: clipping implemented in Dasher (curve subdivision at clip edges) + higher quality(curve, subpixels) + new path simplifier
Reviewed-by: prr, serb</pre>

<table><tr valign="top">
<td><pre>
   1 /*
<span class="changed">   2  * Copyright (c) 2007, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the "Classpath" exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.java2d.marlin;
  27 
  28 import sun.awt.geom.PathConsumer2D;
  29 import java.awt.geom.AffineTransform;
  30 import java.awt.geom.Path2D;

  31 import sun.java2d.marlin.Helpers.IndexStack;
  32 import sun.java2d.marlin.Helpers.PolyStack;
  33 
  34 final class TransformingPathConsumer2D {
  35 



  36     private final RendererContext rdrCtx;
  37 
  38     // recycled ClosedPathDetector instance from detectClosedPath()
  39     private final ClosedPathDetector   cpDetector;
  40 
  41     // recycled PathClipFilter instance from pathClipper()
  42     private final PathClipFilter       pathClipper;
  43 
  44     // recycled PathConsumer2D instance from wrapPath2D()
  45     private final Path2DWrapper        wp_Path2DWrapper        = new Path2DWrapper();
  46 
  47     // recycled PathConsumer2D instances from deltaTransformConsumer()
  48     private final DeltaScaleFilter     dt_DeltaScaleFilter     = new DeltaScaleFilter();
  49     private final DeltaTransformFilter dt_DeltaTransformFilter = new DeltaTransformFilter();
  50 
  51     // recycled PathConsumer2D instances from inverseDeltaTransformConsumer()
  52     private final DeltaScaleFilter     iv_DeltaScaleFilter     = new DeltaScaleFilter();
  53     private final DeltaTransformFilter iv_DeltaTransformFilter = new DeltaTransformFilter();
  54 
  55     // recycled PathTracer instances from tracer...() methods
  56     private final PathTracer tracerInput      = new PathTracer("[Input]");
  57     private final PathTracer tracerCPDetector = new PathTracer("ClosedPathDetector");
  58     private final PathTracer tracerFiller     = new PathTracer("Filler");
  59     private final PathTracer tracerStroker    = new PathTracer("Stroker");

  60 
  61     TransformingPathConsumer2D(final RendererContext rdrCtx) {
  62         // used by RendererContext
  63         this.rdrCtx = rdrCtx;
  64         this.cpDetector = new ClosedPathDetector(rdrCtx);
  65         this.pathClipper = new PathClipFilter(rdrCtx);
  66     }
  67 
  68     PathConsumer2D wrapPath2D(Path2D.Float p2d) {
  69         return wp_Path2DWrapper.init(p2d);
  70     }
  71 
  72     PathConsumer2D traceInput(PathConsumer2D out) {
  73         return tracerInput.init(out);
  74     }
  75 
  76     PathConsumer2D traceClosedPathDetector(PathConsumer2D out) {
  77         return tracerCPDetector.init(out);
  78     }
  79 
  80     PathConsumer2D traceFiller(PathConsumer2D out) {
  81         return tracerFiller.init(out);
  82     }
  83 
  84     PathConsumer2D traceStroker(PathConsumer2D out) {
  85         return tracerStroker.init(out);
  86     }
  87 




  88     PathConsumer2D detectClosedPath(PathConsumer2D out) {
  89         return cpDetector.init(out);
  90     }
  91 
  92     PathConsumer2D pathClipper(PathConsumer2D out) {
  93         return pathClipper.init(out);
  94     }
  95 
  96     PathConsumer2D deltaTransformConsumer(PathConsumer2D out,
  97                                           AffineTransform at)
  98     {
  99         if (at == null) {
 100             return out;
 101         }
 102         final float mxx = (float) at.getScaleX();
 103         final float mxy = (float) at.getShearX();
 104         final float myx = (float) at.getShearY();
 105         final float myy = (float) at.getScaleY();
 106 
 107         if (mxy == 0.0f &amp;&amp; myx == 0.0f) {

</pre><hr></hr><pre>
 483     static final class PathClipFilter implements PathConsumer2D {
 484 
 485         private PathConsumer2D out;
 486 
 487         // Bounds of the drawing region, at pixel precision.
 488         private final float[] clipRect;
 489 
 490         private final float[] corners = new float[8];
 491         private boolean init_corners = false;
 492 
 493         private final IndexStack stack;
 494 
 495         // the current outcode of the current sub path
 496         private int cOutCode = 0;
 497 
 498         // the cumulated (and) outcode of the complete path
 499         private int gOutCode = MarlinConst.OUTCODE_MASK_T_B_L_R;
 500 
 501         private boolean outside = false;
 502 
<span class="changed"> 503         // The current point OUTSIDE</span>
 504         private float cx0, cy0;
 505 






 506         PathClipFilter(final RendererContext rdrCtx) {
 507             this.clipRect = rdrCtx.clipRect;


 508             this.stack = (rdrCtx.stats != null) ?
 509                 new IndexStack(rdrCtx,
 510                         rdrCtx.stats.stat_pcf_idxstack_indices,
 511                         rdrCtx.stats.hist_pcf_idxstack_indices,
 512                         rdrCtx.stats.stat_array_pcf_idxstack_indices)
 513                 : new IndexStack(rdrCtx);
 514         }
 515 
 516         PathClipFilter init(final PathConsumer2D out) {
 517             this.out = out;
 518 
 519             // Adjust the clipping rectangle with the renderer offsets
 520             final float rdrOffX = Renderer.RDR_OFFSET_X;
 521             final float rdrOffY = Renderer.RDR_OFFSET_Y;
 522 
 523             // add a small rounding error:
 524             final float margin = 1e-3f;
 525 
 526             final float[] _clipRect = this.clipRect;
 527             _clipRect[0] -= margin - rdrOffY;
 528             _clipRect[1] += margin + rdrOffY;
 529             _clipRect[2] -= margin - rdrOffX;
 530             _clipRect[3] += margin + rdrOffX;
 531 





 532             this.init_corners = true;
 533             this.gOutCode = MarlinConst.OUTCODE_MASK_T_B_L_R;
 534 
 535             return this; // fluent API
 536         }
 537 
 538         /**
 539          * Disposes this instance:
 540          * clean up before reusing this instance
 541          */
 542         void dispose() {
 543             stack.dispose();
 544         }
 545 
 546         private void finishPath() {
 547             if (outside) {
 548                 // criteria: inside or totally outside ?
 549                 if (gOutCode == 0) {
 550                     finish();
 551                 } else {

</pre><hr></hr><pre>
 562                 if (init_corners) {
 563                     init_corners = false;
 564 
 565                     final float[] _corners = corners;
 566                     final float[] _clipRect = clipRect;
 567                     // Top Left (0):
 568                     _corners[0] = _clipRect[2];
 569                     _corners[1] = _clipRect[0];
 570                     // Bottom Left (1):
 571                     _corners[2] = _clipRect[2];
 572                     _corners[3] = _clipRect[1];
 573                     // Top right (2):
 574                     _corners[4] = _clipRect[3];
 575                     _corners[5] = _clipRect[0];
 576                     // Bottom Right (3):
 577                     _corners[6] = _clipRect[3];
 578                     _corners[7] = _clipRect[1];
 579                 }
 580                 stack.pullAll(corners, out);
 581             }
<span class="changed"> 582             out.lineTo(cx0, cy0);</span>


 583         }
 584 
 585         @Override
 586         public void pathDone() {
 587             finishPath();
 588 
 589             out.pathDone();
 590 
 591             // TODO: fix possible leak if exception happened
 592             // Dispose this instance:
 593             dispose();
 594         }
 595 
 596         @Override
 597         public void closePath() {
 598             finishPath();
 599 
 600             out.closePath();
 601         }
 602 
 603         @Override
 604         public void moveTo(final float x0, final float y0) {
 605             finishPath();
 606 
<span class="changed"> 607             final int outcode = Helpers.outcode(x0, y0, clipRect);</span>
<span class="changed"> 608             this.cOutCode = outcode;</span>
 609             this.outside = false;
 610             out.moveTo(x0, y0);


 611         }
 612 
 613         @Override
 614         public void lineTo(final float xe, final float ye) {
 615             final int outcode0 = this.cOutCode;
 616             final int outcode1 = Helpers.outcode(xe, ye, clipRect);
<span class="removed"> 617             this.cOutCode = outcode1;</span>
 618 



 619             final int sideCode = (outcode0 &amp; outcode1);
 620 
 621             // basic rejection criteria:
 622             if (sideCode == 0) {
<span class="changed"> 623                 this.gOutCode = 0;</span>



















 624             } else {

 625                 this.gOutCode &amp;= sideCode;
 626                 // keep last point coordinate before entering the clip again:
 627                 this.outside = true;
<span class="changed"> 628                 this.cx0 = xe;</span>
<span class="changed"> 629                 this.cy0 = ye;</span>
 630 
 631                 clip(sideCode, outcode0, outcode1);
 632                 return;
 633             }





 634             if (outside) {
 635                 finish();
 636             }
 637             // clipping disabled:
 638             out.lineTo(xe, ye);


 639         }
 640 
 641         private void clip(final int sideCode,
 642                           final int outcode0,
 643                           final int outcode1)
 644         {
 645             // corner or cross-boundary on left or right side:
 646             if ((outcode0 != outcode1)
 647                     &amp;&amp; ((sideCode &amp; MarlinConst.OUTCODE_MASK_L_R) != 0))
 648             {
 649                 // combine outcodes:
 650                 final int mergeCode = (outcode0 | outcode1);
 651                 final int tbCode = mergeCode &amp; MarlinConst.OUTCODE_MASK_T_B;
 652                 final int lrCode = mergeCode &amp; MarlinConst.OUTCODE_MASK_L_R;
 653                 final int off = (lrCode == MarlinConst.OUTCODE_LEFT) ? 0 : 2;
 654 
 655                 // add corners to outside stack:
 656                 switch (tbCode) {
 657                     case MarlinConst.OUTCODE_TOP:
<span class="removed"> 658 // System.out.println("TOP "+ ((off == 0) ? "LEFT" : "RIGHT"));</span>
 659                         stack.push(off); // top
 660                         return;
 661                     case MarlinConst.OUTCODE_BOTTOM:
<span class="removed"> 662 // System.out.println("BOTTOM "+ ((off == 0) ? "LEFT" : "RIGHT"));</span>
 663                         stack.push(off + 1); // bottom
 664                         return;
 665                     default:
 666                         // both TOP / BOTTOM:
 667                         if ((outcode0 &amp; MarlinConst.OUTCODE_TOP) != 0) {
<span class="removed"> 668 // System.out.println("TOP + BOTTOM "+ ((off == 0) ? "LEFT" : "RIGHT"));</span>
 669                             // top to bottom
 670                             stack.push(off); // top
 671                             stack.push(off + 1); // bottom
 672                         } else {
<span class="removed"> 673 // System.out.println("BOTTOM + TOP "+ ((off == 0) ? "LEFT" : "RIGHT"));</span>
 674                             // bottom to top
 675                             stack.push(off + 1); // bottom
 676                             stack.push(off); // top
 677                         }
 678                 }
 679             }
 680         }
 681 
 682         @Override
 683         public void curveTo(final float x1, final float y1,
 684                             final float x2, final float y2,
 685                             final float xe, final float ye)
 686         {
 687             final int outcode0 = this.cOutCode;


 688             final int outcode3 = Helpers.outcode(xe, ye, clipRect);
<span class="removed"> 689             this.cOutCode = outcode3;</span>
 690 
<span class="changed"> 691             int sideCode = outcode0 &amp; outcode3;</span>



 692 

 693             if (sideCode == 0) {
<span class="changed"> 694                 this.gOutCode = 0;</span>





















 695             } else {
<span class="changed"> 696                 sideCode &amp;= Helpers.outcode(x1, y1, clipRect);</span>
<span class="changed"> 697                 sideCode &amp;= Helpers.outcode(x2, y2, clipRect);</span>
 698                 this.gOutCode &amp;= sideCode;
<span class="removed"> 699 </span>
<span class="removed"> 700                 // basic rejection criteria:</span>
<span class="removed"> 701                 if (sideCode != 0) {</span>
 702                     // keep last point coordinate before entering the clip again:
 703                     this.outside = true;
<span class="changed"> 704                     this.cx0 = xe;</span>
<span class="changed"> 705                     this.cy0 = ye;</span>
 706 
 707                     clip(sideCode, outcode0, outcode3);
 708                     return;
 709                 }
 710             }




 711             if (outside) {
 712                 finish();
 713             }
 714             // clipping disabled:
 715             out.curveTo(x1, y1, x2, y2, xe, ye);


 716         }
 717 
 718         @Override
 719         public void quadTo(final float x1, final float y1,
 720                            final float xe, final float ye)
 721         {
 722             final int outcode0 = this.cOutCode;

 723             final int outcode2 = Helpers.outcode(xe, ye, clipRect);
<span class="removed"> 724             this.cOutCode = outcode2;</span>
 725 
<span class="changed"> 726             int sideCode = outcode0 &amp; outcode2;</span>



 727 

 728             if (sideCode == 0) {
<span class="changed"> 729                 this.gOutCode = 0;</span>



















 730             } else {
<span class="changed"> 731                 sideCode &amp;= Helpers.outcode(x1, y1, clipRect);</span>
 732                 this.gOutCode &amp;= sideCode;
<span class="removed"> 733 </span>
<span class="removed"> 734                 // basic rejection criteria:</span>
<span class="removed"> 735                 if (sideCode != 0) {</span>
 736                     // keep last point coordinate before entering the clip again:
 737                     this.outside = true;
<span class="changed"> 738                     this.cx0 = xe;</span>
<span class="changed"> 739                     this.cy0 = ye;</span>
 740 
 741                     clip(sideCode, outcode0, outcode2);
 742                     return;
 743                 }
 744             }




 745             if (outside) {
 746                 finish();
 747             }
 748             // clipping disabled:
 749             out.quadTo(x1, y1, xe, ye);


 750         }
 751 
 752         @Override
 753         public long getNativeConsumer() {
 754             throw new InternalError("Not using a native peer");
 755         }
 756     }
 757 































































































































































































































































 758     static final class PathTracer implements PathConsumer2D {
 759         private final String prefix;
 760         private PathConsumer2D out;
 761 
 762         PathTracer(String name) {
 763             this.prefix = name + ": ";
 764         }
 765 
 766         PathTracer init(PathConsumer2D out) {
 767             this.out = out;
 768             return this; // fluent API
 769         }
 770 
 771         @Override
 772         public void moveTo(float x0, float y0) {
 773             log("moveTo (" + x0 + ", " + y0 + ')');
 774             out.moveTo(x0, y0);
 775         }
 776 
 777         @Override

</pre><hr></hr><pre>
 791 
 792         @Override
 793         public void quadTo(float x1, float y1, float x2, float y2) {
 794             log("quadTo P1(" + x1 + ", " + y1 + ") P2(" + x2 + ", " + y2  + ')');
 795             out.quadTo(x1, y1, x2, y2);
 796         }
 797 
 798         @Override
 799         public void closePath() {
 800             log("closePath");
 801             out.closePath();
 802         }
 803 
 804         @Override
 805         public void pathDone() {
 806             log("pathDone");
 807             out.pathDone();
 808         }
 809 
 810         private void log(final String message) {
<span class="changed"> 811             System.out.println(prefix + message);</span>
 812         }
 813 
 814         @Override
 815         public long getNativeConsumer() {
 816             throw new InternalError("Not using a native peer");
 817         }
 818     }
 819 }
</pre></td><td><pre>
   1 /*
<span class="changed">   2  * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the "Classpath" exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.java2d.marlin;
  27 
  28 import sun.awt.geom.PathConsumer2D;
  29 import java.awt.geom.AffineTransform;
  30 import java.awt.geom.Path2D;
<span class="new">  31 import java.util.Arrays;</span>
  32 import sun.java2d.marlin.Helpers.IndexStack;
  33 import sun.java2d.marlin.Helpers.PolyStack;
  34 
  35 final class TransformingPathConsumer2D {
  36 
<span class="new">  37     // higher uncertainty in float variant for huge shapes &gt; 10^7</span>
<span class="new">  38     static final float CLIP_RECT_PADDING = 1.0f;</span>
<span class="new">  39 </span>
  40     private final RendererContext rdrCtx;
  41 
  42     // recycled ClosedPathDetector instance from detectClosedPath()
  43     private final ClosedPathDetector   cpDetector;
  44 
  45     // recycled PathClipFilter instance from pathClipper()
  46     private final PathClipFilter       pathClipper;
  47 
  48     // recycled PathConsumer2D instance from wrapPath2D()
  49     private final Path2DWrapper        wp_Path2DWrapper        = new Path2DWrapper();
  50 
  51     // recycled PathConsumer2D instances from deltaTransformConsumer()
  52     private final DeltaScaleFilter     dt_DeltaScaleFilter     = new DeltaScaleFilter();
  53     private final DeltaTransformFilter dt_DeltaTransformFilter = new DeltaTransformFilter();
  54 
  55     // recycled PathConsumer2D instances from inverseDeltaTransformConsumer()
  56     private final DeltaScaleFilter     iv_DeltaScaleFilter     = new DeltaScaleFilter();
  57     private final DeltaTransformFilter iv_DeltaTransformFilter = new DeltaTransformFilter();
  58 
  59     // recycled PathTracer instances from tracer...() methods
  60     private final PathTracer tracerInput      = new PathTracer("[Input]");
  61     private final PathTracer tracerCPDetector = new PathTracer("ClosedPathDetector");
  62     private final PathTracer tracerFiller     = new PathTracer("Filler");
  63     private final PathTracer tracerStroker    = new PathTracer("Stroker");
<span class="new">  64     private final PathTracer tracerDasher     = new PathTracer("Dasher");</span>
  65 
  66     TransformingPathConsumer2D(final RendererContext rdrCtx) {
  67         // used by RendererContext
  68         this.rdrCtx = rdrCtx;
  69         this.cpDetector = new ClosedPathDetector(rdrCtx);
  70         this.pathClipper = new PathClipFilter(rdrCtx);
  71     }
  72 
  73     PathConsumer2D wrapPath2D(Path2D.Float p2d) {
  74         return wp_Path2DWrapper.init(p2d);
  75     }
  76 
  77     PathConsumer2D traceInput(PathConsumer2D out) {
  78         return tracerInput.init(out);
  79     }
  80 
  81     PathConsumer2D traceClosedPathDetector(PathConsumer2D out) {
  82         return tracerCPDetector.init(out);
  83     }
  84 
  85     PathConsumer2D traceFiller(PathConsumer2D out) {
  86         return tracerFiller.init(out);
  87     }
  88 
  89     PathConsumer2D traceStroker(PathConsumer2D out) {
  90         return tracerStroker.init(out);
  91     }
  92 
<span class="new">  93     PathConsumer2D traceDasher(PathConsumer2D out) {</span>
<span class="new">  94         return tracerDasher.init(out);</span>
<span class="new">  95     }</span>
<span class="new">  96 </span>
  97     PathConsumer2D detectClosedPath(PathConsumer2D out) {
  98         return cpDetector.init(out);
  99     }
 100 
 101     PathConsumer2D pathClipper(PathConsumer2D out) {
 102         return pathClipper.init(out);
 103     }
 104 
 105     PathConsumer2D deltaTransformConsumer(PathConsumer2D out,
 106                                           AffineTransform at)
 107     {
 108         if (at == null) {
 109             return out;
 110         }
 111         final float mxx = (float) at.getScaleX();
 112         final float mxy = (float) at.getShearX();
 113         final float myx = (float) at.getShearY();
 114         final float myy = (float) at.getScaleY();
 115 
 116         if (mxy == 0.0f &amp;&amp; myx == 0.0f) {

</pre><hr></hr><pre>
 492     static final class PathClipFilter implements PathConsumer2D {
 493 
 494         private PathConsumer2D out;
 495 
 496         // Bounds of the drawing region, at pixel precision.
 497         private final float[] clipRect;
 498 
 499         private final float[] corners = new float[8];
 500         private boolean init_corners = false;
 501 
 502         private final IndexStack stack;
 503 
 504         // the current outcode of the current sub path
 505         private int cOutCode = 0;
 506 
 507         // the cumulated (and) outcode of the complete path
 508         private int gOutCode = MarlinConst.OUTCODE_MASK_T_B_L_R;
 509 
 510         private boolean outside = false;
 511 
<span class="changed"> 512         // The current point (TODO stupid repeated info)</span>
 513         private float cx0, cy0;
 514 
<span class="new"> 515         // The current point OUTSIDE</span>
<span class="new"> 516         private float cox0, coy0;</span>
<span class="new"> 517 </span>
<span class="new"> 518         private boolean subdivide = MarlinConst.DO_CLIP_SUBDIVIDER;</span>
<span class="new"> 519         private final CurveClipSplitter curveSplitter;</span>
<span class="new"> 520 </span>
 521         PathClipFilter(final RendererContext rdrCtx) {
 522             this.clipRect = rdrCtx.clipRect;
<span class="new"> 523             this.curveSplitter = rdrCtx.curveClipSplitter;</span>
<span class="new"> 524 </span>
 525             this.stack = (rdrCtx.stats != null) ?
 526                 new IndexStack(rdrCtx,
 527                         rdrCtx.stats.stat_pcf_idxstack_indices,
 528                         rdrCtx.stats.hist_pcf_idxstack_indices,
 529                         rdrCtx.stats.stat_array_pcf_idxstack_indices)
 530                 : new IndexStack(rdrCtx);
 531         }
 532 
 533         PathClipFilter init(final PathConsumer2D out) {
 534             this.out = out;
 535 
 536             // Adjust the clipping rectangle with the renderer offsets
 537             final float rdrOffX = Renderer.RDR_OFFSET_X;
 538             final float rdrOffY = Renderer.RDR_OFFSET_Y;
 539 
 540             // add a small rounding error:
 541             final float margin = 1e-3f;
 542 
 543             final float[] _clipRect = this.clipRect;
 544             _clipRect[0] -= margin - rdrOffY;
 545             _clipRect[1] += margin + rdrOffY;
 546             _clipRect[2] -= margin - rdrOffX;
 547             _clipRect[3] += margin + rdrOffX;
 548 
<span class="new"> 549             if (MarlinConst.DO_CLIP_SUBDIVIDER) {</span>
<span class="new"> 550                 // adjust padded clip rectangle:</span>
<span class="new"> 551                 curveSplitter.init();</span>
<span class="new"> 552             }</span>
<span class="new"> 553 </span>
 554             this.init_corners = true;
 555             this.gOutCode = MarlinConst.OUTCODE_MASK_T_B_L_R;
 556 
 557             return this; // fluent API
 558         }
 559 
 560         /**
 561          * Disposes this instance:
 562          * clean up before reusing this instance
 563          */
 564         void dispose() {
 565             stack.dispose();
 566         }
 567 
 568         private void finishPath() {
 569             if (outside) {
 570                 // criteria: inside or totally outside ?
 571                 if (gOutCode == 0) {
 572                     finish();
 573                 } else {

</pre><hr></hr><pre>
 584                 if (init_corners) {
 585                     init_corners = false;
 586 
 587                     final float[] _corners = corners;
 588                     final float[] _clipRect = clipRect;
 589                     // Top Left (0):
 590                     _corners[0] = _clipRect[2];
 591                     _corners[1] = _clipRect[0];
 592                     // Bottom Left (1):
 593                     _corners[2] = _clipRect[2];
 594                     _corners[3] = _clipRect[1];
 595                     // Top right (2):
 596                     _corners[4] = _clipRect[3];
 597                     _corners[5] = _clipRect[0];
 598                     // Bottom Right (3):
 599                     _corners[6] = _clipRect[3];
 600                     _corners[7] = _clipRect[1];
 601                 }
 602                 stack.pullAll(corners, out);
 603             }
<span class="changed"> 604             out.lineTo(cox0, coy0);</span>
<span class="changed"> 605             this.cx0 = cox0;</span>
<span class="changed"> 606             this.cy0 = coy0;</span>
 607         }
 608 
 609         @Override
 610         public void pathDone() {
 611             finishPath();
 612 
 613             out.pathDone();
 614 
 615             // TODO: fix possible leak if exception happened
 616             // Dispose this instance:
 617             dispose();
 618         }
 619 
 620         @Override
 621         public void closePath() {
 622             finishPath();
 623 
 624             out.closePath();
 625         }
 626 
 627         @Override
 628         public void moveTo(final float x0, final float y0) {
 629             finishPath();
 630 
<span class="changed"> 631             this.cOutCode = Helpers.outcode(x0, y0, clipRect);</span>

 632             this.outside = false;
 633             out.moveTo(x0, y0);
<span class="new"> 634             this.cx0 = x0;</span>
<span class="new"> 635             this.cy0 = y0;</span>
 636         }
 637 
 638         @Override
 639         public void lineTo(final float xe, final float ye) {
 640             final int outcode0 = this.cOutCode;
 641             final int outcode1 = Helpers.outcode(xe, ye, clipRect);

 642 
<span class="new"> 643             // Should clip</span>
<span class="new"> 644             final int orCode = (outcode0 | outcode1);</span>
<span class="new"> 645             if (orCode != 0) {</span>
 646                 final int sideCode = (outcode0 &amp; outcode1);
 647 
 648                 // basic rejection criteria:
 649                 if (sideCode == 0) {
<span class="changed"> 650                     // ovelap clip:</span>
<span class="changed"> 651                     if (subdivide) {</span>
<span class="changed"> 652                         // avoid reentrance</span>
<span class="changed"> 653                         subdivide = false;</span>
<span class="changed"> 654                         boolean ret;</span>
<span class="changed"> 655                         // subdivide curve =&gt; callback with subdivided parts:</span>
<span class="changed"> 656                         if (outside) {</span>
<span class="changed"> 657                             ret = curveSplitter.splitLine(cox0, coy0, xe, ye,</span>
<span class="changed"> 658                                                           orCode, this);</span>
<span class="changed"> 659                         } else {</span>
<span class="changed"> 660                             ret = curveSplitter.splitLine(cx0, cy0, xe, ye,</span>
<span class="changed"> 661                                                           orCode, this);</span>
<span class="changed"> 662                         }</span>
<span class="changed"> 663                         // reentrance is done:</span>
<span class="changed"> 664                         subdivide = true;</span>
<span class="changed"> 665                         if (ret) {</span>
<span class="changed"> 666                             return;</span>
<span class="changed"> 667                         }</span>
<span class="changed"> 668                     }</span>
<span class="changed"> 669                     // already subdivided so render it</span>
 670                 } else {
<span class="new"> 671                     this.cOutCode = outcode1;</span>
 672                     this.gOutCode &amp;= sideCode;
 673                     // keep last point coordinate before entering the clip again:
 674                     this.outside = true;
<span class="changed"> 675                     this.cox0 = xe;</span>
<span class="changed"> 676                     this.coy0 = ye;</span>
 677 
 678                     clip(sideCode, outcode0, outcode1);
 679                     return;
 680                 }
<span class="new"> 681             }</span>
<span class="new"> 682 </span>
<span class="new"> 683             this.cOutCode = outcode1;</span>
<span class="new"> 684             this.gOutCode = 0;</span>
<span class="new"> 685 </span>
 686             if (outside) {
 687                 finish();
 688             }
 689             // clipping disabled:
 690             out.lineTo(xe, ye);
<span class="new"> 691             this.cx0 = xe;</span>
<span class="new"> 692             this.cy0 = ye;</span>
 693         }
 694 
 695         private void clip(final int sideCode,
 696                           final int outcode0,
 697                           final int outcode1)
 698         {
 699             // corner or cross-boundary on left or right side:
 700             if ((outcode0 != outcode1)
 701                     &amp;&amp; ((sideCode &amp; MarlinConst.OUTCODE_MASK_L_R) != 0))
 702             {
 703                 // combine outcodes:
 704                 final int mergeCode = (outcode0 | outcode1);
 705                 final int tbCode = mergeCode &amp; MarlinConst.OUTCODE_MASK_T_B;
 706                 final int lrCode = mergeCode &amp; MarlinConst.OUTCODE_MASK_L_R;
 707                 final int off = (lrCode == MarlinConst.OUTCODE_LEFT) ? 0 : 2;
 708 
 709                 // add corners to outside stack:
 710                 switch (tbCode) {
 711                     case MarlinConst.OUTCODE_TOP:

 712                         stack.push(off); // top
 713                         return;
 714                     case MarlinConst.OUTCODE_BOTTOM:

 715                         stack.push(off + 1); // bottom
 716                         return;
 717                     default:
 718                         // both TOP / BOTTOM:
 719                         if ((outcode0 &amp; MarlinConst.OUTCODE_TOP) != 0) {

 720                             // top to bottom
 721                             stack.push(off); // top
 722                             stack.push(off + 1); // bottom
 723                         } else {

 724                             // bottom to top
 725                             stack.push(off + 1); // bottom
 726                             stack.push(off); // top
 727                         }
 728                 }
 729             }
 730         }
 731 
 732         @Override
 733         public void curveTo(final float x1, final float y1,
 734                             final float x2, final float y2,
 735                             final float xe, final float ye)
 736         {
 737             final int outcode0 = this.cOutCode;
<span class="new"> 738             final int outcode1 = Helpers.outcode(x1, y1, clipRect);</span>
<span class="new"> 739             final int outcode2 = Helpers.outcode(x2, y2, clipRect);</span>
 740             final int outcode3 = Helpers.outcode(xe, ye, clipRect);

 741 
<span class="changed"> 742             // Should clip</span>
<span class="changed"> 743             final int orCode = (outcode0 | outcode1 | outcode2 | outcode3);</span>
<span class="changed"> 744             if (orCode != 0) {</span>
<span class="changed"> 745                 final int sideCode = outcode0 &amp; outcode1 &amp; outcode2 &amp; outcode3;</span>
 746 
<span class="new"> 747                 // basic rejection criteria:</span>
 748                 if (sideCode == 0) {
<span class="changed"> 749                     // ovelap clip:</span>
<span class="changed"> 750                     if (subdivide) {</span>
<span class="changed"> 751                         // avoid reentrance</span>
<span class="changed"> 752                         subdivide = false;</span>
<span class="changed"> 753                         // subdivide curve =&gt; callback with subdivided parts:</span>
<span class="changed"> 754                         boolean ret;</span>
<span class="changed"> 755                         if (outside) {</span>
<span class="changed"> 756                             ret = curveSplitter.splitCurve(cox0, coy0, x1, y1,</span>
<span class="changed"> 757                                                            x2, y2, xe, ye,</span>
<span class="changed"> 758                                                            orCode, this);</span>
<span class="changed"> 759                         } else {</span>
<span class="changed"> 760                             ret = curveSplitter.splitCurve(cx0, cy0, x1, y1,</span>
<span class="changed"> 761                                                            x2, y2, xe, ye,</span>
<span class="changed"> 762                                                            orCode, this);</span>
<span class="changed"> 763                         }</span>
<span class="changed"> 764                         // reentrance is done:</span>
<span class="changed"> 765                         subdivide = true;</span>
<span class="changed"> 766                         if (ret) {</span>
<span class="changed"> 767                             return;</span>
<span class="changed"> 768                         }</span>
<span class="changed"> 769                     }</span>
<span class="changed"> 770                     // already subdivided so render it</span>
 771                 } else {
<span class="changed"> 772                     this.cOutCode = outcode3;</span>

 773                     this.gOutCode &amp;= sideCode;



 774                     // keep last point coordinate before entering the clip again:
 775                     this.outside = true;
<span class="changed"> 776                     this.cox0 = xe;</span>
<span class="changed"> 777                     this.coy0 = ye;</span>
 778 
 779                     clip(sideCode, outcode0, outcode3);
 780                     return;
 781                 }
 782             }
<span class="new"> 783 </span>
<span class="new"> 784             this.cOutCode = outcode3;</span>
<span class="new"> 785             this.gOutCode = 0;</span>
<span class="new"> 786 </span>
 787             if (outside) {
 788                 finish();
 789             }
 790             // clipping disabled:
 791             out.curveTo(x1, y1, x2, y2, xe, ye);
<span class="new"> 792             this.cx0 = xe;</span>
<span class="new"> 793             this.cy0 = ye;</span>
 794         }
 795 
 796         @Override
 797         public void quadTo(final float x1, final float y1,
 798                            final float xe, final float ye)
 799         {
 800             final int outcode0 = this.cOutCode;
<span class="new"> 801             final int outcode1 = Helpers.outcode(x1, y1, clipRect);</span>
 802             final int outcode2 = Helpers.outcode(xe, ye, clipRect);

 803 
<span class="changed"> 804             // Should clip</span>
<span class="changed"> 805             final int orCode = (outcode0 | outcode1 | outcode2);</span>
<span class="changed"> 806             if (orCode != 0) {</span>
<span class="changed"> 807                 final int sideCode = outcode0 &amp; outcode1 &amp; outcode2;</span>
 808 
<span class="new"> 809                 // basic rejection criteria:</span>
 810                 if (sideCode == 0) {
<span class="changed"> 811                     // ovelap clip:</span>
<span class="changed"> 812                     if (subdivide) {</span>
<span class="changed"> 813                         // avoid reentrance</span>
<span class="changed"> 814                         subdivide = false;</span>
<span class="changed"> 815                         // subdivide curve =&gt; callback with subdivided parts:</span>
<span class="changed"> 816                         boolean ret;</span>
<span class="changed"> 817                         if (outside) {</span>
<span class="changed"> 818                             ret = curveSplitter.splitQuad(cox0, coy0, x1, y1,</span>
<span class="changed"> 819                                                           xe, ye, orCode, this);</span>
<span class="changed"> 820                         } else {</span>
<span class="changed"> 821                             ret = curveSplitter.splitQuad(cx0, cy0, x1, y1,</span>
<span class="changed"> 822                                                           xe, ye, orCode, this);</span>
<span class="changed"> 823                         }</span>
<span class="changed"> 824                         // reentrance is done:</span>
<span class="changed"> 825                         subdivide = true;</span>
<span class="changed"> 826                         if (ret) {</span>
<span class="changed"> 827                             return;</span>
<span class="changed"> 828                         }</span>
<span class="changed"> 829                     }</span>
<span class="changed"> 830                     // already subdivided so render it</span>
 831                 } else {
<span class="changed"> 832                     this.cOutCode = outcode2;</span>
 833                     this.gOutCode &amp;= sideCode;



 834                     // keep last point coordinate before entering the clip again:
 835                     this.outside = true;
<span class="changed"> 836                     this.cox0 = xe;</span>
<span class="changed"> 837                     this.coy0 = ye;</span>
 838 
 839                     clip(sideCode, outcode0, outcode2);
 840                     return;
 841                 }
 842             }
<span class="new"> 843 </span>
<span class="new"> 844             this.cOutCode = outcode2;</span>
<span class="new"> 845             this.gOutCode = 0;</span>
<span class="new"> 846 </span>
 847             if (outside) {
 848                 finish();
 849             }
 850             // clipping disabled:
 851             out.quadTo(x1, y1, xe, ye);
<span class="new"> 852             this.cx0 = xe;</span>
<span class="new"> 853             this.cy0 = ye;</span>
 854         }
 855 
 856         @Override
 857         public long getNativeConsumer() {
 858             throw new InternalError("Not using a native peer");
 859         }
 860     }
 861 
<span class="new"> 862     static final class CurveClipSplitter {</span>
<span class="new"> 863 </span>
<span class="new"> 864         static final float LEN_TH = MarlinProperties.getSubdividerMinLength();</span>
<span class="new"> 865         static final boolean DO_CHECK_LENGTH = (LEN_TH &gt; 0.0f);</span>
<span class="new"> 866 </span>
<span class="new"> 867         private static final boolean TRACE = false;</span>
<span class="new"> 868 </span>
<span class="new"> 869         private static final int MAX_N_CURVES = 3 * 4;</span>
<span class="new"> 870 </span>
<span class="new"> 871         // clip rectangle (ymin, ymax, xmin, xmax):</span>
<span class="new"> 872         final float[] clipRect;</span>
<span class="new"> 873 </span>
<span class="new"> 874         // clip rectangle (ymin, ymax, xmin, xmax) including padding:</span>
<span class="new"> 875         final float[] clipRectPad = new float[4];</span>
<span class="new"> 876         private boolean init_clipRectPad = false;</span>
<span class="new"> 877 </span>
<span class="new"> 878         // This is where the curve to be processed is put. We give it</span>
<span class="new"> 879         // enough room to store all curves.</span>
<span class="new"> 880         final float[] middle = new float[MAX_N_CURVES * 8 + 2];</span>
<span class="new"> 881         // t values at subdivision points</span>
<span class="new"> 882         private final float[] subdivTs = new float[MAX_N_CURVES];</span>
<span class="new"> 883 </span>
<span class="new"> 884         // dirty curve</span>
<span class="new"> 885         private final Curve curve;</span>
<span class="new"> 886 </span>
<span class="new"> 887         CurveClipSplitter(final RendererContext rdrCtx) {</span>
<span class="new"> 888             this.clipRect = rdrCtx.clipRect;</span>
<span class="new"> 889             this.curve = rdrCtx.curve;</span>
<span class="new"> 890         }</span>
<span class="new"> 891 </span>
<span class="new"> 892         void init() {</span>
<span class="new"> 893             this.init_clipRectPad = true;</span>
<span class="new"> 894         }</span>
<span class="new"> 895 </span>
<span class="new"> 896         private void initPaddedClip() {</span>
<span class="new"> 897             // bounds as half-open intervals: minX &lt;= x &lt; maxX and minY &lt;= y &lt; maxY</span>
<span class="new"> 898             // adjust padded clip rectangle (ymin, ymax, xmin, xmax):</span>
<span class="new"> 899             // add a rounding error (curve subdivision ~ 0.1px):</span>
<span class="new"> 900             final float[] _clipRect = clipRect;</span>
<span class="new"> 901             final float[] _clipRectPad = clipRectPad;</span>
<span class="new"> 902 </span>
<span class="new"> 903             _clipRectPad[0] = _clipRect[0] - CLIP_RECT_PADDING;</span>
<span class="new"> 904             _clipRectPad[1] = _clipRect[1] + CLIP_RECT_PADDING;</span>
<span class="new"> 905             _clipRectPad[2] = _clipRect[2] - CLIP_RECT_PADDING;</span>
<span class="new"> 906             _clipRectPad[3] = _clipRect[3] + CLIP_RECT_PADDING;</span>
<span class="new"> 907 </span>
<span class="new"> 908             if (TRACE) {</span>
<span class="new"> 909                 MarlinUtils.logInfo("clip: X [" + _clipRectPad[2] + " .. " + _clipRectPad[3] +"] "</span>
<span class="new"> 910                                         + "Y ["+ _clipRectPad[0] + " .. " + _clipRectPad[1] +"]");</span>
<span class="new"> 911             }</span>
<span class="new"> 912         }</span>
<span class="new"> 913 </span>
<span class="new"> 914         boolean splitLine(final float x0, final float y0,</span>
<span class="new"> 915                           final float x1, final float y1,</span>
<span class="new"> 916                           final int outCodeOR,</span>
<span class="new"> 917                           final PathConsumer2D out)</span>
<span class="new"> 918         {</span>
<span class="new"> 919             if (TRACE) {</span>
<span class="new"> 920                 MarlinUtils.logInfo("divLine P0(" + x0 + ", " + y0 + ") P1(" + x1 + ", " + y1 + ")");</span>
<span class="new"> 921             }</span>
<span class="new"> 922 </span>
<span class="new"> 923             if (DO_CHECK_LENGTH &amp;&amp; Helpers.fastLineLen(x0, y0, x1, y1) &lt;= LEN_TH) {</span>
<span class="new"> 924                 return false;</span>
<span class="new"> 925             }</span>
<span class="new"> 926 </span>
<span class="new"> 927             final float[] mid = middle;</span>
<span class="new"> 928             mid[0] = x0;  mid[1] = y0;</span>
<span class="new"> 929             mid[2] = x1;  mid[3] = y1;</span>
<span class="new"> 930 </span>
<span class="new"> 931             return subdivideAtIntersections(4, outCodeOR, out);</span>
<span class="new"> 932         }</span>
<span class="new"> 933 </span>
<span class="new"> 934         boolean splitQuad(final float x0, final float y0,</span>
<span class="new"> 935                           final float x1, final float y1,</span>
<span class="new"> 936                           final float x2, final float y2,</span>
<span class="new"> 937                           final int outCodeOR,</span>
<span class="new"> 938                           final PathConsumer2D out)</span>
<span class="new"> 939         {</span>
<span class="new"> 940             if (TRACE) {</span>
<span class="new"> 941                 MarlinUtils.logInfo("divQuad P0(" + x0 + ", " + y0 + ") P1(" + x1 + ", " + y1 + ") P2(" + x2 + ", " + y2 + ")");</span>
<span class="new"> 942             }</span>
<span class="new"> 943 </span>
<span class="new"> 944             if (DO_CHECK_LENGTH &amp;&amp; Helpers.fastQuadLen(x0, y0, x1, y1, x2, y2) &lt;= LEN_TH) {</span>
<span class="new"> 945                 return false;</span>
<span class="new"> 946             }</span>
<span class="new"> 947 </span>
<span class="new"> 948             final float[] mid = middle;</span>
<span class="new"> 949             mid[0] = x0;  mid[1] = y0;</span>
<span class="new"> 950             mid[2] = x1;  mid[3] = y1;</span>
<span class="new"> 951             mid[4] = x2;  mid[5] = y2;</span>
<span class="new"> 952 </span>
<span class="new"> 953             return subdivideAtIntersections(6, outCodeOR, out);</span>
<span class="new"> 954         }</span>
<span class="new"> 955 </span>
<span class="new"> 956         boolean splitCurve(final float x0, final float y0,</span>
<span class="new"> 957                            final float x1, final float y1,</span>
<span class="new"> 958                            final float x2, final float y2,</span>
<span class="new"> 959                            final float x3, final float y3,</span>
<span class="new"> 960                            final int outCodeOR,</span>
<span class="new"> 961                            final PathConsumer2D out)</span>
<span class="new"> 962         {</span>
<span class="new"> 963             if (TRACE) {</span>
<span class="new"> 964                 MarlinUtils.logInfo("divCurve P0(" + x0 + ", " + y0 + ") P1(" + x1 + ", " + y1 + ") P2(" + x2 + ", " + y2 + ") P3(" + x3 + ", " + y3 + ")");</span>
<span class="new"> 965             }</span>
<span class="new"> 966 </span>
<span class="new"> 967             if (DO_CHECK_LENGTH &amp;&amp; Helpers.fastCurvelen(x0, y0, x1, y1, x2, y2, x3, y3) &lt;= LEN_TH) {</span>
<span class="new"> 968                 return false;</span>
<span class="new"> 969             }</span>
<span class="new"> 970 </span>
<span class="new"> 971             final float[] mid = middle;</span>
<span class="new"> 972             mid[0] = x0;  mid[1] = y0;</span>
<span class="new"> 973             mid[2] = x1;  mid[3] = y1;</span>
<span class="new"> 974             mid[4] = x2;  mid[5] = y2;</span>
<span class="new"> 975             mid[6] = x3;  mid[7] = y3;</span>
<span class="new"> 976 </span>
<span class="new"> 977             return subdivideAtIntersections(8, outCodeOR, out);</span>
<span class="new"> 978         }</span>
<span class="new"> 979 </span>
<span class="new"> 980         private boolean subdivideAtIntersections(final int type, final int outCodeOR,</span>
<span class="new"> 981                                                  final PathConsumer2D out)</span>
<span class="new"> 982         {</span>
<span class="new"> 983             final float[] mid = middle;</span>
<span class="new"> 984             final float[] subTs = subdivTs;</span>
<span class="new"> 985 </span>
<span class="new"> 986             if (init_clipRectPad) {</span>
<span class="new"> 987                 init_clipRectPad = false;</span>
<span class="new"> 988                 initPaddedClip();</span>
<span class="new"> 989             }</span>
<span class="new"> 990 </span>
<span class="new"> 991             final int nSplits = Helpers.findClipPoints(curve, mid, subTs, type,</span>
<span class="new"> 992                                                         outCodeOR, clipRectPad);</span>
<span class="new"> 993 </span>
<span class="new"> 994             if (TRACE) {</span>
<span class="new"> 995                 MarlinUtils.logInfo("nSplits: "+ nSplits);</span>
<span class="new"> 996                 MarlinUtils.logInfo("subTs: "+Arrays.toString(Arrays.copyOfRange(subTs, 0, nSplits)));</span>
<span class="new"> 997             }</span>
<span class="new"> 998             if (nSplits == 0) {</span>
<span class="new"> 999                 // only curve support shortcut</span>
<span class="new">1000                 return false;</span>
<span class="new">1001             }</span>
<span class="new">1002             float prevT = 0.0f;</span>
<span class="new">1003 </span>
<span class="new">1004             for (int i = 0, off = 0; i &lt; nSplits; i++, off += type) {</span>
<span class="new">1005                 final float t = subTs[i];</span>
<span class="new">1006 </span>
<span class="new">1007                 Helpers.subdivideAt((t - prevT) / (1.0f - prevT),</span>
<span class="new">1008                                      mid, off, mid, off, type);</span>
<span class="new">1009                 prevT = t;</span>
<span class="new">1010             }</span>
<span class="new">1011 </span>
<span class="new">1012             for (int i = 0, off = 0; i &lt;= nSplits; i++, off += type) {</span>
<span class="new">1013                 if (TRACE) {</span>
<span class="new">1014                     MarlinUtils.logInfo("Part Curve "+Arrays.toString(Arrays.copyOfRange(mid, off, off + type)));</span>
<span class="new">1015                 }</span>
<span class="new">1016                 emitCurrent(type, mid, off, out);</span>
<span class="new">1017             }</span>
<span class="new">1018             return true;</span>
<span class="new">1019         }</span>
<span class="new">1020 </span>
<span class="new">1021         static void emitCurrent(final int type, final float[] pts,</span>
<span class="new">1022                                 final int off, final PathConsumer2D out)</span>
<span class="new">1023         {</span>
<span class="new">1024             // if instead of switch (perf + most probable cases first)</span>
<span class="new">1025             if (type == 8) {</span>
<span class="new">1026                 out.curveTo(pts[off + 2], pts[off + 3],</span>
<span class="new">1027                             pts[off + 4], pts[off + 5],</span>
<span class="new">1028                             pts[off + 6], pts[off + 7]);</span>
<span class="new">1029             } else if (type == 4) {</span>
<span class="new">1030                 out.lineTo(pts[off + 2], pts[off + 3]);</span>
<span class="new">1031             } else {</span>
<span class="new">1032                 out.quadTo(pts[off + 2], pts[off + 3],</span>
<span class="new">1033                            pts[off + 4], pts[off + 5]);</span>
<span class="new">1034             }</span>
<span class="new">1035         }</span>
<span class="new">1036     }</span>
<span class="new">1037 </span>
<span class="new">1038     static final class CurveBasicMonotonizer {</span>
<span class="new">1039 </span>
<span class="new">1040         private static final int MAX_N_CURVES = 11;</span>
<span class="new">1041 </span>
<span class="new">1042         // squared half line width (for stroker)</span>
<span class="new">1043         private float lw2;</span>
<span class="new">1044 </span>
<span class="new">1045         // number of splitted curves</span>
<span class="new">1046         int nbSplits;</span>
<span class="new">1047 </span>
<span class="new">1048         // This is where the curve to be processed is put. We give it</span>
<span class="new">1049         // enough room to store all curves.</span>
<span class="new">1050         final float[] middle = new float[MAX_N_CURVES * 6 + 2];</span>
<span class="new">1051         // t values at subdivision points</span>
<span class="new">1052         private final float[] subdivTs = new float[MAX_N_CURVES - 1];</span>
<span class="new">1053 </span>
<span class="new">1054         // dirty curve</span>
<span class="new">1055         private final Curve curve;</span>
<span class="new">1056 </span>
<span class="new">1057         CurveBasicMonotonizer(final RendererContext rdrCtx) {</span>
<span class="new">1058             this.curve = rdrCtx.curve;</span>
<span class="new">1059         }</span>
<span class="new">1060 </span>
<span class="new">1061         void init(final float lineWidth) {</span>
<span class="new">1062             this.lw2 = (lineWidth * lineWidth) / 4.0f;</span>
<span class="new">1063         }</span>
<span class="new">1064 </span>
<span class="new">1065         CurveBasicMonotonizer curve(final float x0, final float y0,</span>
<span class="new">1066                                     final float x1, final float y1,</span>
<span class="new">1067                                     final float x2, final float y2,</span>
<span class="new">1068                                     final float x3, final float y3)</span>
<span class="new">1069         {</span>
<span class="new">1070             final float[] mid = middle;</span>
<span class="new">1071             mid[0] = x0;  mid[1] = y0;</span>
<span class="new">1072             mid[2] = x1;  mid[3] = y1;</span>
<span class="new">1073             mid[4] = x2;  mid[5] = y2;</span>
<span class="new">1074             mid[6] = x3;  mid[7] = y3;</span>
<span class="new">1075 </span>
<span class="new">1076             final float[] subTs = subdivTs;</span>
<span class="new">1077             final int nSplits = Helpers.findSubdivPoints(curve, mid, subTs, 8, lw2);</span>
<span class="new">1078 </span>
<span class="new">1079             float prevT = 0.0f;</span>
<span class="new">1080             for (int i = 0, off = 0; i &lt; nSplits; i++, off += 6) {</span>
<span class="new">1081                 final float t = subTs[i];</span>
<span class="new">1082 </span>
<span class="new">1083                 Helpers.subdivideCubicAt((t - prevT) / (1.0f - prevT),</span>
<span class="new">1084                                           mid, off, mid, off, off + 6);</span>
<span class="new">1085                 prevT = t;</span>
<span class="new">1086             }</span>
<span class="new">1087 </span>
<span class="new">1088             this.nbSplits = nSplits;</span>
<span class="new">1089             return this;</span>
<span class="new">1090         }</span>
<span class="new">1091 </span>
<span class="new">1092         CurveBasicMonotonizer quad(final float x0, final float y0,</span>
<span class="new">1093                                    final float x1, final float y1,</span>
<span class="new">1094                                    final float x2, final float y2)</span>
<span class="new">1095         {</span>
<span class="new">1096             final float[] mid = middle;</span>
<span class="new">1097             mid[0] = x0;  mid[1] = y0;</span>
<span class="new">1098             mid[2] = x1;  mid[3] = y1;</span>
<span class="new">1099             mid[4] = x2;  mid[5] = y2;</span>
<span class="new">1100 </span>
<span class="new">1101             final float[] subTs = subdivTs;</span>
<span class="new">1102             final int nSplits = Helpers.findSubdivPoints(curve, mid, subTs, 6, lw2);</span>
<span class="new">1103 </span>
<span class="new">1104             float prevt = 0.0f;</span>
<span class="new">1105             for (int i = 0, off = 0; i &lt; nSplits; i++, off += 4) {</span>
<span class="new">1106                 final float t = subTs[i];</span>
<span class="new">1107                 Helpers.subdivideQuadAt((t - prevt) / (1.0f - prevt),</span>
<span class="new">1108                                          mid, off, mid, off, off + 4);</span>
<span class="new">1109                 prevt = t;</span>
<span class="new">1110             }</span>
<span class="new">1111 </span>
<span class="new">1112             this.nbSplits = nSplits;</span>
<span class="new">1113             return this;</span>
<span class="new">1114         }</span>
<span class="new">1115     }</span>
<span class="new">1116 </span>
1117     static final class PathTracer implements PathConsumer2D {
1118         private final String prefix;
1119         private PathConsumer2D out;
1120 
1121         PathTracer(String name) {
1122             this.prefix = name + ": ";
1123         }
1124 
1125         PathTracer init(PathConsumer2D out) {
1126             this.out = out;
1127             return this; // fluent API
1128         }
1129 
1130         @Override
1131         public void moveTo(float x0, float y0) {
1132             log("moveTo (" + x0 + ", " + y0 + ')');
1133             out.moveTo(x0, y0);
1134         }
1135 
1136         @Override

</pre><hr></hr><pre>
1150 
1151         @Override
1152         public void quadTo(float x1, float y1, float x2, float y2) {
1153             log("quadTo P1(" + x1 + ", " + y1 + ") P2(" + x2 + ", " + y2  + ')');
1154             out.quadTo(x1, y1, x2, y2);
1155         }
1156 
1157         @Override
1158         public void closePath() {
1159             log("closePath");
1160             out.closePath();
1161         }
1162 
1163         @Override
1164         public void pathDone() {
1165             log("pathDone");
1166             out.pathDone();
1167         }
1168 
1169         private void log(final String message) {
<span class="changed">1170             MarlinUtils.logInfo(prefix + message);</span>
1171         }
1172 
1173         @Override
1174         public long getNativeConsumer() {
1175             throw new InternalError("Not using a native peer");
1176         }
1177     }
1178 }
</pre></td>
</tr></table>
<center><a href='../../../../../../src/share/classes/sun/java2d/marlin/Stroker.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../src/share/classes/sun/java2d/marlin/Version.java.sdiff.html' target='_top'>next &gt</a></center>
</body></html>
