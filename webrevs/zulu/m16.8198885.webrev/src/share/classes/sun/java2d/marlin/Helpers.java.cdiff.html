<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>jdk Cdiff src/share/classes/sun/java2d/marlin/Helpers.java</title>
</head>
<body id="SUNWwebrev">
<center><a href='../../../../../../src/share/classes/sun/java2d/marlin/FloatArrayCache.java.cdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../src/share/classes/sun/java2d/marlin/IntArrayCache.java.cdiff.html' target='_top'>next &gt</a></center>
<h2>src/share/classes/sun/java2d/marlin/Helpers.java</h2>
        <a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-13695">13695</a> : <a href="https://bugs.openjdk.java.net/browse/JDK-8198885">8198885</a>: upgrade Marlin (java2d) to 0.9.1
Summary: clipping implemented in Dasher (curve subdivision at clip edges) + higher quality(curve, subpixels) + new path simplifier
Reviewed-by: prr, serb</pre>
        <pre>
<hr /><span class="oldmarker">*** 1,7 ****</span>
  /*
<span class="changed">!  * Copyright (c) 2007, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="newmarker">--- 1,7 ----</span>
  /*
<span class="changed">!  * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<hr /><span class="oldmarker">*** 23,33 ****</span>
   * questions.
   */
  
  package sun.java2d.marlin;
  
<span class="removed">- import static java.lang.Math.PI;</span>
  import java.util.Arrays;
  import sun.awt.geom.PathConsumer2D;
  import sun.java2d.marlin.stats.Histogram;
  import sun.java2d.marlin.stats.StatLong;
  
<span class="newmarker">--- 23,32 ----</span>
<hr /><span class="oldmarker">*** 45,61 ****</span>
      static boolean within(final double x, final double y, final double err) {
          final double d = y - x;
          return (d &lt;= err &amp;&amp; d &gt;= -err);
      }
  
<span class="changed">!     static int quadraticRoots(final float a, final float b,</span>
<span class="changed">!                               final float c, float[] zeroes, final int off)</span>
      {
          int ret = off;
<span class="removed">-         float t;</span>
          if (a != 0.0f) {
<span class="changed">!             final float dis = b*b - 4*a*c;</span>
              if (dis &gt; 0.0f) {
                  final float sqrtDis = (float) Math.sqrt(dis);
                  // depending on the sign of b we use a slightly different
                  // algorithm than the traditional one to find one of the roots
                  // so we can avoid adding numbers of different signs (which
<span class="newmarker">--- 44,72 ----</span>
      static boolean within(final double x, final double y, final double err) {
          final double d = y - x;
          return (d &lt;= err &amp;&amp; d &gt;= -err);
      }
  
<span class="changed">!     static float evalCubic(final float a, final float b,</span>
<span class="changed">!                            final float c, final float d,</span>
<span class="changed">!                            final float t)</span>
<span class="changed">!     {</span>
<span class="changed">!         return t * (t * (t * a + b) + c) + d;</span>
<span class="changed">!     }</span>
<span class="changed">! </span>
<span class="changed">!     static float evalQuad(final float a, final float b,</span>
<span class="changed">!                           final float c, final float t)</span>
<span class="changed">!     {</span>
<span class="changed">!         return t * (t * a + b) + c;</span>
<span class="changed">!     }</span>
<span class="changed">! </span>
<span class="changed">!     static int quadraticRoots(final float a, final float b, final float c,</span>
<span class="changed">!                               final float[] zeroes, final int off)</span>
      {
          int ret = off;
          if (a != 0.0f) {
<span class="changed">!             final float dis = b*b - 4.0f * a * c;</span>
              if (dis &gt; 0.0f) {
                  final float sqrtDis = (float) Math.sqrt(dis);
                  // depending on the sign of b we use a slightly different
                  // algorithm than the traditional one to find one of the roots
                  // so we can avoid adding numbers of different signs (which
<hr /><span class="oldmarker">*** 66,172 ****</span>
                  } else {
                      zeroes[ret++] = (-b + sqrtDis) / (2.0f * a);
                      zeroes[ret++] = (2.0f * c) / (-b + sqrtDis);
                  }
              } else if (dis == 0.0f) {
<span class="changed">!                 t = (-b) / (2.0f * a);</span>
<span class="changed">!                 zeroes[ret++] = t;</span>
<span class="changed">!             }</span>
<span class="changed">!         } else {</span>
<span class="changed">!             if (b != 0.0f) {</span>
<span class="changed">!                 t = (-c) / b;</span>
<span class="changed">!                 zeroes[ret++] = t;</span>
              }
          }
          return ret - off;
      }
  
      // find the roots of g(t) = d*t^3 + a*t^2 + b*t + c in [A,B)
<span class="changed">!     static int cubicRootsInAB(float d, float a, float b, float c,</span>
<span class="changed">!                               float[] pts, final int off,</span>
                                final float A, final float B)
      {
<span class="changed">!         if (d == 0.0f) {</span>
<span class="changed">!             int num = quadraticRoots(a, b, c, pts, off);</span>
              return filterOutNotInAB(pts, off, num, A, B) - off;
          }
          // From Graphics Gems:
<span class="changed">!         // http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c</span>
          // (also from awt.geom.CubicCurve2D. But here we don't need as
          // much accuracy and we don't want to create arrays so we use
          // our own customized version).
  
          // normal form: x^3 + ax^2 + bx + c = 0
<span class="changed">!         a /= d;</span>
<span class="changed">!         b /= d;</span>
<span class="changed">!         c /= d;</span>
  
          //  substitute x = y - A/3 to eliminate quadratic term:
          //     x^3 +Px + Q = 0
          //
          // Since we actually need P/3 and Q/2 for all of the
          // calculations that follow, we will calculate
          // p = P/3
          // q = Q/2
          // instead and use those values for simplicity of the code.
<span class="changed">!         double sq_A = a * a;</span>
<span class="changed">!         double p = (1.0d/3.0d) * ((-1.0d/3.0d) * sq_A + b);</span>
<span class="changed">!         double q = (1.0d/2.0d) * ((2.0d/27.0d) * a * sq_A - (1.0d/3.0d) * a * b + c);</span>
  
          // use Cardano's formula
  
<span class="changed">!         double cb_p = p * p * p;</span>
<span class="changed">!         double D = q * q + cb_p;</span>
  
          int num;
          if (D &lt; 0.0d) {
              // see: http://en.wikipedia.org/wiki/Cubic_function#Trigonometric_.28and_hyperbolic.29_method
<span class="changed">!             final double phi = (1.0d/3.0d) * Math.acos(-q / Math.sqrt(-cb_p));</span>
              final double t = 2.0d * Math.sqrt(-p);
  
<span class="changed">!             pts[ off+0 ] = (float) ( t * Math.cos(phi));</span>
<span class="changed">!             pts[ off+1 ] = (float) (-t * Math.cos(phi + (PI / 3.0d)));</span>
<span class="changed">!             pts[ off+2 ] = (float) (-t * Math.cos(phi - (PI / 3.0d)));</span>
              num = 3;
          } else {
              final double sqrt_D = Math.sqrt(D);
              final double u =   Math.cbrt(sqrt_D - q);
              final double v = - Math.cbrt(sqrt_D + q);
  
<span class="changed">!             pts[ off ] = (float) (u + v);</span>
              num = 1;
  
              if (within(D, 0.0d, 1e-8d)) {
<span class="changed">!                 pts[off+1] = -(pts[off] / 2.0f);</span>
                  num = 2;
              }
          }
  
<span class="removed">-         final float sub = (1.0f/3.0f) * a;</span>
<span class="removed">- </span>
<span class="removed">-         for (int i = 0; i &lt; num; ++i) {</span>
<span class="removed">-             pts[ off+i ] -= sub;</span>
<span class="removed">-         }</span>
<span class="removed">- </span>
          return filterOutNotInAB(pts, off, num, A, B) - off;
      }
  
<span class="removed">-     static float evalCubic(final float a, final float b,</span>
<span class="removed">-                            final float c, final float d,</span>
<span class="removed">-                            final float t)</span>
<span class="removed">-     {</span>
<span class="removed">-         return t * (t * (t * a + b) + c) + d;</span>
<span class="removed">-     }</span>
<span class="removed">- </span>
<span class="removed">-     static float evalQuad(final float a, final float b,</span>
<span class="removed">-                           final float c, final float t)</span>
<span class="removed">-     {</span>
<span class="removed">-         return t * (t * a + b) + c;</span>
<span class="removed">-     }</span>
<span class="removed">- </span>
      // returns the index 1 past the last valid element remaining after filtering
<span class="changed">!     static int filterOutNotInAB(float[] nums, final int off, final int len,</span>
                                  final float a, final float b)
      {
          int ret = off;
          for (int i = off, end = off + len; i &lt; end; i++) {
              if (nums[i] &gt;= a &amp;&amp; nums[i] &lt; b) {
<span class="newmarker">--- 77,166 ----</span>
                  } else {
                      zeroes[ret++] = (-b + sqrtDis) / (2.0f * a);
                      zeroes[ret++] = (2.0f * c) / (-b + sqrtDis);
                  }
              } else if (dis == 0.0f) {
<span class="changed">!                 zeroes[ret++] = -b / (2.0f * a);</span>
              }
<span class="new">+         } else if (b != 0.0f) {</span>
<span class="new">+             zeroes[ret++] = -c / b;</span>
          }
          return ret - off;
      }
  
      // find the roots of g(t) = d*t^3 + a*t^2 + b*t + c in [A,B)
<span class="changed">!     static int cubicRootsInAB(final float d0, float a0, float b0, float c0,</span>
<span class="changed">!                               final float[] pts, final int off,</span>
                                final float A, final float B)
      {
<span class="changed">!         if (d0 == 0.0f) {</span>
<span class="changed">!             final int num = quadraticRoots(a0, b0, c0, pts, off);</span>
              return filterOutNotInAB(pts, off, num, A, B) - off;
          }
          // From Graphics Gems:
<span class="changed">!         // https://github.com/erich666/GraphicsGems/blob/master/gems/Roots3And4.c</span>
          // (also from awt.geom.CubicCurve2D. But here we don't need as
          // much accuracy and we don't want to create arrays so we use
          // our own customized version).
  
          // normal form: x^3 + ax^2 + bx + c = 0
<span class="changed">! </span>
<span class="changed">!         // 2018.1: Need double precision if d is very small (flat curve) !</span>
<span class="changed">!         /*</span>
<span class="changed">!          * TODO: cleanup all that code after reading Roots3And4.c</span>
<span class="changed">!          */</span>
<span class="changed">!         final double a = ((double)a0) / d0;</span>
<span class="changed">!         final double b = ((double)b0) / d0;</span>
<span class="changed">!         final double c = ((double)c0) / d0;</span>
  
          //  substitute x = y - A/3 to eliminate quadratic term:
          //     x^3 +Px + Q = 0
          //
          // Since we actually need P/3 and Q/2 for all of the
          // calculations that follow, we will calculate
          // p = P/3
          // q = Q/2
          // instead and use those values for simplicity of the code.
<span class="changed">!         final double sub = (1.0d / 3.0d) * a;</span>
<span class="changed">!         final double sq_A = a * a;</span>
<span class="changed">!         final double p = (1.0d / 3.0d) * ((-1.0d / 3.0d) * sq_A + b);</span>
<span class="changed">!         final double q = (1.0d / 2.0d) * ((2.0d / 27.0d) * a * sq_A - sub * b + c);</span>
  
          // use Cardano's formula
  
<span class="changed">!         final double cb_p = p * p * p;</span>
<span class="changed">!         final double D = q * q + cb_p;</span>
  
          int num;
          if (D &lt; 0.0d) {
              // see: http://en.wikipedia.org/wiki/Cubic_function#Trigonometric_.28and_hyperbolic.29_method
<span class="changed">!             final double phi = (1.0d / 3.0d) * Math.acos(-q / Math.sqrt(-cb_p));</span>
              final double t = 2.0d * Math.sqrt(-p);
  
<span class="changed">!             pts[off    ] = (float) ( t * Math.cos(phi) - sub);</span>
<span class="changed">!             pts[off + 1] = (float) (-t * Math.cos(phi + (Math.PI / 3.0d)) - sub);</span>
<span class="changed">!             pts[off + 2] = (float) (-t * Math.cos(phi - (Math.PI / 3.0d)) - sub);</span>
              num = 3;
          } else {
              final double sqrt_D = Math.sqrt(D);
              final double u =   Math.cbrt(sqrt_D - q);
              final double v = - Math.cbrt(sqrt_D + q);
  
<span class="changed">!             pts[off    ] = (float) (u + v - sub);</span>
              num = 1;
  
              if (within(D, 0.0d, 1e-8d)) {
<span class="changed">!                 pts[off + 1] = (float)((-1.0d / 2.0d) * (u + v) - sub);</span>
                  num = 2;
              }
          }
  
          return filterOutNotInAB(pts, off, num, A, B) - off;
      }
  
      // returns the index 1 past the last valid element remaining after filtering
<span class="changed">!     static int filterOutNotInAB(final float[] nums, final int off, final int len,</span>
                                  final float a, final float b)
      {
          int ret = off;
          for (int i = off, end = off + len; i &lt; end; i++) {
              if (nums[i] &gt;= a &amp;&amp; nums[i] &lt; b) {
<hr /><span class="oldmarker">*** 174,212 ****</span>
              }
          }
          return ret;
      }
  
<span class="changed">!     static float linelen(float x1, float y1, float x2, float y2) {</span>
<span class="changed">!         final float dx = x2 - x1;</span>
<span class="changed">!         final float dy = y2 - y1;</span>
<span class="changed">!         return (float) Math.sqrt(dx*dx + dy*dy);</span>
      }
  
<span class="changed">!     static void subdivide(float[] src, int srcoff, float[] left, int leftoff,</span>
<span class="changed">!                           float[] right, int rightoff, int type)</span>
<span class="changed">!     {</span>
          switch(type) {
          case 6:
<span class="changed">!             Helpers.subdivideQuad(src, srcoff, left, leftoff, right, rightoff);</span>
<span class="changed">!             return;</span>
          case 8:
<span class="changed">!             Helpers.subdivideCubic(src, srcoff, left, leftoff, right, rightoff);</span>
              return;
          default:
              throw new InternalError("Unsupported curve type");
          }
      }
  
<span class="changed">!     static void isort(float[] a, int off, int len) {</span>
<span class="changed">!         for (int i = off + 1, end = off + len; i &lt; end; i++) {</span>
<span class="changed">!             float ai = a[i];</span>
<span class="changed">!             int j = i - 1;</span>
<span class="changed">!             for (; j &gt;= off &amp;&amp; a[j] &gt; ai; j--) {</span>
<span class="changed">!                 a[j+1] = a[j];</span>
              }
<span class="changed">!             a[j+1] = ai;</span>
          }
      }
  
      // Most of these are copied from classes in java.awt.geom because we need
      // both single and double precision variants of these functions, and Line2D,
<span class="newmarker">--- 168,361 ----</span>
              }
          }
          return ret;
      }
  
<span class="changed">!     static float fastLineLen(final float x0, final float y0,</span>
<span class="changed">!                              final float x1, final float y1)</span>
<span class="changed">!     {</span>
<span class="changed">!         final float dx = x1 - x0;</span>
<span class="changed">!         final float dy = y1 - y0;</span>
<span class="changed">! </span>
<span class="changed">!         // use manhattan norm:</span>
<span class="changed">!         return Math.abs(dx) + Math.abs(dy);</span>
      }
  
<span class="changed">!     static float linelen(final float x0, final float y0,</span>
<span class="changed">!                          final float x1, final float y1)</span>
<span class="changed">!     {</span>
<span class="changed">!         final float dx = x1 - x0;</span>
<span class="changed">!         final float dy = y1 - y0;</span>
<span class="changed">!         return (float) Math.sqrt(dx * dx + dy * dy);</span>
<span class="changed">!     }</span>
<span class="changed">! </span>
<span class="changed">!     static float fastQuadLen(final float x0, final float y0,</span>
<span class="changed">!                              final float x1, final float y1,</span>
<span class="changed">!                              final float x2, final float y2)</span>
<span class="changed">!     {</span>
<span class="changed">!         final float dx1 = x1 - x0;</span>
<span class="changed">!         final float dx2 = x2 - x1;</span>
<span class="changed">!         final float dy1 = y1 - y0;</span>
<span class="changed">!         final float dy2 = y2 - y1;</span>
<span class="changed">! </span>
<span class="changed">!         // use manhattan norm:</span>
<span class="changed">!         return Math.abs(dx1) + Math.abs(dx2)</span>
<span class="changed">!              + Math.abs(dy1) + Math.abs(dy2);</span>
<span class="changed">!     }</span>
<span class="changed">! </span>
<span class="changed">!     static float quadlen(final float x0, final float y0,</span>
<span class="changed">!                          final float x1, final float y1,</span>
<span class="changed">!                          final float x2, final float y2)</span>
<span class="changed">!     {</span>
<span class="changed">!         return (linelen(x0, y0, x1, y1)</span>
<span class="changed">!                 + linelen(x1, y1, x2, y2)</span>
<span class="changed">!                 + linelen(x0, y0, x2, y2)) / 2.0f;</span>
<span class="changed">!     }</span>
<span class="changed">! </span>
<span class="changed">! </span>
<span class="changed">!     static float fastCurvelen(final float x0, final float y0,</span>
<span class="changed">!                               final float x1, final float y1,</span>
<span class="changed">!                               final float x2, final float y2,</span>
<span class="changed">!                               final float x3, final float y3)</span>
<span class="changed">!     {</span>
<span class="changed">!         final float dx1 = x1 - x0;</span>
<span class="changed">!         final float dx2 = x2 - x1;</span>
<span class="changed">!         final float dx3 = x3 - x2;</span>
<span class="changed">!         final float dy1 = y1 - y0;</span>
<span class="changed">!         final float dy2 = y2 - y1;</span>
<span class="changed">!         final float dy3 = y3 - y2;</span>
<span class="changed">! </span>
<span class="changed">!         // use manhattan norm:</span>
<span class="changed">!         return Math.abs(dx1) + Math.abs(dx2) + Math.abs(dx3)</span>
<span class="changed">!              + Math.abs(dy1) + Math.abs(dy2) + Math.abs(dy3);</span>
<span class="changed">!     }</span>
<span class="changed">! </span>
<span class="changed">!     static float curvelen(final float x0, final float y0,</span>
<span class="changed">!                           final float x1, final float y1,</span>
<span class="changed">!                           final float x2, final float y2,</span>
<span class="changed">!                           final float x3, final float y3)</span>
<span class="changed">!     {</span>
<span class="changed">!         return (linelen(x0, y0, x1, y1)</span>
<span class="changed">!               + linelen(x1, y1, x2, y2)</span>
<span class="changed">!               + linelen(x2, y2, x3, y3)</span>
<span class="changed">!               + linelen(x0, y0, x3, y3)) / 2.0f;</span>
<span class="changed">!     }</span>
<span class="changed">! </span>
<span class="changed">!     // finds values of t where the curve in pts should be subdivided in order</span>
<span class="changed">!     // to get good offset curves a distance of w away from the middle curve.</span>
<span class="changed">!     // Stores the points in ts, and returns how many of them there were.</span>
<span class="changed">!     static int findSubdivPoints(final Curve c, final float[] pts,</span>
<span class="changed">!                                 final float[] ts, final int type,</span>
<span class="changed">!                                 final float w2)</span>
<span class="changed">!     {</span>
<span class="changed">!         final float x12 = pts[2] - pts[0];</span>
<span class="changed">!         final float y12 = pts[3] - pts[1];</span>
<span class="changed">!         // if the curve is already parallel to either axis we gain nothing</span>
<span class="changed">!         // from rotating it.</span>
<span class="changed">!         if ((y12 != 0.0f &amp;&amp; x12 != 0.0f)) {</span>
<span class="changed">!             // we rotate it so that the first vector in the control polygon is</span>
<span class="changed">!             // parallel to the x-axis. This will ensure that rotated quarter</span>
<span class="changed">!             // circles won't be subdivided.</span>
<span class="changed">!             final float hypot = (float)Math.sqrt(x12 * x12 + y12 * y12);</span>
<span class="changed">!             final float cos = x12 / hypot;</span>
<span class="changed">!             final float sin = y12 / hypot;</span>
<span class="changed">!             final float x1 = cos * pts[0] + sin * pts[1];</span>
<span class="changed">!             final float y1 = cos * pts[1] - sin * pts[0];</span>
<span class="changed">!             final float x2 = cos * pts[2] + sin * pts[3];</span>
<span class="changed">!             final float y2 = cos * pts[3] - sin * pts[2];</span>
<span class="changed">!             final float x3 = cos * pts[4] + sin * pts[5];</span>
<span class="changed">!             final float y3 = cos * pts[5] - sin * pts[4];</span>
<span class="changed">! </span>
              switch(type) {
<span class="new">+             case 8:</span>
<span class="new">+                 final float x4 = cos * pts[6] + sin * pts[7];</span>
<span class="new">+                 final float y4 = cos * pts[7] - sin * pts[6];</span>
<span class="new">+                 c.set(x1, y1, x2, y2, x3, y3, x4, y4);</span>
<span class="new">+                 break;</span>
              case 6:
<span class="changed">!                 c.set(x1, y1, x2, y2, x3, y3);</span>
<span class="changed">!                 break;</span>
<span class="changed">!             default:</span>
<span class="changed">!             }</span>
<span class="changed">!         } else {</span>
<span class="changed">!             c.set(pts, type);</span>
<span class="changed">!         }</span>
<span class="changed">! </span>
<span class="changed">!         int ret = 0;</span>
<span class="changed">!         // we subdivide at values of t such that the remaining rotated</span>
<span class="changed">!         // curves are monotonic in x and y.</span>
<span class="changed">!         ret += c.dxRoots(ts, ret);</span>
<span class="changed">!         ret += c.dyRoots(ts, ret);</span>
<span class="changed">! </span>
<span class="changed">!         // subdivide at inflection points.</span>
<span class="changed">!         if (type == 8) {</span>
<span class="changed">!             // quadratic curves can't have inflection points</span>
<span class="changed">!             ret += c.infPoints(ts, ret);</span>
<span class="changed">!         }</span>
<span class="changed">! </span>
<span class="changed">!         // now we must subdivide at points where one of the offset curves will have</span>
<span class="changed">!         // a cusp. This happens at ts where the radius of curvature is equal to w.</span>
<span class="changed">!         ret += c.rootsOfROCMinusW(ts, ret, w2, 0.0001f);</span>
<span class="changed">! </span>
<span class="changed">!         ret = filterOutNotInAB(ts, 0, ret, 0.0001f, 0.9999f);</span>
<span class="changed">!         isort(ts, ret);</span>
<span class="changed">!         return ret;</span>
<span class="changed">!     }</span>
<span class="changed">! </span>
<span class="changed">!     // finds values of t where the curve in pts should be subdivided in order</span>
<span class="changed">!     // to get intersections with the given clip rectangle.</span>
<span class="changed">!     // Stores the points in ts, and returns how many of them there were.</span>
<span class="changed">!     static int findClipPoints(final Curve curve, final float[] pts,</span>
<span class="changed">!                               final float[] ts, final int type,</span>
<span class="changed">!                               final int outCodeOR,</span>
<span class="changed">!                               final float[] clipRect)</span>
<span class="changed">!     {</span>
<span class="changed">!         curve.set(pts, type);</span>
<span class="changed">! </span>
<span class="changed">!         // clip rectangle (ymin, ymax, xmin, xmax)</span>
<span class="changed">!         int ret = 0;</span>
<span class="changed">! </span>
<span class="changed">!         if ((outCodeOR &amp; OUTCODE_LEFT) != 0) {</span>
<span class="changed">!             ret += curve.xPoints(ts, ret, clipRect[2]);</span>
<span class="changed">!         }</span>
<span class="changed">!         if ((outCodeOR &amp; OUTCODE_RIGHT) != 0) {</span>
<span class="changed">!             ret += curve.xPoints(ts, ret, clipRect[3]);</span>
<span class="changed">!         }</span>
<span class="changed">!         if ((outCodeOR &amp; OUTCODE_TOP) != 0) {</span>
<span class="changed">!             ret += curve.yPoints(ts, ret, clipRect[0]);</span>
<span class="changed">!         }</span>
<span class="changed">!         if ((outCodeOR &amp; OUTCODE_BOTTOM) != 0) {</span>
<span class="changed">!             ret += curve.yPoints(ts, ret, clipRect[1]);</span>
<span class="changed">!         }</span>
<span class="changed">!         isort(ts, ret);</span>
<span class="changed">!         return ret;</span>
<span class="changed">!     }</span>
<span class="changed">! </span>
<span class="changed">!     static void subdivide(final float[] src,</span>
<span class="changed">!                           final float[] left, final float[] right,</span>
<span class="changed">!                           final int type)</span>
<span class="changed">!     {</span>
<span class="changed">!         switch(type) {</span>
          case 8:
<span class="changed">!             subdivideCubic(src, left, right);</span>
<span class="changed">!             return;</span>
<span class="changed">!         case 6:</span>
<span class="changed">!             subdivideQuad(src, left, right);</span>
              return;
          default:
              throw new InternalError("Unsupported curve type");
          }
      }
  
<span class="changed">!     static void isort(final float[] a, final int len) {</span>
<span class="changed">!         for (int i = 1, j; i &lt; len; i++) {</span>
<span class="changed">!             final float ai = a[i];</span>
<span class="changed">!             j = i - 1;</span>
<span class="changed">!             for (; j &gt;= 0 &amp;&amp; a[j] &gt; ai; j--) {</span>
<span class="changed">!                 a[j + 1] = a[j];</span>
              }
<span class="changed">!             a[j + 1] = ai;</span>
          }
      }
  
      // Most of these are copied from classes in java.awt.geom because we need
      // both single and double precision variants of these functions, and Line2D,
<hr /><span class="oldmarker">*** 225,434 ****</span>
       * it is possible to pass the same array for &lt;code&gt;left&lt;/code&gt;
       * and &lt;code&gt;right&lt;/code&gt; and to use offsets, such as &lt;code&gt;rightoff&lt;/code&gt;
       * equals (&lt;code&gt;leftoff&lt;/code&gt; + 6), in order
       * to avoid allocating extra storage for this common point.
       * @param src the array holding the coordinates for the source curve
<span class="removed">-      * @param srcoff the offset into the array of the beginning of the</span>
<span class="removed">-      * the 6 source coordinates</span>
       * @param left the array for storing the coordinates for the first
       * half of the subdivided curve
<span class="removed">-      * @param leftoff the offset into the array of the beginning of the</span>
<span class="removed">-      * the 6 left coordinates</span>
       * @param right the array for storing the coordinates for the second
       * half of the subdivided curve
<span class="removed">-      * @param rightoff the offset into the array of the beginning of the</span>
<span class="removed">-      * the 6 right coordinates</span>
       * @since 1.7
       */
<span class="changed">!     static void subdivideCubic(float[] src, int srcoff,</span>
<span class="changed">!                                float[] left, int leftoff,</span>
<span class="changed">!                                float[] right, int rightoff)</span>
<span class="changed">!     {</span>
<span class="changed">!         float x1 = src[srcoff + 0];</span>
<span class="changed">!         float y1 = src[srcoff + 1];</span>
<span class="changed">!         float ctrlx1 = src[srcoff + 2];</span>
<span class="changed">!         float ctrly1 = src[srcoff + 3];</span>
<span class="changed">!         float ctrlx2 = src[srcoff + 4];</span>
<span class="changed">!         float ctrly2 = src[srcoff + 5];</span>
<span class="changed">!         float x2 = src[srcoff + 6];</span>
<span class="changed">!         float y2 = src[srcoff + 7];</span>
<span class="changed">!         if (left != null) {</span>
<span class="changed">!             left[leftoff + 0] = x1;</span>
<span class="changed">!             left[leftoff + 1] = y1;</span>
<span class="changed">!         }</span>
<span class="changed">!         if (right != null) {</span>
<span class="changed">!             right[rightoff + 6] = x2;</span>
<span class="changed">!             right[rightoff + 7] = y2;</span>
<span class="changed">!         }</span>
<span class="changed">!         x1 = (x1 + ctrlx1) / 2.0f;</span>
<span class="changed">!         y1 = (y1 + ctrly1) / 2.0f;</span>
<span class="changed">!         x2 = (x2 + ctrlx2) / 2.0f;</span>
<span class="changed">!         y2 = (y2 + ctrly2) / 2.0f;</span>
<span class="changed">!         float centerx = (ctrlx1 + ctrlx2) / 2.0f;</span>
<span class="changed">!         float centery = (ctrly1 + ctrly2) / 2.0f;</span>
<span class="changed">!         ctrlx1 = (x1 + centerx) / 2.0f;</span>
<span class="changed">!         ctrly1 = (y1 + centery) / 2.0f;</span>
<span class="changed">!         ctrlx2 = (x2 + centerx) / 2.0f;</span>
<span class="changed">!         ctrly2 = (y2 + centery) / 2.0f;</span>
<span class="changed">!         centerx = (ctrlx1 + ctrlx2) / 2.0f;</span>
<span class="changed">!         centery = (ctrly1 + ctrly2) / 2.0f;</span>
<span class="changed">!         if (left != null) {</span>
<span class="changed">!             left[leftoff + 2] = x1;</span>
<span class="changed">!             left[leftoff + 3] = y1;</span>
<span class="changed">!             left[leftoff + 4] = ctrlx1;</span>
<span class="changed">!             left[leftoff + 5] = ctrly1;</span>
<span class="changed">!             left[leftoff + 6] = centerx;</span>
<span class="changed">!             left[leftoff + 7] = centery;</span>
<span class="changed">!         }</span>
<span class="changed">!         if (right != null) {</span>
<span class="changed">!             right[rightoff + 0] = centerx;</span>
<span class="changed">!             right[rightoff + 1] = centery;</span>
<span class="changed">!             right[rightoff + 2] = ctrlx2;</span>
<span class="changed">!             right[rightoff + 3] = ctrly2;</span>
<span class="changed">!             right[rightoff + 4] = x2;</span>
<span class="changed">!             right[rightoff + 5] = y2;</span>
<span class="changed">!         }</span>
<span class="changed">!     }</span>
<span class="changed">! </span>
<span class="changed">! </span>
<span class="changed">!     static void subdivideCubicAt(float t, float[] src, int srcoff,</span>
<span class="changed">!                                  float[] left, int leftoff,</span>
<span class="changed">!                                  float[] right, int rightoff)</span>
<span class="changed">!     {</span>
<span class="changed">!         float x1 = src[srcoff + 0];</span>
<span class="changed">!         float y1 = src[srcoff + 1];</span>
<span class="changed">!         float ctrlx1 = src[srcoff + 2];</span>
<span class="changed">!         float ctrly1 = src[srcoff + 3];</span>
<span class="changed">!         float ctrlx2 = src[srcoff + 4];</span>
<span class="changed">!         float ctrly2 = src[srcoff + 5];</span>
<span class="changed">!         float x2 = src[srcoff + 6];</span>
<span class="changed">!         float y2 = src[srcoff + 7];</span>
<span class="changed">!         if (left != null) {</span>
<span class="changed">!             left[leftoff + 0] = x1;</span>
<span class="changed">!             left[leftoff + 1] = y1;</span>
<span class="changed">!         }</span>
<span class="changed">!         if (right != null) {</span>
<span class="changed">!             right[rightoff + 6] = x2;</span>
<span class="changed">!             right[rightoff + 7] = y2;</span>
<span class="changed">!         }</span>
<span class="changed">!         x1 = x1 + t * (ctrlx1 - x1);</span>
<span class="changed">!         y1 = y1 + t * (ctrly1 - y1);</span>
<span class="changed">!         x2 = ctrlx2 + t * (x2 - ctrlx2);</span>
<span class="changed">!         y2 = ctrly2 + t * (y2 - ctrly2);</span>
<span class="changed">!         float centerx = ctrlx1 + t * (ctrlx2 - ctrlx1);</span>
<span class="changed">!         float centery = ctrly1 + t * (ctrly2 - ctrly1);</span>
<span class="changed">!         ctrlx1 = x1 + t * (centerx - x1);</span>
<span class="changed">!         ctrly1 = y1 + t * (centery - y1);</span>
<span class="changed">!         ctrlx2 = centerx + t * (x2 - centerx);</span>
<span class="changed">!         ctrly2 = centery + t * (y2 - centery);</span>
<span class="changed">!         centerx = ctrlx1 + t * (ctrlx2 - ctrlx1);</span>
<span class="changed">!         centery = ctrly1 + t * (ctrly2 - ctrly1);</span>
<span class="changed">!         if (left != null) {</span>
<span class="changed">!             left[leftoff + 2] = x1;</span>
<span class="changed">!             left[leftoff + 3] = y1;</span>
<span class="changed">!             left[leftoff + 4] = ctrlx1;</span>
<span class="changed">!             left[leftoff + 5] = ctrly1;</span>
<span class="changed">!             left[leftoff + 6] = centerx;</span>
<span class="changed">!             left[leftoff + 7] = centery;</span>
<span class="changed">!         }</span>
<span class="changed">!         if (right != null) {</span>
<span class="changed">!             right[rightoff + 0] = centerx;</span>
<span class="changed">!             right[rightoff + 1] = centery;</span>
<span class="changed">!             right[rightoff + 2] = ctrlx2;</span>
<span class="changed">!             right[rightoff + 3] = ctrly2;</span>
<span class="changed">!             right[rightoff + 4] = x2;</span>
<span class="changed">!             right[rightoff + 5] = y2;</span>
<span class="changed">!         }</span>
<span class="changed">!     }</span>
<span class="changed">! </span>
<span class="changed">!     static void subdivideQuad(float[] src, int srcoff,</span>
<span class="changed">!                               float[] left, int leftoff,</span>
<span class="changed">!                               float[] right, int rightoff)</span>
<span class="changed">!     {</span>
<span class="changed">!         float x1 = src[srcoff + 0];</span>
<span class="changed">!         float y1 = src[srcoff + 1];</span>
<span class="changed">!         float ctrlx = src[srcoff + 2];</span>
<span class="changed">!         float ctrly = src[srcoff + 3];</span>
<span class="changed">!         float x2 = src[srcoff + 4];</span>
<span class="changed">!         float y2 = src[srcoff + 5];</span>
<span class="changed">!         if (left != null) {</span>
<span class="changed">!             left[leftoff + 0] = x1;</span>
<span class="changed">!             left[leftoff + 1] = y1;</span>
<span class="changed">!         }</span>
<span class="changed">!         if (right != null) {</span>
<span class="changed">!             right[rightoff + 4] = x2;</span>
<span class="changed">!             right[rightoff + 5] = y2;</span>
<span class="changed">!         }</span>
<span class="changed">!         x1 = (x1 + ctrlx) / 2.0f;</span>
<span class="changed">!         y1 = (y1 + ctrly) / 2.0f;</span>
<span class="changed">!         x2 = (x2 + ctrlx) / 2.0f;</span>
<span class="changed">!         y2 = (y2 + ctrly) / 2.0f;</span>
<span class="changed">!         ctrlx = (x1 + x2) / 2.0f;</span>
<span class="changed">!         ctrly = (y1 + y2) / 2.0f;</span>
<span class="changed">!         if (left != null) {</span>
<span class="changed">!             left[leftoff + 2] = x1;</span>
<span class="changed">!             left[leftoff + 3] = y1;</span>
<span class="changed">!             left[leftoff + 4] = ctrlx;</span>
<span class="changed">!             left[leftoff + 5] = ctrly;</span>
<span class="changed">!         }</span>
<span class="changed">!         if (right != null) {</span>
<span class="changed">!             right[rightoff + 0] = ctrlx;</span>
<span class="changed">!             right[rightoff + 1] = ctrly;</span>
<span class="changed">!             right[rightoff + 2] = x2;</span>
<span class="changed">!             right[rightoff + 3] = y2;</span>
<span class="changed">!         }</span>
<span class="changed">!     }</span>
<span class="changed">! </span>
<span class="changed">!     static void subdivideQuadAt(float t, float[] src, int srcoff,</span>
<span class="changed">!                                 float[] left, int leftoff,</span>
<span class="changed">!                                 float[] right, int rightoff)</span>
<span class="changed">!     {</span>
<span class="changed">!         float x1 = src[srcoff + 0];</span>
<span class="changed">!         float y1 = src[srcoff + 1];</span>
<span class="changed">!         float ctrlx = src[srcoff + 2];</span>
<span class="changed">!         float ctrly = src[srcoff + 3];</span>
<span class="changed">!         float x2 = src[srcoff + 4];</span>
<span class="changed">!         float y2 = src[srcoff + 5];</span>
<span class="changed">!         if (left != null) {</span>
<span class="changed">!             left[leftoff + 0] = x1;</span>
<span class="changed">!             left[leftoff + 1] = y1;</span>
<span class="changed">!         }</span>
<span class="changed">!         if (right != null) {</span>
<span class="changed">!             right[rightoff + 4] = x2;</span>
<span class="changed">!             right[rightoff + 5] = y2;</span>
<span class="changed">!         }</span>
<span class="changed">!         x1 = x1 + t * (ctrlx - x1);</span>
<span class="changed">!         y1 = y1 + t * (ctrly - y1);</span>
<span class="changed">!         x2 = ctrlx + t * (x2 - ctrlx);</span>
<span class="changed">!         y2 = ctrly + t * (y2 - ctrly);</span>
<span class="changed">!         ctrlx = x1 + t * (x2 - x1);</span>
<span class="changed">!         ctrly = y1 + t * (y2 - y1);</span>
<span class="changed">!         if (left != null) {</span>
<span class="changed">!             left[leftoff + 2] = x1;</span>
<span class="changed">!             left[leftoff + 3] = y1;</span>
<span class="changed">!             left[leftoff + 4] = ctrlx;</span>
<span class="changed">!             left[leftoff + 5] = ctrly;</span>
<span class="changed">!         }</span>
<span class="changed">!         if (right != null) {</span>
<span class="changed">!             right[rightoff + 0] = ctrlx;</span>
<span class="changed">!             right[rightoff + 1] = ctrly;</span>
<span class="changed">!             right[rightoff + 2] = x2;</span>
<span class="changed">!             right[rightoff + 3] = y2;</span>
<span class="changed">!         }</span>
<span class="changed">!     }</span>
<span class="changed">! </span>
<span class="changed">!     static void subdivideAt(float t, float[] src, int srcoff,</span>
<span class="changed">!                             float[] left, int leftoff,</span>
<span class="changed">!                             float[] right, int rightoff, int size)</span>
<span class="changed">!     {</span>
<span class="changed">!         switch(size) {</span>
<span class="changed">!         case 8:</span>
<span class="changed">!             subdivideCubicAt(t, src, srcoff, left, leftoff, right, rightoff);</span>
<span class="changed">!             return;</span>
<span class="changed">!         case 6:</span>
<span class="changed">!             subdivideQuadAt(t, src, srcoff, left, leftoff, right, rightoff);</span>
<span class="changed">!             return;</span>
          }
      }
  
      // From sun.java2d.loops.GeneralRenderer:
  
<span class="newmarker">--- 374,593 ----</span>
       * it is possible to pass the same array for &lt;code&gt;left&lt;/code&gt;
       * and &lt;code&gt;right&lt;/code&gt; and to use offsets, such as &lt;code&gt;rightoff&lt;/code&gt;
       * equals (&lt;code&gt;leftoff&lt;/code&gt; + 6), in order
       * to avoid allocating extra storage for this common point.
       * @param src the array holding the coordinates for the source curve
       * @param left the array for storing the coordinates for the first
       * half of the subdivided curve
       * @param right the array for storing the coordinates for the second
       * half of the subdivided curve
       * @since 1.7
       */
<span class="changed">!     static void subdivideCubic(final float[] src,</span>
<span class="changed">!                                final float[] left,</span>
<span class="changed">!                                final float[] right)</span>
<span class="changed">!     {</span>
<span class="changed">!         float  x1 = src[0];</span>
<span class="changed">!         float  y1 = src[1];</span>
<span class="changed">!         float cx1 = src[2];</span>
<span class="changed">!         float cy1 = src[3];</span>
<span class="changed">!         float cx2 = src[4];</span>
<span class="changed">!         float cy2 = src[5];</span>
<span class="changed">!         float  x2 = src[6];</span>
<span class="changed">!         float  y2 = src[7];</span>
<span class="changed">! </span>
<span class="changed">!         left[0]  = x1;</span>
<span class="changed">!         left[1]  = y1;</span>
<span class="changed">! </span>
<span class="changed">!         right[6] = x2;</span>
<span class="changed">!         right[7] = y2;</span>
<span class="changed">! </span>
<span class="changed">!         x1 = (x1 + cx1) / 2.0f;</span>
<span class="changed">!         y1 = (y1 + cy1) / 2.0f;</span>
<span class="changed">!         x2 = (x2 + cx2) / 2.0f;</span>
<span class="changed">!         y2 = (y2 + cy2) / 2.0f;</span>
<span class="changed">! </span>
<span class="changed">!         float cx = (cx1 + cx2) / 2.0f;</span>
<span class="changed">!         float cy = (cy1 + cy2) / 2.0f;</span>
<span class="changed">! </span>
<span class="changed">!         cx1 = (x1 + cx) / 2.0f;</span>
<span class="changed">!         cy1 = (y1 + cy) / 2.0f;</span>
<span class="changed">!         cx2 = (x2 + cx) / 2.0f;</span>
<span class="changed">!         cy2 = (y2 + cy) / 2.0f;</span>
<span class="changed">!         cx  = (cx1 + cx2) / 2.0f;</span>
<span class="changed">!         cy  = (cy1 + cy2) / 2.0f;</span>
<span class="changed">! </span>
<span class="changed">!         left[2] = x1;</span>
<span class="changed">!         left[3] = y1;</span>
<span class="changed">!         left[4] = cx1;</span>
<span class="changed">!         left[5] = cy1;</span>
<span class="changed">!         left[6] = cx;</span>
<span class="changed">!         left[7] = cy;</span>
<span class="changed">! </span>
<span class="changed">!         right[0] = cx;</span>
<span class="changed">!         right[1] = cy;</span>
<span class="changed">!         right[2] = cx2;</span>
<span class="changed">!         right[3] = cy2;</span>
<span class="changed">!         right[4] = x2;</span>
<span class="changed">!         right[5] = y2;</span>
<span class="changed">!     }</span>
<span class="changed">! </span>
<span class="changed">!     static void subdivideCubicAt(final float t,</span>
<span class="changed">!                                  final float[] src, final int offS,</span>
<span class="changed">!                                  final float[] pts, final int offL, final int offR)</span>
<span class="changed">!     {</span>
<span class="changed">!         float  x1 = src[offS    ];</span>
<span class="changed">!         float  y1 = src[offS + 1];</span>
<span class="changed">!         float cx1 = src[offS + 2];</span>
<span class="changed">!         float cy1 = src[offS + 3];</span>
<span class="changed">!         float cx2 = src[offS + 4];</span>
<span class="changed">!         float cy2 = src[offS + 5];</span>
<span class="changed">!         float  x2 = src[offS + 6];</span>
<span class="changed">!         float  y2 = src[offS + 7];</span>
<span class="changed">! </span>
<span class="changed">!         pts[offL    ] = x1;</span>
<span class="changed">!         pts[offL + 1] = y1;</span>
<span class="changed">! </span>
<span class="changed">!         pts[offR + 6] = x2;</span>
<span class="changed">!         pts[offR + 7] = y2;</span>
<span class="changed">! </span>
<span class="changed">!         x1 =  x1 + t * (cx1 - x1);</span>
<span class="changed">!         y1 =  y1 + t * (cy1 - y1);</span>
<span class="changed">!         x2 = cx2 + t * (x2 - cx2);</span>
<span class="changed">!         y2 = cy2 + t * (y2 - cy2);</span>
<span class="changed">! </span>
<span class="changed">!         float cx = cx1 + t * (cx2 - cx1);</span>
<span class="changed">!         float cy = cy1 + t * (cy2 - cy1);</span>
<span class="changed">! </span>
<span class="changed">!         cx1 =  x1 + t * (cx - x1);</span>
<span class="changed">!         cy1 =  y1 + t * (cy - y1);</span>
<span class="changed">!         cx2 =  cx + t * (x2 - cx);</span>
<span class="changed">!         cy2 =  cy + t * (y2 - cy);</span>
<span class="changed">!         cx  = cx1 + t * (cx2 - cx1);</span>
<span class="changed">!         cy  = cy1 + t * (cy2 - cy1);</span>
<span class="changed">! </span>
<span class="changed">!         pts[offL + 2] = x1;</span>
<span class="changed">!         pts[offL + 3] = y1;</span>
<span class="changed">!         pts[offL + 4] = cx1;</span>
<span class="changed">!         pts[offL + 5] = cy1;</span>
<span class="changed">!         pts[offL + 6] = cx;</span>
<span class="changed">!         pts[offL + 7] = cy;</span>
<span class="changed">! </span>
<span class="changed">!         pts[offR    ] = cx;</span>
<span class="changed">!         pts[offR + 1] = cy;</span>
<span class="changed">!         pts[offR + 2] = cx2;</span>
<span class="changed">!         pts[offR + 3] = cy2;</span>
<span class="changed">!         pts[offR + 4] = x2;</span>
<span class="changed">!         pts[offR + 5] = y2;</span>
<span class="changed">!     }</span>
<span class="changed">! </span>
<span class="changed">!     static void subdivideQuad(final float[] src,</span>
<span class="changed">!                               final float[] left,</span>
<span class="changed">!                               final float[] right)</span>
<span class="changed">!     {</span>
<span class="changed">!         float x1 = src[0];</span>
<span class="changed">!         float y1 = src[1];</span>
<span class="changed">!         float cx = src[2];</span>
<span class="changed">!         float cy = src[3];</span>
<span class="changed">!         float x2 = src[4];</span>
<span class="changed">!         float y2 = src[5];</span>
<span class="changed">! </span>
<span class="changed">!         left[0]  = x1;</span>
<span class="changed">!         left[1]  = y1;</span>
<span class="changed">! </span>
<span class="changed">!         right[4] = x2;</span>
<span class="changed">!         right[5] = y2;</span>
<span class="changed">! </span>
<span class="changed">!         x1 = (x1 + cx) / 2.0f;</span>
<span class="changed">!         y1 = (y1 + cy) / 2.0f;</span>
<span class="changed">!         x2 = (x2 + cx) / 2.0f;</span>
<span class="changed">!         y2 = (y2 + cy) / 2.0f;</span>
<span class="changed">!         cx = (x1 + x2) / 2.0f;</span>
<span class="changed">!         cy = (y1 + y2) / 2.0f;</span>
<span class="changed">! </span>
<span class="changed">!         left[2] = x1;</span>
<span class="changed">!         left[3] = y1;</span>
<span class="changed">!         left[4] = cx;</span>
<span class="changed">!         left[5] = cy;</span>
<span class="changed">! </span>
<span class="changed">!         right[0] = cx;</span>
<span class="changed">!         right[1] = cy;</span>
<span class="changed">!         right[2] = x2;</span>
<span class="changed">!         right[3] = y2;</span>
<span class="changed">!     }</span>
<span class="changed">! </span>
<span class="changed">!     static void subdivideQuadAt(final float t,</span>
<span class="changed">!                                 final float[] src, final int offS,</span>
<span class="changed">!                                 final float[] pts, final int offL, final int offR)</span>
<span class="changed">!     {</span>
<span class="changed">!         float x1 = src[offS    ];</span>
<span class="changed">!         float y1 = src[offS + 1];</span>
<span class="changed">!         float cx = src[offS + 2];</span>
<span class="changed">!         float cy = src[offS + 3];</span>
<span class="changed">!         float x2 = src[offS + 4];</span>
<span class="changed">!         float y2 = src[offS + 5];</span>
<span class="changed">! </span>
<span class="changed">!         pts[offL    ] = x1;</span>
<span class="changed">!         pts[offL + 1] = y1;</span>
<span class="changed">! </span>
<span class="changed">!         pts[offR + 4] = x2;</span>
<span class="changed">!         pts[offR + 5] = y2;</span>
<span class="changed">! </span>
<span class="changed">!         x1 = x1 + t * (cx - x1);</span>
<span class="changed">!         y1 = y1 + t * (cy - y1);</span>
<span class="changed">!         x2 = cx + t * (x2 - cx);</span>
<span class="changed">!         y2 = cy + t * (y2 - cy);</span>
<span class="changed">!         cx = x1 + t * (x2 - x1);</span>
<span class="changed">!         cy = y1 + t * (y2 - y1);</span>
<span class="changed">! </span>
<span class="changed">!         pts[offL + 2] = x1;</span>
<span class="changed">!         pts[offL + 3] = y1;</span>
<span class="changed">!         pts[offL + 4] = cx;</span>
<span class="changed">!         pts[offL + 5] = cy;</span>
<span class="changed">! </span>
<span class="changed">!         pts[offR    ] = cx;</span>
<span class="changed">!         pts[offR + 1] = cy;</span>
<span class="changed">!         pts[offR + 2] = x2;</span>
<span class="changed">!         pts[offR + 3] = y2;</span>
<span class="changed">!     }</span>
<span class="changed">! </span>
<span class="changed">!     static void subdivideLineAt(final float t,</span>
<span class="changed">!                                 final float[] src, final int offS,</span>
<span class="changed">!                                 final float[] pts, final int offL, final int offR)</span>
<span class="changed">!     {</span>
<span class="changed">!         float x1 = src[offS    ];</span>
<span class="changed">!         float y1 = src[offS + 1];</span>
<span class="changed">!         float x2 = src[offS + 2];</span>
<span class="changed">!         float y2 = src[offS + 3];</span>
<span class="changed">! </span>
<span class="changed">!         pts[offL    ] = x1;</span>
<span class="changed">!         pts[offL + 1] = y1;</span>
<span class="changed">! </span>
<span class="changed">!         pts[offR + 2] = x2;</span>
<span class="changed">!         pts[offR + 3] = y2;</span>
<span class="changed">! </span>
<span class="changed">!         x1 = x1 + t * (x2 - x1);</span>
<span class="changed">!         y1 = y1 + t * (y2 - y1);</span>
<span class="changed">! </span>
<span class="changed">!         pts[offL + 2] = x1;</span>
<span class="changed">!         pts[offL + 3] = y1;</span>
<span class="changed">! </span>
<span class="changed">!         pts[offR    ] = x1;</span>
<span class="changed">!         pts[offR + 1] = y1;</span>
<span class="changed">!     }</span>
<span class="changed">! </span>
<span class="changed">!     static void subdivideAt(final float t,</span>
<span class="changed">!                             final float[] src, final int offS,</span>
<span class="changed">!                             final float[] pts, final int offL, final int type)</span>
<span class="changed">!     {</span>
<span class="changed">!         // if instead of switch (perf + most probable cases first)</span>
<span class="changed">!         if (type == 8) {</span>
<span class="changed">!             subdivideCubicAt(t, src, offS, pts, offL, offL + type);</span>
<span class="changed">!         } else if (type == 4) {</span>
<span class="changed">!             subdivideLineAt(t, src, offS, pts, offL, offL + type);</span>
<span class="changed">!         } else {</span>
<span class="changed">!             subdivideQuadAt(t, src, offS, pts, offL, offL + type);</span>
          }
      }
  
      // From sun.java2d.loops.GeneralRenderer:
  
<hr /><span class="oldmarker">*** 612,627 ****</span>
                  case TYPE_LINETO:
                      io.lineTo(_curves[e], _curves[e+1]);
                      e += 2;
                      continue;
                  case TYPE_QUADTO:
<span class="changed">!                     io.quadTo(_curves[e+0], _curves[e+1],</span>
                                _curves[e+2], _curves[e+3]);
                      e += 4;
                      continue;
                  case TYPE_CUBICTO:
<span class="changed">!                     io.curveTo(_curves[e+0], _curves[e+1],</span>
                                 _curves[e+2], _curves[e+3],
                                 _curves[e+4], _curves[e+5]);
                      e += 6;
                      continue;
                  default:
<span class="newmarker">--- 771,786 ----</span>
                  case TYPE_LINETO:
                      io.lineTo(_curves[e], _curves[e+1]);
                      e += 2;
                      continue;
                  case TYPE_QUADTO:
<span class="changed">!                     io.quadTo(_curves[e],   _curves[e+1],</span>
                                _curves[e+2], _curves[e+3]);
                      e += 4;
                      continue;
                  case TYPE_CUBICTO:
<span class="changed">!                     io.curveTo(_curves[e],   _curves[e+1],</span>
                                 _curves[e+2], _curves[e+3],
                                 _curves[e+4], _curves[e+5]);
                      e += 6;
                      continue;
                  default:
<hr /><span class="oldmarker">*** 655,670 ****</span>
                      e -= 2;
                      io.lineTo(_curves[e], _curves[e+1]);
                      continue;
                  case TYPE_QUADTO:
                      e -= 4;
<span class="changed">!                     io.quadTo(_curves[e+0], _curves[e+1],</span>
                                _curves[e+2], _curves[e+3]);
                      continue;
                  case TYPE_CUBICTO:
                      e -= 6;
<span class="changed">!                     io.curveTo(_curves[e+0], _curves[e+1],</span>
                                 _curves[e+2], _curves[e+3],
                                 _curves[e+4], _curves[e+5]);
                      continue;
                  default:
                  }
<span class="newmarker">--- 814,829 ----</span>
                      e -= 2;
                      io.lineTo(_curves[e], _curves[e+1]);
                      continue;
                  case TYPE_QUADTO:
                      e -= 4;
<span class="changed">!                     io.quadTo(_curves[e],   _curves[e+1],</span>
                                _curves[e+2], _curves[e+3]);
                      continue;
                  case TYPE_CUBICTO:
                      e -= 6;
<span class="changed">!                     io.curveTo(_curves[e],   _curves[e+1],</span>
                                 _curves[e+2], _curves[e+3],
                                 _curves[e+4], _curves[e+5]);
                      continue;
                  default:
                  }
</pre>
<center><a href='../../../../../../src/share/classes/sun/java2d/marlin/FloatArrayCache.java.cdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../src/share/classes/sun/java2d/marlin/IntArrayCache.java.cdiff.html' target='_top'>next &gt</a></center>
</body></html>

