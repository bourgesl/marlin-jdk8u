<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>jdk Sdiff src/share/classes/sun/java2d/marlin </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../../../src/share/classes/sun/java2d/marlin/DMarlinRenderingEngine.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../src/share/classes/sun/java2d/marlin/DRendererContext.java.sdiff.html' target='_top'>next &gt</a></center>
<h2>src/share/classes/sun/java2d/marlin/DRenderer.java</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-13695">13695</a> : <a href="https://bugs.openjdk.java.net/browse/JDK-8198885">8198885</a>: upgrade Marlin (java2d) to 0.9.1
Summary: clipping implemented in Dasher (curve subdivision at clip edges) + higher quality(curve, subpixels) + new path simplifier
Reviewed-by: prr, serb</pre>

<table><tr valign="top">
<td><pre>
   1 /*
<span class="changed">   2  * Copyright (c) 2007, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the "Classpath" exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any

</pre><hr></hr><pre>
  37     static final boolean ENABLE_BLOCK_FLAGS_HEURISTICS = MarlinProperties.isUseTileFlagsWithHeuristics();
  38 
  39     private static final int ALL_BUT_LSB = 0xFFFFFFFE;
  40     private static final int ERR_STEP_MAX = 0x7FFFFFFF; // = 2^31 - 1
  41 
  42     private static final double POWER_2_TO_32 = 0x1.0p32d;
  43 
  44     // use double to make tosubpix methods faster (no int to double conversion)
  45     static final double SUBPIXEL_SCALE_X = SUBPIXEL_POSITIONS_X;
  46     static final double SUBPIXEL_SCALE_Y = SUBPIXEL_POSITIONS_Y;
  47     static final int SUBPIXEL_MASK_X = SUBPIXEL_POSITIONS_X - 1;
  48     static final int SUBPIXEL_MASK_Y = SUBPIXEL_POSITIONS_Y - 1;
  49 
  50     static final double RDR_OFFSET_X = 0.5d / SUBPIXEL_SCALE_X;
  51     static final double RDR_OFFSET_Y = 0.5d / SUBPIXEL_SCALE_Y;
  52 
  53     // number of subpixels corresponding to a tile line
  54     private static final int SUBPIXEL_TILE
  55         = TILE_H &lt;&lt; SUBPIXEL_LG_POSITIONS_Y;
  56 
<span class="changed">  57     // 2048 (pixelSize) pixels (height) x 8 subpixels = 64K</span>
  58     static final int INITIAL_BUCKET_ARRAY
<span class="changed">  59         = INITIAL_PIXEL_DIM * SUBPIXEL_POSITIONS_Y;</span>
  60 
  61     // crossing capacity = edges count / 4 ~ 1024
  62     static final int INITIAL_CROSSING_COUNT = INITIAL_EDGES_COUNT &gt;&gt; 2;
  63 
  64     // common to all types of input path segments.
  65     // OFFSET as bytes
  66     // only integer values:
  67     public static final long OFF_CURX_OR  = 0;
  68     public static final long OFF_ERROR    = OFF_CURX_OR  + SIZE_INT;
  69     public static final long OFF_BUMP_X   = OFF_ERROR    + SIZE_INT;
  70     public static final long OFF_BUMP_ERR = OFF_BUMP_X   + SIZE_INT;
  71     public static final long OFF_NEXT     = OFF_BUMP_ERR + SIZE_INT;
  72     public static final long OFF_YMAX     = OFF_NEXT     + SIZE_INT;
  73 
  74     // size of one edge in bytes
  75     public static final int SIZEOF_EDGE_BYTES = (int)(OFF_YMAX + SIZE_INT);
  76 
  77     // curve break into lines
  78     // cubic error in subpixels to decrement step
  79     private static final double CUB_DEC_ERR_SUBPIX
<span class="changed">  80         = MarlinProperties.getCubicDecD2() * (NORM_SUBPIXELS / 8.0d); // 1 pixel</span>
  81     // cubic error in subpixels to increment step
  82     private static final double CUB_INC_ERR_SUBPIX
<span class="changed">  83         = MarlinProperties.getCubicIncD1() * (NORM_SUBPIXELS / 8.0d); // 0.4 pixel</span>


  84 
  85     // TestNonAARasterization (JDK-8170879): cubics
  86     // bad paths (59294/100000 == 59,29%, 94335 bad pixels (avg = 1,59), 3966 warnings (avg = 0,07)


  87 
  88     // cubic bind length to decrement step
  89     public static final double CUB_DEC_BND
  90         = 8.0d * CUB_DEC_ERR_SUBPIX;
  91     // cubic bind length to increment step
  92     public static final double CUB_INC_BND
  93         = 8.0d * CUB_INC_ERR_SUBPIX;
  94 
  95     // cubic countlg
  96     public static final int CUB_COUNT_LG = 2;
  97     // cubic count = 2^countlg
  98     private static final int CUB_COUNT = 1 &lt;&lt; CUB_COUNT_LG;
  99     // cubic count^2 = 4^countlg
 100     private static final int CUB_COUNT_2 = 1 &lt;&lt; (2 * CUB_COUNT_LG);
 101     // cubic count^3 = 8^countlg
 102     private static final int CUB_COUNT_3 = 1 &lt;&lt; (3 * CUB_COUNT_LG);
 103     // cubic dt = 1 / count
 104     private static final double CUB_INV_COUNT = 1.0d / CUB_COUNT;
 105     // cubic dt^2 = 1 / count^2 = 1 / 4^countlg
 106     private static final double CUB_INV_COUNT_2 = 1.0d / CUB_COUNT_2;
 107     // cubic dt^3 = 1 / count^3 = 1 / 8^countlg
 108     private static final double CUB_INV_COUNT_3 = 1.0d / CUB_COUNT_3;
 109 
 110     // quad break into lines
 111     // quadratic error in subpixels
 112     private static final double QUAD_DEC_ERR_SUBPIX
<span class="changed"> 113         = MarlinProperties.getQuadDecD2() * (NORM_SUBPIXELS / 8.0d); // 0.5 pixel</span>
 114 
 115     // TestNonAARasterization (JDK-8170879): quads
 116     // bad paths (62916/100000 == 62,92%, 103818 bad pixels (avg = 1,65), 6514 warnings (avg = 0,10)


 117 
 118     // quadratic bind length to decrement step
 119     public static final double QUAD_DEC_BND
 120         = 8.0d * QUAD_DEC_ERR_SUBPIX;
 121 
 122 //////////////////////////////////////////////////////////////////////////////
 123 //  SCAN LINE
 124 //////////////////////////////////////////////////////////////////////////////
 125     // crossings ie subpixel edge x coordinates
 126     private int[] crossings;
 127     // auxiliary storage for crossings (merge sort)
 128     private int[] aux_crossings;
 129 
 130     // indices into the segment pointer lists. They indicate the "active"
 131     // sublist in the segment lists (the portion of the list that contains
 132     // all the segments that cross the next scan line).
 133     private int edgeCount;
 134     private int[] edgePtrs;
 135     // auxiliary storage for edge pointers (merge sort)
 136     private int[] aux_edgePtrs;

</pre><hr></hr><pre>
 163     private int[] edgeBucketCounts; // 2*newedges + (1 if pruning needed)
 164     // used range for edgeBuckets / edgeBucketCounts
 165     private int buckets_minY;
 166     private int buckets_maxY;
 167 
 168     // edgeBuckets ref (clean)
 169     private final IntArrayCache.Reference edgeBuckets_ref;
 170     // edgeBucketCounts ref (clean)
 171     private final IntArrayCache.Reference edgeBucketCounts_ref;
 172 
 173     // Flattens using adaptive forward differencing. This only carries out
 174     // one iteration of the AFD loop. All it does is update AFD variables (i.e.
 175     // X0, Y0, D*[X|Y], COUNT; not variables used for computing scanline crossings).
 176     private void quadBreakIntoLinesAndAdd(double x0, double y0,
 177                                           final DCurve c,
 178                                           final double x2, final double y2)
 179     {
 180         int count = 1; // dt = 1 / count
 181 
 182         // maximum(ddX|Y) = norm(dbx, dby) * dt^2 (= 1)
<span class="changed"> 183         double maxDD = Math.abs(c.dbx) + Math.abs(c.dby);</span>
 184 
 185         final double _DEC_BND = QUAD_DEC_BND;
 186 
 187         while (maxDD &gt;= _DEC_BND) {
 188             // divide step by half:
 189             maxDD /= 4.0d; // error divided by 2^2 = 4
 190 
 191             count &lt;&lt;= 1;
 192             if (DO_STATS) {
 193                 rdrCtx.stats.stat_rdr_quadBreak_dec.add(count);
 194             }
 195         }
 196 
<span class="changed"> 197         int nL = 0; // line count</span>

 198         if (count &gt; 1) {
 199             final double icount = 1.0d / count; // dt
 200             final double icount2 = icount * icount; // dt^2
 201 
 202             final double ddx = c.dbx * icount2;
 203             final double ddy = c.dby * icount2;
 204             double dx = c.bx * icount2 + c.cx * icount;
 205             double dy = c.by * icount2 + c.cy * icount;
 206 
<span class="changed"> 207             double x1, y1;</span>
<span class="changed"> 208 </span>
<span class="changed"> 209             while (--count &gt; 0) {</span>
<span class="changed"> 210                 x1 = x0 + dx;</span>
<span class="changed"> 211                 dx += ddx;</span>
<span class="changed"> 212                 y1 = y0 + dy;</span>
<span class="changed"> 213                 dy += ddy;</span>
 214 
 215                 addLine(x0, y0, x1, y1);
<span class="removed"> 216 </span>
<span class="removed"> 217                 if (DO_STATS) { nL++; }</span>
 218                 x0 = x1;
 219                 y0 = y1;
 220             }
 221         }
 222         addLine(x0, y0, x2, y2);
 223 
 224         if (DO_STATS) {
<span class="changed"> 225             rdrCtx.stats.stat_rdr_quadBreak.add(nL + 1);</span>
 226         }
 227     }
 228 
 229     // x0, y0 and x3,y3 are the endpoints of the curve. We could compute these
 230     // using c.xat(0),c.yat(0) and c.xat(1),c.yat(1), but this might introduce
 231     // numerical errors, and our callers already have the exact values.
 232     // Another alternative would be to pass all the control points, and call
 233     // c.set here, but then too many numbers are passed around.
 234     private void curveBreakIntoLinesAndAdd(double x0, double y0,
 235                                            final DCurve c,
 236                                            final double x3, final double y3)
 237     {
 238         int count           = CUB_COUNT;
 239         final double icount  = CUB_INV_COUNT;   // dt
 240         final double icount2 = CUB_INV_COUNT_2; // dt^2
 241         final double icount3 = CUB_INV_COUNT_3; // dt^3
 242 
 243         // the dx and dy refer to forward differencing variables, not the last
 244         // coefficients of the "points" polynomial
 245         double dddx, dddy, ddx, ddy, dx, dy;
 246         dddx = 2.0d * c.dax * icount3;
 247         dddy = 2.0d * c.day * icount3;
 248         ddx = dddx + c.dbx * icount2;
 249         ddy = dddy + c.dby * icount2;
 250         dx = c.ax * icount3 + c.bx * icount2 + c.cx * icount;
 251         dy = c.ay * icount3 + c.by * icount2 + c.cy * icount;
 252 
<span class="removed"> 253         // we use x0, y0 to walk the line</span>
<span class="removed"> 254         double x1 = x0, y1 = y0;</span>
 255         int nL = 0; // line count
 256 
 257         final double _DEC_BND = CUB_DEC_BND;
 258         final double _INC_BND = CUB_INC_BND;

 259 
<span class="changed"> 260         while (count &gt; 0) {</span>
<span class="changed"> 261             // divide step by half:</span>
<span class="changed"> 262             while (Math.abs(ddx) + Math.abs(ddy) &gt;= _DEC_BND) {</span>
<span class="changed"> 263                 dddx /= 8.0d;</span>
<span class="changed"> 264                 dddy /= 8.0d;</span>
<span class="changed"> 265                 ddx = ddx / 4.0d - dddx;</span>
<span class="changed"> 266                 ddy = ddy / 4.0d - dddy;</span>
<span class="changed"> 267                 dx = (dx - ddx) / 2.0d;</span>
<span class="changed"> 268                 dy = (dy - ddy) / 2.0d;</span>
<span class="changed"> 269 </span>
<span class="changed"> 270                 count &lt;&lt;= 1;</span>
<span class="changed"> 271                 if (DO_STATS) {</span>
<span class="changed"> 272                     rdrCtx.stats.stat_rdr_curveBreak_dec.add(count);</span>
<span class="changed"> 273                 }</span>
<span class="changed"> 274             }</span>
 275 
 276             // double step:
 277             // can only do this on even "count" values, because we must divide count by 2
<span class="changed"> 278             while (count % 2 == 0</span>
<span class="changed"> 279                    &amp;&amp; Math.abs(dx) + Math.abs(dy) &lt;= _INC_BND)</span>
<span class="changed"> 280             {</span>
 281                 dx = 2.0d * dx + ddx;
 282                 dy = 2.0d * dy + ddy;
 283                 ddx = 4.0d * (ddx + dddx);
 284                 ddy = 4.0d * (ddy + dddy);
 285                 dddx *= 8.0d;
 286                 dddy *= 8.0d;
 287 
 288                 count &gt;&gt;= 1;
 289                 if (DO_STATS) {
 290                     rdrCtx.stats.stat_rdr_curveBreak_inc.add(count);
 291                 }
 292             }
<span class="changed"> 293             if (--count &gt; 0) {</span>


















 294                 x1 += dx;
<span class="removed"> 295                 dx += ddx;</span>
<span class="removed"> 296                 ddx += dddx;</span>
 297                 y1 += dy;

 298                 dy += ddy;

 299                 ddy += dddy;
<span class="removed"> 300             } else {</span>
<span class="removed"> 301                 x1 = x3;</span>
<span class="removed"> 302                 y1 = y3;</span>
<span class="removed"> 303             }</span>
 304 
 305             addLine(x0, y0, x1, y1);
<span class="removed"> 306 </span>
<span class="removed"> 307             if (DO_STATS) { nL++; }</span>
 308             x0 = x1;
 309             y0 = y1;
 310         }


 311         if (DO_STATS) {
<span class="changed"> 312             rdrCtx.stats.stat_rdr_curveBreak.add(nL);</span>
 313         }
 314     }
 315 
 316     private void addLine(double x1, double y1, double x2, double y2) {
 317         if (DO_MONITORS) {
 318             rdrCtx.stats.mon_rdr_addLine.start();
 319         }
 320         if (DO_STATS) {
 321             rdrCtx.stats.stat_rdr_addLine.add(1);
 322         }
 323         int or = 1; // orientation of the line. 1 if y increases, 0 otherwise.
 324         if (y2 &lt; y1) {
 325             or = 0;
 326             double tmp = y2;
 327             y2 = y1;
 328             y1 = tmp;
 329             tmp = x2;
 330             x2 = x1;
 331             x1 = tmp;
 332         }

</pre><hr></hr><pre>
 517 
 518     /* block flags (0|1) */
 519     private int[] blkFlags;
 520 
 521     // blkFlags ref (clean)
 522     private final IntArrayCache.Reference blkFlags_ref;
 523 
 524     DRenderer(final DRendererContext rdrCtx) {
 525         this.rdrCtx = rdrCtx;
 526         this.curve = rdrCtx.curve;
 527         this.cache = rdrCtx.cache;
 528 
 529         this.edges = rdrCtx.newOffHeapArray(INITIAL_EDGES_CAPACITY); // 96K
 530 
 531         edgeBuckets_ref      = rdrCtx.newCleanIntArrayRef(INITIAL_BUCKET_ARRAY); // 64K
 532         edgeBucketCounts_ref = rdrCtx.newCleanIntArrayRef(INITIAL_BUCKET_ARRAY); // 64K
 533 
 534         edgeBuckets      = edgeBuckets_ref.initial;
 535         edgeBucketCounts = edgeBucketCounts_ref.initial;
 536 
<span class="changed"> 537         // 2048 (pixelsize) pixel large</span>
<span class="changed"> 538         alphaLine_ref = rdrCtx.newCleanIntArrayRef(INITIAL_AA_ARRAY); // 8K</span>
 539         alphaLine     = alphaLine_ref.initial;
 540 
 541         crossings_ref     = rdrCtx.newDirtyIntArrayRef(INITIAL_CROSSING_COUNT); // 2K
 542         aux_crossings_ref = rdrCtx.newDirtyIntArrayRef(INITIAL_CROSSING_COUNT); // 2K
 543         edgePtrs_ref      = rdrCtx.newDirtyIntArrayRef(INITIAL_CROSSING_COUNT); // 2K
 544         aux_edgePtrs_ref  = rdrCtx.newDirtyIntArrayRef(INITIAL_CROSSING_COUNT); // 2K
 545 
 546         crossings     = crossings_ref.initial;
 547         aux_crossings = aux_crossings_ref.initial;
 548         edgePtrs      = edgePtrs_ref.initial;
 549         aux_edgePtrs  = aux_edgePtrs_ref.initial;
 550 
 551         blkFlags_ref = rdrCtx.newCleanIntArrayRef(INITIAL_ARRAY); // 1K = 1 tile line
 552         blkFlags     = blkFlags_ref.initial;
 553     }
 554 
 555     DRenderer init(final int pix_boundsX, final int pix_boundsY,
 556                   final int pix_boundsWidth, final int pix_boundsHeight,
 557                   final int windingRule)
 558     {

</pre><hr></hr><pre>
 676         this.x0 = sx;
 677         this.y0 = sy;
 678     }
 679 
 680     @Override
 681     public void lineTo(final double pix_x1, final double pix_y1) {
 682         final double x1 = tosubpixx(pix_x1);
 683         final double y1 = tosubpixy(pix_y1);
 684         addLine(x0, y0, x1, y1);
 685         x0 = x1;
 686         y0 = y1;
 687     }
 688 
 689     @Override
 690     public void curveTo(final double pix_x1, final double pix_y1,
 691                         final double pix_x2, final double pix_y2,
 692                         final double pix_x3, final double pix_y3)
 693     {
 694         final double xe = tosubpixx(pix_x3);
 695         final double ye = tosubpixy(pix_y3);
<span class="changed"> 696         curve.set(x0, y0, tosubpixx(pix_x1), tosubpixy(pix_y1),</span>
<span class="changed"> 697                   tosubpixx(pix_x2), tosubpixy(pix_y2), xe, ye);</span>


 698         curveBreakIntoLinesAndAdd(x0, y0, curve, xe, ye);
 699         x0 = xe;
 700         y0 = ye;
 701     }
 702 
 703     @Override
 704     public void quadTo(final double pix_x1, final double pix_y1,
 705                        final double pix_x2, final double pix_y2)
 706     {
 707         final double xe = tosubpixx(pix_x2);
 708         final double ye = tosubpixy(pix_y2);
<span class="changed"> 709         curve.set(x0, y0, tosubpixx(pix_x1), tosubpixy(pix_y1), xe, ye);</span>


 710         quadBreakIntoLinesAndAdd(x0, y0, curve, xe, ye);
 711         x0 = xe;
 712         y0 = ye;
 713     }
 714 
 715     @Override
 716     public void closePath() {
 717         if (x0 != sx0 || y0 != sy0) {
 718             addLine(x0, y0, sx0, sy0);
 719             x0 = sx0;
 720             y0 = sy0;
 721         }
 722     }
 723 
 724     @Override
 725     public void pathDone() {
 726         closePath();
 727     }
 728 
 729     @Override

</pre><hr></hr>
</pre></td><td><pre>
   1 /*
<span class="changed">   2  * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the "Classpath" exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any

</pre><hr></hr><pre>
  37     static final boolean ENABLE_BLOCK_FLAGS_HEURISTICS = MarlinProperties.isUseTileFlagsWithHeuristics();
  38 
  39     private static final int ALL_BUT_LSB = 0xFFFFFFFE;
  40     private static final int ERR_STEP_MAX = 0x7FFFFFFF; // = 2^31 - 1
  41 
  42     private static final double POWER_2_TO_32 = 0x1.0p32d;
  43 
  44     // use double to make tosubpix methods faster (no int to double conversion)
  45     static final double SUBPIXEL_SCALE_X = SUBPIXEL_POSITIONS_X;
  46     static final double SUBPIXEL_SCALE_Y = SUBPIXEL_POSITIONS_Y;
  47     static final int SUBPIXEL_MASK_X = SUBPIXEL_POSITIONS_X - 1;
  48     static final int SUBPIXEL_MASK_Y = SUBPIXEL_POSITIONS_Y - 1;
  49 
  50     static final double RDR_OFFSET_X = 0.5d / SUBPIXEL_SCALE_X;
  51     static final double RDR_OFFSET_Y = 0.5d / SUBPIXEL_SCALE_Y;
  52 
  53     // number of subpixels corresponding to a tile line
  54     private static final int SUBPIXEL_TILE
  55         = TILE_H &lt;&lt; SUBPIXEL_LG_POSITIONS_Y;
  56 
<span class="changed">  57     // 2176 pixels (height) x 8 subpixels = 68K</span>
  58     static final int INITIAL_BUCKET_ARRAY
<span class="changed">  59         = INITIAL_PIXEL_HEIGHT * SUBPIXEL_POSITIONS_Y;</span>
  60 
  61     // crossing capacity = edges count / 4 ~ 1024
  62     static final int INITIAL_CROSSING_COUNT = INITIAL_EDGES_COUNT &gt;&gt; 2;
  63 
  64     // common to all types of input path segments.
  65     // OFFSET as bytes
  66     // only integer values:
  67     public static final long OFF_CURX_OR  = 0;
  68     public static final long OFF_ERROR    = OFF_CURX_OR  + SIZE_INT;
  69     public static final long OFF_BUMP_X   = OFF_ERROR    + SIZE_INT;
  70     public static final long OFF_BUMP_ERR = OFF_BUMP_X   + SIZE_INT;
  71     public static final long OFF_NEXT     = OFF_BUMP_ERR + SIZE_INT;
  72     public static final long OFF_YMAX     = OFF_NEXT     + SIZE_INT;
  73 
  74     // size of one edge in bytes
  75     public static final int SIZEOF_EDGE_BYTES = (int)(OFF_YMAX + SIZE_INT);
  76 
  77     // curve break into lines
  78     // cubic error in subpixels to decrement step
  79     private static final double CUB_DEC_ERR_SUBPIX
<span class="changed">  80         = MarlinProperties.getCubicDecD2() * (SUBPIXEL_POSITIONS_X / 8.0d); // 1.0 / 8th pixel</span>
  81     // cubic error in subpixels to increment step
  82     private static final double CUB_INC_ERR_SUBPIX
<span class="changed">  83         = MarlinProperties.getCubicIncD1() * (SUBPIXEL_POSITIONS_X / 8.0d); // 0.4 / 8th pixel</span>
<span class="changed">  84     // scale factor for Y-axis contribution to quad / cubic errors:</span>
<span class="changed">  85     public static final double SCALE_DY = ((double) SUBPIXEL_POSITIONS_X) / SUBPIXEL_POSITIONS_Y;</span>
  86 
  87     // TestNonAARasterization (JDK-8170879): cubics
  88     // bad paths (59294/100000 == 59,29%, 94335 bad pixels (avg = 1,59), 3966 warnings (avg = 0,07)
<span class="new">  89 // 2018</span>
<span class="new">  90     // 1.0 / 0.2: bad paths (67194/100000 == 67,19%, 117394 bad pixels (avg = 1,75 - max =  9), 4042 warnings (avg = 0,06)</span>
  91 
  92     // cubic bind length to decrement step
  93     public static final double CUB_DEC_BND
  94         = 8.0d * CUB_DEC_ERR_SUBPIX;
  95     // cubic bind length to increment step
  96     public static final double CUB_INC_BND
  97         = 8.0d * CUB_INC_ERR_SUBPIX;
  98 
  99     // cubic countlg
 100     public static final int CUB_COUNT_LG = 2;
 101     // cubic count = 2^countlg
 102     private static final int CUB_COUNT = 1 &lt;&lt; CUB_COUNT_LG;
 103     // cubic count^2 = 4^countlg
 104     private static final int CUB_COUNT_2 = 1 &lt;&lt; (2 * CUB_COUNT_LG);
 105     // cubic count^3 = 8^countlg
 106     private static final int CUB_COUNT_3 = 1 &lt;&lt; (3 * CUB_COUNT_LG);
 107     // cubic dt = 1 / count
 108     private static final double CUB_INV_COUNT = 1.0d / CUB_COUNT;
 109     // cubic dt^2 = 1 / count^2 = 1 / 4^countlg
 110     private static final double CUB_INV_COUNT_2 = 1.0d / CUB_COUNT_2;
 111     // cubic dt^3 = 1 / count^3 = 1 / 8^countlg
 112     private static final double CUB_INV_COUNT_3 = 1.0d / CUB_COUNT_3;
 113 
 114     // quad break into lines
 115     // quadratic error in subpixels
 116     private static final double QUAD_DEC_ERR_SUBPIX
<span class="changed"> 117         = MarlinProperties.getQuadDecD2() * (SUBPIXEL_POSITIONS_X / 8.0d); // 0.5 / 8th pixel</span>
 118 
 119     // TestNonAARasterization (JDK-8170879): quads
 120     // bad paths (62916/100000 == 62,92%, 103818 bad pixels (avg = 1,65), 6514 warnings (avg = 0,10)
<span class="new"> 121 // 2018</span>
<span class="new"> 122     // 0.50px  = bad paths (62915/100000 == 62,92%, 103810 bad pixels (avg = 1,65), 6512 warnings (avg = 0,10)</span>
 123 
 124     // quadratic bind length to decrement step
 125     public static final double QUAD_DEC_BND
 126         = 8.0d * QUAD_DEC_ERR_SUBPIX;
 127 
 128 //////////////////////////////////////////////////////////////////////////////
 129 //  SCAN LINE
 130 //////////////////////////////////////////////////////////////////////////////
 131     // crossings ie subpixel edge x coordinates
 132     private int[] crossings;
 133     // auxiliary storage for crossings (merge sort)
 134     private int[] aux_crossings;
 135 
 136     // indices into the segment pointer lists. They indicate the "active"
 137     // sublist in the segment lists (the portion of the list that contains
 138     // all the segments that cross the next scan line).
 139     private int edgeCount;
 140     private int[] edgePtrs;
 141     // auxiliary storage for edge pointers (merge sort)
 142     private int[] aux_edgePtrs;

</pre><hr></hr><pre>
 169     private int[] edgeBucketCounts; // 2*newedges + (1 if pruning needed)
 170     // used range for edgeBuckets / edgeBucketCounts
 171     private int buckets_minY;
 172     private int buckets_maxY;
 173 
 174     // edgeBuckets ref (clean)
 175     private final IntArrayCache.Reference edgeBuckets_ref;
 176     // edgeBucketCounts ref (clean)
 177     private final IntArrayCache.Reference edgeBucketCounts_ref;
 178 
 179     // Flattens using adaptive forward differencing. This only carries out
 180     // one iteration of the AFD loop. All it does is update AFD variables (i.e.
 181     // X0, Y0, D*[X|Y], COUNT; not variables used for computing scanline crossings).
 182     private void quadBreakIntoLinesAndAdd(double x0, double y0,
 183                                           final DCurve c,
 184                                           final double x2, final double y2)
 185     {
 186         int count = 1; // dt = 1 / count
 187 
 188         // maximum(ddX|Y) = norm(dbx, dby) * dt^2 (= 1)
<span class="changed"> 189         double maxDD = Math.abs(c.dbx) + Math.abs(c.dby) * SCALE_DY;</span>
 190 
 191         final double _DEC_BND = QUAD_DEC_BND;
 192 
 193         while (maxDD &gt;= _DEC_BND) {
 194             // divide step by half:
 195             maxDD /= 4.0d; // error divided by 2^2 = 4
 196 
 197             count &lt;&lt;= 1;
 198             if (DO_STATS) {
 199                 rdrCtx.stats.stat_rdr_quadBreak_dec.add(count);
 200             }
 201         }
 202 
<span class="changed"> 203         final int nL = count; // line count</span>
<span class="changed"> 204 </span>
 205         if (count &gt; 1) {
 206             final double icount = 1.0d / count; // dt
 207             final double icount2 = icount * icount; // dt^2
 208 
 209             final double ddx = c.dbx * icount2;
 210             final double ddy = c.dby * icount2;
 211             double dx = c.bx * icount2 + c.cx * icount;
 212             double dy = c.by * icount2 + c.cy * icount;
 213 
<span class="changed"> 214             // we use x0, y0 to walk the line</span>
<span class="changed"> 215             for (double x1 = x0, y1 = y0; --count &gt; 0; dx += ddx, dy += ddy) {</span>
<span class="changed"> 216                 x1 += dx;</span>
<span class="changed"> 217                 y1 += dy;</span>



 218 
 219                 addLine(x0, y0, x1, y1);


 220                 x0 = x1;
 221                 y0 = y1;
 222             }
 223         }
 224         addLine(x0, y0, x2, y2);
 225 
 226         if (DO_STATS) {
<span class="changed"> 227             rdrCtx.stats.stat_rdr_quadBreak.add(nL);</span>
 228         }
 229     }
 230 
 231     // x0, y0 and x3,y3 are the endpoints of the curve. We could compute these
 232     // using c.xat(0),c.yat(0) and c.xat(1),c.yat(1), but this might introduce
 233     // numerical errors, and our callers already have the exact values.
 234     // Another alternative would be to pass all the control points, and call
 235     // c.set here, but then too many numbers are passed around.
 236     private void curveBreakIntoLinesAndAdd(double x0, double y0,
 237                                            final DCurve c,
 238                                            final double x3, final double y3)
 239     {
 240         int count            = CUB_COUNT;
 241         final double icount  = CUB_INV_COUNT;   // dt
 242         final double icount2 = CUB_INV_COUNT_2; // dt^2
 243         final double icount3 = CUB_INV_COUNT_3; // dt^3
 244 
 245         // the dx and dy refer to forward differencing variables, not the last
 246         // coefficients of the "points" polynomial
 247         double dddx, dddy, ddx, ddy, dx, dy;
 248         dddx = 2.0d * c.dax * icount3;
 249         dddy = 2.0d * c.day * icount3;
 250         ddx = dddx + c.dbx * icount2;
 251         ddy = dddy + c.dby * icount2;
 252         dx = c.ax * icount3 + c.bx * icount2 + c.cx * icount;
 253         dy = c.ay * icount3 + c.by * icount2 + c.cy * icount;
 254 


 255         int nL = 0; // line count
 256 
 257         final double _DEC_BND = CUB_DEC_BND;
 258         final double _INC_BND = CUB_INC_BND;
<span class="new"> 259         final double _SCALE_DY = SCALE_DY;</span>
 260 
<span class="changed"> 261         // we use x0, y0 to walk the line</span>
<span class="changed"> 262         for (double x1 = x0, y1 = y0; count &gt; 0; ) {</span>
<span class="changed"> 263             // inc / dec =&gt; ratio ~ 5 to minimize upscale / downscale but minimize edges</span>












 264 
 265             // double step:
 266             // can only do this on even "count" values, because we must divide count by 2
<span class="changed"> 267             while ((count % 2 == 0)</span>
<span class="changed"> 268                     &amp;&amp; ((Math.abs(ddx) + Math.abs(ddy) * _SCALE_DY) &lt;= _INC_BND)) {</span>

 269                 dx = 2.0d * dx + ddx;
 270                 dy = 2.0d * dy + ddy;
 271                 ddx = 4.0d * (ddx + dddx);
 272                 ddy = 4.0d * (ddy + dddy);
 273                 dddx *= 8.0d;
 274                 dddy *= 8.0d;
 275 
 276                 count &gt;&gt;= 1;
 277                 if (DO_STATS) {
 278                     rdrCtx.stats.stat_rdr_curveBreak_inc.add(count);
 279                 }
 280             }
<span class="changed"> 281 </span>
<span class="changed"> 282             // divide step by half:</span>
<span class="changed"> 283             while ((Math.abs(ddx) + Math.abs(ddy) * _SCALE_DY) &gt;= _DEC_BND) {</span>
<span class="changed"> 284                 dddx /= 8.0d;</span>
<span class="changed"> 285                 dddy /= 8.0d;</span>
<span class="changed"> 286                 ddx = ddx / 4.0d - dddx;</span>
<span class="changed"> 287                 ddy = ddy / 4.0d - dddy;</span>
<span class="changed"> 288                 dx = (dx - ddx) / 2.0d;</span>
<span class="changed"> 289                 dy = (dy - ddy) / 2.0d;</span>
<span class="changed"> 290 </span>
<span class="changed"> 291                 count &lt;&lt;= 1;</span>
<span class="changed"> 292                 if (DO_STATS) {</span>
<span class="changed"> 293                     rdrCtx.stats.stat_rdr_curveBreak_dec.add(count);</span>
<span class="changed"> 294                 }</span>
<span class="changed"> 295             }</span>
<span class="changed"> 296             if (--count == 0) {</span>
<span class="changed"> 297                 break;</span>
<span class="changed"> 298             }</span>
<span class="changed"> 299 </span>
 300             x1 += dx;


 301             y1 += dy;
<span class="new"> 302             dx += ddx;</span>
 303             dy += ddy;
<span class="new"> 304             ddx += dddx;</span>
 305             ddy += dddy;




 306 
 307             addLine(x0, y0, x1, y1);


 308             x0 = x1;
 309             y0 = y1;
 310         }
<span class="new"> 311         addLine(x0, y0, x3, y3);</span>
<span class="new"> 312 </span>
 313         if (DO_STATS) {
<span class="changed"> 314             rdrCtx.stats.stat_rdr_curveBreak.add(nL + 1);</span>
 315         }
 316     }
 317 
 318     private void addLine(double x1, double y1, double x2, double y2) {
 319         if (DO_MONITORS) {
 320             rdrCtx.stats.mon_rdr_addLine.start();
 321         }
 322         if (DO_STATS) {
 323             rdrCtx.stats.stat_rdr_addLine.add(1);
 324         }
 325         int or = 1; // orientation of the line. 1 if y increases, 0 otherwise.
 326         if (y2 &lt; y1) {
 327             or = 0;
 328             double tmp = y2;
 329             y2 = y1;
 330             y1 = tmp;
 331             tmp = x2;
 332             x2 = x1;
 333             x1 = tmp;
 334         }

</pre><hr></hr><pre>
 519 
 520     /* block flags (0|1) */
 521     private int[] blkFlags;
 522 
 523     // blkFlags ref (clean)
 524     private final IntArrayCache.Reference blkFlags_ref;
 525 
 526     DRenderer(final DRendererContext rdrCtx) {
 527         this.rdrCtx = rdrCtx;
 528         this.curve = rdrCtx.curve;
 529         this.cache = rdrCtx.cache;
 530 
 531         this.edges = rdrCtx.newOffHeapArray(INITIAL_EDGES_CAPACITY); // 96K
 532 
 533         edgeBuckets_ref      = rdrCtx.newCleanIntArrayRef(INITIAL_BUCKET_ARRAY); // 64K
 534         edgeBucketCounts_ref = rdrCtx.newCleanIntArrayRef(INITIAL_BUCKET_ARRAY); // 64K
 535 
 536         edgeBuckets      = edgeBuckets_ref.initial;
 537         edgeBucketCounts = edgeBucketCounts_ref.initial;
 538 
<span class="changed"> 539         // 4096 pixels large</span>
<span class="changed"> 540         alphaLine_ref = rdrCtx.newCleanIntArrayRef(INITIAL_AA_ARRAY); // 16K</span>
 541         alphaLine     = alphaLine_ref.initial;
 542 
 543         crossings_ref     = rdrCtx.newDirtyIntArrayRef(INITIAL_CROSSING_COUNT); // 2K
 544         aux_crossings_ref = rdrCtx.newDirtyIntArrayRef(INITIAL_CROSSING_COUNT); // 2K
 545         edgePtrs_ref      = rdrCtx.newDirtyIntArrayRef(INITIAL_CROSSING_COUNT); // 2K
 546         aux_edgePtrs_ref  = rdrCtx.newDirtyIntArrayRef(INITIAL_CROSSING_COUNT); // 2K
 547 
 548         crossings     = crossings_ref.initial;
 549         aux_crossings = aux_crossings_ref.initial;
 550         edgePtrs      = edgePtrs_ref.initial;
 551         aux_edgePtrs  = aux_edgePtrs_ref.initial;
 552 
 553         blkFlags_ref = rdrCtx.newCleanIntArrayRef(INITIAL_ARRAY); // 1K = 1 tile line
 554         blkFlags     = blkFlags_ref.initial;
 555     }
 556 
 557     DRenderer init(final int pix_boundsX, final int pix_boundsY,
 558                   final int pix_boundsWidth, final int pix_boundsHeight,
 559                   final int windingRule)
 560     {

</pre><hr></hr><pre>
 678         this.x0 = sx;
 679         this.y0 = sy;
 680     }
 681 
 682     @Override
 683     public void lineTo(final double pix_x1, final double pix_y1) {
 684         final double x1 = tosubpixx(pix_x1);
 685         final double y1 = tosubpixy(pix_y1);
 686         addLine(x0, y0, x1, y1);
 687         x0 = x1;
 688         y0 = y1;
 689     }
 690 
 691     @Override
 692     public void curveTo(final double pix_x1, final double pix_y1,
 693                         final double pix_x2, final double pix_y2,
 694                         final double pix_x3, final double pix_y3)
 695     {
 696         final double xe = tosubpixx(pix_x3);
 697         final double ye = tosubpixy(pix_y3);
<span class="changed"> 698         curve.set(x0, y0,</span>
<span class="changed"> 699                 tosubpixx(pix_x1), tosubpixy(pix_y1),</span>
<span class="changed"> 700                 tosubpixx(pix_x2), tosubpixy(pix_y2),</span>
<span class="changed"> 701                 xe, ye);</span>
 702         curveBreakIntoLinesAndAdd(x0, y0, curve, xe, ye);
 703         x0 = xe;
 704         y0 = ye;
 705     }
 706 
 707     @Override
 708     public void quadTo(final double pix_x1, final double pix_y1,
 709                        final double pix_x2, final double pix_y2)
 710     {
 711         final double xe = tosubpixx(pix_x2);
 712         final double ye = tosubpixy(pix_y2);
<span class="changed"> 713         curve.set(x0, y0,</span>
<span class="changed"> 714                 tosubpixx(pix_x1), tosubpixy(pix_y1),</span>
<span class="changed"> 715                 xe, ye);</span>
 716         quadBreakIntoLinesAndAdd(x0, y0, curve, xe, ye);
 717         x0 = xe;
 718         y0 = ye;
 719     }
 720 
 721     @Override
 722     public void closePath() {
 723         if (x0 != sx0 || y0 != sy0) {
 724             addLine(x0, y0, sx0, sy0);
 725             x0 = sx0;
 726             y0 = sy0;
 727         }
 728     }
 729 
 730     @Override
 731     public void pathDone() {
 732         closePath();
 733     }
 734 
 735     @Override

</pre><hr></hr>
</pre></td>
</tr></table>
<center><a href='../../../../../../src/share/classes/sun/java2d/marlin/DMarlinRenderingEngine.java.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../../index.html' target='_top'>index</a> <a href='../../../../../../src/share/classes/sun/java2d/marlin/DRendererContext.java.sdiff.html' target='_top'>next &gt</a></center>
</body></html>
