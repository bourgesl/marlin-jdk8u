# HG changeset patch
# User lbourges
# Date 1466019819 -7200
#      Wed Jun 15 21:43:39 2016 +0200
# Node ID 21bfc4452441ea3a542af4ca79cbc54048bec0eb
# Parent  cf5567d544b4db383800f4b3aa52c00ceda1592e
8159093: Fix coding conventions in Marlin renderer
Summary: capital letters for constants and use rdrCtx.stats (field)
Reviewed-by: flar, prr

diff --git a/src/share/classes/sun/java2d/marlin/ArrayCache.java b/src/share/classes/sun/java2d/marlin/ArrayCache.java
--- a/src/share/classes/sun/java2d/marlin/ArrayCache.java
+++ b/src/share/classes/sun/java2d/marlin/ArrayCache.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2016, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -58,7 +58,7 @@
         for (int i = 0; i < BUCKETS; i++, arraySize <<= 2) {
             ARRAY_SIZES[i] = arraySize;
 
-            if (doTrace) {
+            if (DO_TRACE) {
                 logInfo("arraySize[" + i + "]: " + arraySize);
             }
         }
@@ -71,7 +71,7 @@
         for (int i = 0; i < BUCKETS; i++, arraySize <<= 1) {
             DIRTY_BYTE_ARRAY_SIZES[i] = arraySize;
 
-            if (doTrace) {
+            if (DO_TRACE) {
                 logInfo("dirty arraySize[" + i + "]: " + arraySize);
             }
         }
@@ -83,7 +83,7 @@
         THRESHOLD_LARGE_ARRAY_SIZE = 8L * THRESHOLD_ARRAY_SIZE; // 16M
         THRESHOLD_HUGE_ARRAY_SIZE  = 8L * THRESHOLD_LARGE_ARRAY_SIZE; // 128M
 
-        if (doStats || doMonitors) {
+        if (DO_STATS || DO_MONITORS) {
             logInfo("ArrayCache.BUCKETS        = " + BUCKETS);
             logInfo("ArrayCache.MIN_ARRAY_SIZE = " + MIN_ARRAY_SIZE);
             logInfo("ArrayCache.MAX_ARRAY_SIZE = " + MAX_ARRAY_SIZE);
diff --git a/src/share/classes/sun/java2d/marlin/ByteArrayCache.java b/src/share/classes/sun/java2d/marlin/ByteArrayCache.java
--- a/src/share/classes/sun/java2d/marlin/ByteArrayCache.java
+++ b/src/share/classes/sun/java2d/marlin/ByteArrayCache.java
@@ -54,7 +54,7 @@
     }
 
     byte[] getArray() {
-        if (doStats) {
+        if (DO_STATS) {
             getOp++;
         }
 
@@ -64,7 +64,7 @@
             return array;
         }
 
-        if (doStats) {
+        if (DO_STATS) {
             createOp++;
         }
 
@@ -73,18 +73,18 @@
 
     void putDirtyArray(final byte[] array, final int length) {
         if (length != arraySize) {
-            if (doChecks) {
+            if (DO_CHECKS) {
                 MarlinUtils.logInfo("ArrayCache: bad length = " + length);
             }
             return;
         }
-        if (doStats) {
+        if (DO_STATS) {
             returnOp++;
         }
 
         // NO clean-up of array data = DIRTY ARRAY
 
-        if (doCleanDirty) {
+        if (DO_CLEAN_DIRTY) {
             // Force zero-fill dirty arrays:
             Arrays.fill(array, 0, array.length, BYTE_0);
         }
@@ -97,12 +97,12 @@
                   final int fromIndex, final int toIndex)
     {
         if (length != arraySize) {
-            if (doChecks) {
+            if (DO_CHECKS) {
                 MarlinUtils.logInfo("ArrayCache: bad length = " + length);
             }
             return;
         }
-        if (doStats) {
+        if (DO_STATS) {
             returnOp++;
         }
 
@@ -125,7 +125,7 @@
             Arrays.fill(array, fromIndex, toIndex, value);
         }
 
-        if (doChecks) {
+        if (DO_CHECKS) {
             check(array, fromIndex, toIndex, value);
         }
     }
@@ -133,7 +133,7 @@
     static void check(final byte[] array, final int fromIndex,
                       final int toIndex, final byte value)
     {
-        if (doChecks) {
+        if (DO_CHECKS) {
             // check zero on full array:
             for (int i = 0; i < array.length; i++) {
                 if (array[i] != value) {
diff --git a/src/share/classes/sun/java2d/marlin/Curve.java b/src/share/classes/sun/java2d/marlin/Curve.java
--- a/src/share/classes/sun/java2d/marlin/Curve.java
+++ b/src/share/classes/sun/java2d/marlin/Curve.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007, 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2016, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,8 +25,6 @@
 
 package sun.java2d.marlin;
 
-import java.util.Iterator;
-
 final class Curve {
 
     float ax, ay, bx, by, cx, cy, dx, dy;
diff --git a/src/share/classes/sun/java2d/marlin/Dasher.java b/src/share/classes/sun/java2d/marlin/Dasher.java
--- a/src/share/classes/sun/java2d/marlin/Dasher.java
+++ b/src/share/classes/sun/java2d/marlin/Dasher.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007, 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2016, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -41,9 +41,9 @@
  */
 final class Dasher implements sun.awt.geom.PathConsumer2D, MarlinConst {
 
-    static final int recLimit = 4;
+    static final int REC_LIMIT = 4;
     static final float ERR = 0.01f;
-    static final float minTincrement = 1f / (1 << recLimit);
+    static final float MIN_T_INC = 1f / (1 << REC_LIMIT);
 
     private PathConsumer2D out;
     private float[] dash;
@@ -139,7 +139,7 @@
      * clean up before reusing this instance
      */
     void dispose() {
-        if (doCleanDirty) {
+        if (DO_CLEAN_DIRTY) {
             // Force zero-fill dirty arrays:
             Arrays.fill(curCurvepts, 0f);
             Arrays.fill(firstSegmentsBuffer, 0f);
@@ -217,8 +217,8 @@
                 int segIdx = firstSegidx;
                 float[] buf = firstSegmentsBuffer;
                 if (segIdx + len  > buf.length) {
-                    if (doStats) {
-                        RendererContext.stats.stat_array_dasher_firstSegmentsBuffer
+                    if (DO_STATS) {
+                        rdrCtx.stats.stat_array_dasher_firstSegmentsBuffer
                             .add(segIdx + len);
                     }
                     firstSegmentsBuffer = buf
@@ -403,8 +403,8 @@
         private final float[] curLeafCtrlPolyLengths = new float[3];
 
         LengthIterator() {
-            this.recCurveStack = new float[recLimit + 1][8];
-            this.sides = new Side[recLimit];
+            this.recCurveStack = new float[REC_LIMIT + 1][8];
+            this.sides = new Side[REC_LIMIT];
             // if any methods are called without first initializing this object
             // on a curve, we want it to fail ASAP.
             this.nextT = Float.MAX_VALUE;
@@ -421,7 +421,7 @@
         void reset() {
             // keep data dirty
             // as it appears not useful to reset data:
-            if (doCleanDirty) {
+            if (DO_CLEAN_DIRTY) {
                 final int recLimit = recCurveStack.length - 1;
                 for (int i = recLimit; i >= 0; i--) {
                     Arrays.fill(recCurveStack[i], 0f);
@@ -607,7 +607,7 @@
             if (len >= 0f) {
                 lastT = nextT;
                 lenAtLastT = lenAtNextT;
-                nextT += (1 << (recLimit - recLevel)) * minTincrement;
+                nextT += (1 << (REC_LIMIT - recLevel)) * MIN_T_INC;
                 lenAtNextT += len;
                 // invalidate caches
                 flatLeafCoefCache[2] = -1f;
@@ -641,7 +641,7 @@
             final float lineLen = Helpers.linelen(curve[0], curve[1],
                                                   curve[curveType-2],
                                                   curve[curveType-1]);
-            if ((polyLen - lineLen) < ERR || recLevel == recLimit) {
+            if ((polyLen - lineLen) < ERR || recLevel == REC_LIMIT) {
                 return (polyLen + lineLen) / 2f;
             }
             return -1f;
diff --git a/src/share/classes/sun/java2d/marlin/FloatArrayCache.java b/src/share/classes/sun/java2d/marlin/FloatArrayCache.java
--- a/src/share/classes/sun/java2d/marlin/FloatArrayCache.java
+++ b/src/share/classes/sun/java2d/marlin/FloatArrayCache.java
@@ -54,7 +54,7 @@
     }
 
     float[] getArray() {
-        if (doStats) {
+        if (DO_STATS) {
             getOp++;
         }
 
@@ -65,7 +65,7 @@
             return array;
         }
 
-        if (doStats) {
+        if (DO_STATS) {
             createOp++;
         }
 
@@ -74,18 +74,18 @@
 
     void putDirtyArray(final float[] array, final int length) {
         if (length != arraySize) {
-            if (doChecks) {
+            if (DO_CHECKS) {
                 MarlinUtils.logInfo("ArrayCache: bad length = " + length);
             }
             return;
         }
-        if (doStats) {
+        if (DO_STATS) {
             returnOp++;
         }
 
         // NO clean-up of array data = DIRTY ARRAY
 
-        if (doCleanDirty) {
+        if (DO_CLEAN_DIRTY) {
             // Force zero-fill dirty arrays:
             Arrays.fill(array, 0, array.length, 0f);
         }
@@ -98,12 +98,12 @@
                   final int fromIndex, final int toIndex)
     {
         if (length != arraySize) {
-            if (doChecks) {
+            if (DO_CHECKS) {
                 MarlinUtils.logInfo("ArrayCache: bad length = " + length);
             }
             return;
         }
-        if (doStats) {
+        if (DO_STATS) {
             returnOp++;
         }
 
@@ -126,7 +126,7 @@
             Arrays.fill(array, fromIndex, toIndex, value);
         }
 
-        if (doChecks) {
+        if (DO_CHECKS) {
             check(array, fromIndex, toIndex, value);
         }
     }
@@ -134,7 +134,7 @@
     static void check(final float[] array, final int fromIndex,
                       final int toIndex, final float value)
     {
-        if (doChecks) {
+        if (DO_CHECKS) {
             // check zero on full array:
             for (int i = 0; i < array.length; i++) {
                 if (array[i] != value) {
diff --git a/src/share/classes/sun/java2d/marlin/Helpers.java b/src/share/classes/sun/java2d/marlin/Helpers.java
--- a/src/share/classes/sun/java2d/marlin/Helpers.java
+++ b/src/share/classes/sun/java2d/marlin/Helpers.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007, 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2016, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -248,9 +248,9 @@
      * the 6 right coordinates
      * @since 1.7
      */
-    static void subdivideCubic(float src[], int srcoff,
-                               float left[], int leftoff,
-                               float right[], int rightoff)
+    static void subdivideCubic(float[] src, int srcoff,
+                               float[] left, int leftoff,
+                               float[] right, int rightoff)
     {
         float x1 = src[srcoff + 0];
         float y1 = src[srcoff + 1];
@@ -299,9 +299,9 @@
     }
 
 
-    static void subdivideCubicAt(float t, float src[], int srcoff,
-                                 float left[], int leftoff,
-                                 float right[], int rightoff)
+    static void subdivideCubicAt(float t, float[] src, int srcoff,
+                                 float[] left, int leftoff,
+                                 float[] right, int rightoff)
     {
         float x1 = src[srcoff + 0];
         float y1 = src[srcoff + 1];
@@ -349,9 +349,9 @@
         }
     }
 
-    static void subdivideQuad(float src[], int srcoff,
-                              float left[], int leftoff,
-                              float right[], int rightoff)
+    static void subdivideQuad(float[] src, int srcoff,
+                              float[] left, int leftoff,
+                              float[] right, int rightoff)
     {
         float x1 = src[srcoff + 0];
         float y1 = src[srcoff + 1];
@@ -387,9 +387,9 @@
         }
     }
 
-    static void subdivideQuadAt(float t, float src[], int srcoff,
-                                float left[], int leftoff,
-                                float right[], int rightoff)
+    static void subdivideQuadAt(float t, float[] src, int srcoff,
+                                float[] left, int leftoff,
+                                float[] right, int rightoff)
     {
         float x1 = src[srcoff + 0];
         float y1 = src[srcoff + 1];
@@ -425,9 +425,9 @@
         }
     }
 
-    static void subdivideAt(float t, float src[], int srcoff,
-                            float left[], int leftoff,
-                            float right[], int rightoff, int size)
+    static void subdivideAt(float t, float[] src, int srcoff,
+                            float[] left, int leftoff,
+                            float[] right, int rightoff, int size)
     {
         switch(size) {
         case 8:
diff --git a/src/share/classes/sun/java2d/marlin/IntArrayCache.java b/src/share/classes/sun/java2d/marlin/IntArrayCache.java
--- a/src/share/classes/sun/java2d/marlin/IntArrayCache.java
+++ b/src/share/classes/sun/java2d/marlin/IntArrayCache.java
@@ -54,7 +54,7 @@
     }
 
     int[] getArray() {
-        if (doStats) {
+        if (DO_STATS) {
             getOp++;
         }
 
@@ -64,7 +64,7 @@
             return array;
         }
 
-        if (doStats) {
+        if (DO_STATS) {
             createOp++;
         }
 
@@ -73,18 +73,18 @@
 
     void putDirtyArray(final int[] array, final int length) {
         if (length != arraySize) {
-            if (doChecks) {
+            if (DO_CHECKS) {
                 MarlinUtils.logInfo("ArrayCache: bad length = " + length);
             }
             return;
         }
-        if (doStats) {
+        if (DO_STATS) {
             returnOp++;
         }
 
         // NO clean-up of array data = DIRTY ARRAY
 
-        if (doCleanDirty) {
+        if (DO_CLEAN_DIRTY) {
             // Force zero-fill dirty arrays:
             Arrays.fill(array, 0, array.length, 0);
         }
@@ -97,12 +97,12 @@
                   final int fromIndex, final int toIndex)
     {
         if (length != arraySize) {
-            if (doChecks) {
+            if (DO_CHECKS) {
                 MarlinUtils.logInfo("ArrayCache: bad length = " + length);
             }
             return;
         }
-        if (doStats) {
+        if (DO_STATS) {
             returnOp++;
         }
 
@@ -125,7 +125,7 @@
             Arrays.fill(array, fromIndex, toIndex, value);
         }
 
-        if (doChecks) {
+        if (DO_CHECKS) {
             check(array, fromIndex, toIndex, value);
         }
     }
@@ -133,7 +133,7 @@
     static void check(final int[] array, final int fromIndex,
                       final int toIndex, final int value)
     {
-        if (doChecks) {
+        if (DO_CHECKS) {
             // check zero on full array:
             for (int i = 0; i < array.length; i++) {
                 if (array[i] != value) {
diff --git a/src/share/classes/sun/java2d/marlin/MarlinCache.java b/src/share/classes/sun/java2d/marlin/MarlinCache.java
--- a/src/share/classes/sun/java2d/marlin/MarlinCache.java
+++ b/src/share/classes/sun/java2d/marlin/MarlinCache.java
@@ -60,7 +60,7 @@
         ALPHA_MAP_UNSAFE = new OffHeapArray(_ALPHA_MAP, _ALPHA_MAP.length); // 1K
         ALPHA_MAP =_ALPHA_MAP;
 
-        final Unsafe _unsafe = OffHeapArray.unsafe;
+        final Unsafe _unsafe = OffHeapArray.UNSAFE;
         final long addr = ALPHA_MAP_UNSAFE.address;
 
         for (int i = 0; i < _ALPHA_MAP.length; i++) {
@@ -157,7 +157,7 @@
                     || (width * heightSubPixel) >
                             ((edgeSumDeltaY - heightSubPixel) << BLOCK_SIZE_LG);
 
-                if (doTrace && !useRLE) {
+                if (DO_TRACE && !useRLE) {
                     final float meanCrossings
                         = ((float) edgeSumDeltaY) / heightSubPixel;
                     final float meanDist = width / (meanCrossings - 1);
@@ -180,8 +180,8 @@
         final int nxTiles = (width + TILE_SIZE) >> TILE_SIZE_LG;
 
         if (nxTiles > INITIAL_ARRAY) {
-            if (doStats) {
-                RendererContext.stats.stat_array_marlincache_touchedTile
+            if (DO_STATS) {
+                rdrCtx.stats.stat_array_marlincache_touchedTile
                     .add(nxTiles);
             }
             touchedTile = rdrCtx.getIntArray(nxTiles);
@@ -206,7 +206,7 @@
             // note: may throw OOME:
             rowAAChunk.resize(INITIAL_CHUNK_ARRAY);
         }
-        if (doCleanDirty) {
+        if (DO_CLEAN_DIRTY) {
             // Force zero-fill dirty arrays:
             rowAAChunk.fill(BYTE_0);
         }
@@ -217,15 +217,15 @@
         bboxY0 = pminY;
 
         // reset current pos
-        if (doStats) {
-            RendererContext.stats.stat_cache_rowAAChunk.add(rowAAChunkPos);
+        if (DO_STATS) {
+            rdrCtx.stats.stat_cache_rowAAChunk.add(rowAAChunkPos);
         }
         rowAAChunkPos = 0L;
 
         // Reset touchedTile:
         if (tileMin != Integer.MAX_VALUE) {
-            if (doStats) {
-                RendererContext.stats.stat_cache_tiles.add(tileMax - tileMin);
+            if (DO_STATS) {
+                rdrCtx.stats.stat_cache_tiles.add(tileMax - tileMin);
             }
             // clean only dirty touchedTile:
             if (tileMax == 1) {
@@ -238,7 +238,7 @@
             tileMax = Integer.MIN_VALUE;
         }
 
-        if (doCleanDirty) {
+        if (DO_CLEAN_DIRTY) {
             // Force zero-fill dirty arrays:
             rowAAChunk.fill(BYTE_0);
         }
@@ -267,14 +267,14 @@
     void copyAARowNoRLE(final int[] alphaRow, final int y,
                    final int px0, final int px1)
     {
-        if (doMonitors) {
-            RendererContext.stats.mon_rdr_copyAARow.start();
+        if (DO_MONITORS) {
+            rdrCtx.stats.mon_rdr_copyAARow.start();
         }
 
         // skip useless pixels above boundary
         final int px_bbox1 = FloatMath.min(px1, bboxX1);
 
-        if (doLogBounds) {
+        if (DO_LOG_BOUNDS) {
             MarlinUtils.logInfo("row = [" + px0 + " ... " + px_bbox1
                                 + " (" + px1 + ") [ for y=" + y);
         }
@@ -305,8 +305,8 @@
         if (_rowAAChunk.length < needSize) {
             expandRowAAChunk(needSize);
         }
-        if (doStats) {
-            RendererContext.stats.stat_cache_rowAA.add(px_bbox1 - px0);
+        if (DO_STATS) {
+            rdrCtx.stats.stat_cache_rowAA.add(px_bbox1 - px0);
         }
 
         // rowAA contains only alpha values for range[x0; x1[
@@ -316,7 +316,7 @@
         final int from = px0      - bboxX0; // first pixel inclusive
         final int to   = px_bbox1 - bboxX0; //  last pixel exclusive
 
-        final Unsafe _unsafe = OffHeapArray.unsafe;
+        final Unsafe _unsafe = OffHeapArray.UNSAFE;
         final long SIZE_BYTE = 1L;
         final long addr_alpha = ALPHA_MAP_UNSAFE.address;
         long addr_off = _rowAAChunk.address + pos;
@@ -361,23 +361,23 @@
             tileMax = tx;
         }
 
-        if (doLogBounds) {
+        if (DO_LOG_BOUNDS) {
             MarlinUtils.logInfo("clear = [" + from + " ... " + to + "[");
         }
 
         // Clear alpha row for reuse:
         IntArrayCache.fill(alphaRow, from, px1 - bboxX0, 0);
 
-        if (doMonitors) {
-            RendererContext.stats.mon_rdr_copyAARow.stop();
+        if (DO_MONITORS) {
+            rdrCtx.stats.mon_rdr_copyAARow.stop();
         }
     }
 
     void copyAARowRLE_WithBlockFlags(final int[] blkFlags, final int[] alphaRow,
                       final int y, final int px0, final int px1)
     {
-        if (doMonitors) {
-            RendererContext.stats.mon_rdr_copyAARow.start();
+        if (DO_MONITORS) {
+            rdrCtx.stats.mon_rdr_copyAARow.start();
         }
 
         // Copy rowAA data into the piscesCache if one is present
@@ -391,7 +391,7 @@
         final int px_bbox1 = FloatMath.min(px1, bboxX1);
         final int to       = px_bbox1 - _bboxX0; //  last pixel exclusive
 
-        if (doLogBounds) {
+        if (DO_LOG_BOUNDS) {
             MarlinUtils.logInfo("row = [" + px0 + " ... " + px_bbox1
                                 + " (" + px1 + ") [ for y=" + y);
         }
@@ -410,7 +410,7 @@
             expandRowAAChunk(needSize);
         }
 
-        final Unsafe _unsafe = OffHeapArray.unsafe;
+        final Unsafe _unsafe = OffHeapArray.UNSAFE;
         final long SIZE_INT = 4L;
         final long addr_alpha = ALPHA_MAP_UNSAFE.address;
         long addr_off = _rowAAChunk.address + initialPos;
@@ -465,7 +465,7 @@
                             // note: it should check X is smaller than 23bits (overflow)!
 
                             // check address alignment to 4 bytes:
-                            if (doCheckUnsafe) {
+                            if (DO_CHECK_UNSAFE) {
                                 if ((addr_off & 3) != 0) {
                                     MarlinUtils.logInfo("Misaligned Unsafe address: " + addr_off);
                                 }
@@ -490,8 +490,8 @@
                             }
                             addr_off += SIZE_INT;
 
-                            if (doStats) {
-                                RendererContext.stats.hist_tile_generator_encoding_runLen
+                            if (DO_STATS) {
+                                rdrCtx.stats.hist_tile_generator_encoding_runLen
                                     .add(runLen);
                             }
                             cx0 = cx;
@@ -513,7 +513,7 @@
                         }
                     }
                 }
-            } else if (doStats) {
+            } else if (DO_STATS) {
                 skip++;
             }
         }
@@ -528,7 +528,7 @@
         // note: it should check X is smaller than 23bits (overflow)!
 
         // check address alignment to 4 bytes:
-        if (doCheckUnsafe) {
+        if (DO_CHECK_UNSAFE) {
             if ((addr_off & 3) != 0) {
                 MarlinUtils.logInfo("Misaligned Unsafe address: " + addr_off);
             }
@@ -553,8 +553,8 @@
         }
         addr_off += SIZE_INT;
 
-        if (doStats) {
-            RendererContext.stats.hist_tile_generator_encoding_runLen
+        if (DO_STATS) {
+            rdrCtx.stats.hist_tile_generator_encoding_runLen
                 .add(runLen);
         }
 
@@ -566,9 +566,9 @@
         // update current position:
         rowAAChunkPos = len;
 
-        if (doStats) {
-            RendererContext.stats.stat_cache_rowAA.add(rowAALen[row]);
-            RendererContext.stats.hist_tile_generator_encoding_ratio.add(
+        if (DO_STATS) {
+            rdrCtx.stats.stat_cache_rowAA.add(rowAALen[row]);
+            rdrCtx.stats.hist_tile_generator_encoding_ratio.add(
                 (100 * skip) / (blkE - blkW)
             );
         }
@@ -589,13 +589,13 @@
             alphaRow[to    ] = 0;
             alphaRow[to + 1] = 0;
         }
-        if (doChecks) {
+        if (DO_CHECKS) {
             IntArrayCache.check(blkFlags, blkW, blkE, 0);
             IntArrayCache.check(alphaRow, from, px1 - bboxX0, 0);
         }
 
-        if (doMonitors) {
-            RendererContext.stats.mon_rdr_copyAARow.stop();
+        if (DO_MONITORS) {
+            rdrCtx.stats.mon_rdr_copyAARow.stop();
         }
     }
 
@@ -611,8 +611,8 @@
     }
 
     private void expandRowAAChunk(final long needSize) {
-        if (doStats) {
-            RendererContext.stats.stat_array_marlincache_rowAAChunk
+        if (DO_STATS) {
+            rdrCtx.stats.stat_array_marlincache_rowAAChunk
                 .add(needSize);
         }
 
diff --git a/src/share/classes/sun/java2d/marlin/MarlinConst.java b/src/share/classes/sun/java2d/marlin/MarlinConst.java
--- a/src/share/classes/sun/java2d/marlin/MarlinConst.java
+++ b/src/share/classes/sun/java2d/marlin/MarlinConst.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2016, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -30,54 +30,55 @@
  */
 interface MarlinConst {
     // enable Logs (logger or stdout)
-    static final boolean enableLogs = MarlinProperties.isLoggingEnabled();
+    static final boolean ENABLE_LOGS = MarlinProperties.isLoggingEnabled();
     // use Logger instead of stdout
-    static final boolean useLogger = enableLogs && MarlinProperties.isUseLogger();
+    static final boolean USE_LOGGER = ENABLE_LOGS && MarlinProperties.isUseLogger();
 
     // log new RendererContext
-    static final boolean logCreateContext = enableLogs
+    static final boolean LOG_CREATE_CONTEXT = ENABLE_LOGS
         && MarlinProperties.isLogCreateContext();
     // log misc.Unsafe alloc/realloc/free
-    static final boolean logUnsafeMalloc = enableLogs
+    static final boolean LOG_UNSAFE_MALLOC = ENABLE_LOGS
         && MarlinProperties.isLogUnsafeMalloc();
     // do check unsafe alignment:
-    static final boolean doCheckUnsafe = false;
+    static final boolean DO_CHECK_UNSAFE = false;
 
     // do statistics
-    static final boolean doStats = enableLogs && MarlinProperties.isDoStats();
+    static final boolean DO_STATS = ENABLE_LOGS && MarlinProperties.isDoStats();
     // do monitors
     // disabled to reduce byte-code size a bit...
-    static final boolean doMonitors = false;
-//    static final boolean doMonitors = enableLogs && MarlinProperties.isDoMonitors();
+    static final boolean DO_MONITORS = false;
+//    static final boolean DO_MONITORS = ENABLE_LOGS && MarlinProperties.isDoMonitors();
     // do checks
-    static final boolean doChecks = enableLogs && MarlinProperties.isDoChecks();
+    static final boolean DO_CHECKS = ENABLE_LOGS && MarlinProperties.isDoChecks();
 
     // do AA range checks: disable when algorithm / code is stable
     static final boolean DO_AA_RANGE_CHECK = false;
 
     // enable logs
-    static final boolean doLogWidenArray = enableLogs && false;
+    static final boolean DO_LOG_WIDEN_ARRAY = ENABLE_LOGS && false;
     // enable oversize logs
-    static final boolean doLogOverSize = enableLogs && false;
+    static final boolean DO_LOG_OVERSIZE = ENABLE_LOGS && false;
     // enable traces
-    static final boolean doTrace = enableLogs && false;
+    static final boolean DO_TRACE = ENABLE_LOGS && false;
+
     // do flush monitors
-    static final boolean doFlushMonitors = true;
+    static final boolean DO_FLUSH_MONITORS = true;
     // use one polling thread to dump statistics/monitors
-    static final boolean useDumpThread = false;
+    static final boolean USE_DUMP_THREAD = false;
     // thread dump interval (ms)
-    static final long statDump = 5000L;
+    static final long DUMP_INTERVAL = 5000L;
 
     // do clean dirty array
-    static final boolean doCleanDirty = false;
+    static final boolean DO_CLEAN_DIRTY = false;
 
     // flag to use line simplifier
-    static final boolean useSimplifier = MarlinProperties.isUseSimplifier();
+    static final boolean USE_SIMPLIFIER = MarlinProperties.isUseSimplifier();
 
     // flag to enable logs related bounds checks
-    static final boolean doLogBounds = enableLogs && false;
+    static final boolean DO_LOG_BOUNDS = ENABLE_LOGS && false;
 
-    // Initial Array sizing (initial context capacity) ~ 512K
+    // Initial Array sizing (initial context capacity) ~ 350K
 
     // 2048 pixel (width x height) for initial capacity
     static final int INITIAL_PIXEL_DIM
@@ -88,8 +89,6 @@
     static final int INITIAL_SMALL_ARRAY  = 1024;
     static final int INITIAL_MEDIUM_ARRAY = 4096;
     static final int INITIAL_LARGE_ARRAY  = 8192;
-    static final int INITIAL_ARRAY_16K    = 16384;
-    static final int INITIAL_ARRAY_32K    = 32768;
     // alpha row dimension
     static final int INITIAL_AA_ARRAY     = INITIAL_PIXEL_DIM;
 
diff --git a/src/share/classes/sun/java2d/marlin/MarlinRenderingEngine.java b/src/share/classes/sun/java2d/marlin/MarlinRenderingEngine.java
--- a/src/share/classes/sun/java2d/marlin/MarlinRenderingEngine.java
+++ b/src/share/classes/sun/java2d/marlin/MarlinRenderingEngine.java
@@ -85,7 +85,7 @@
                                     int caps,
                                     int join,
                                     float miterlimit,
-                                    float dashes[],
+                                    float[] dashes,
                                     float dashphase)
     {
         final RendererContext rdrCtx = getRendererContext();
@@ -278,7 +278,7 @@
                         int caps,
                         int join,
                         float miterlimit,
-                        float dashes[],
+                        float[] dashes,
                         float dashphase,
                         PathConsumer2D pc2d)
     {
@@ -340,8 +340,8 @@
                     if (dashLen <= INITIAL_ARRAY) {
                         newDashes = rdrCtx.dasher.dashes_initial;
                     } else {
-                        if (doStats) {
-                            RendererContext.stats.stat_array_dasher_dasher
+                        if (DO_STATS) {
+                            rdrCtx.stats.stat_array_dasher_dasher
                                 .add(dashLen);
                         }
                         newDashes = rdrCtx.getDirtyFloatArray(dashLen);
@@ -380,7 +380,7 @@
             at = null;
         }
 
-        if (useSimplifier) {
+        if (USE_SIMPLIFIER) {
             // Use simplifier after stroker before Renderer
             // to remove collinear segments (notably due to cap square)
             pc2d = rdrCtx.simplifier.init(pc2d);
@@ -474,9 +474,6 @@
 
         @Override
         public final int currentSegment(final float[] coords) {
-            if (doMonitors) {
-                RendererContext.stats.mon_npi_currentSegment.start();
-            }
             int lastCoord;
             final int type = src.currentSegment(coords);
 
@@ -495,17 +492,11 @@
                     // we don't want to deal with this case later. We just exit now
                     curx_adjust = movx_adjust;
                     cury_adjust = movy_adjust;
-
-                    if (doMonitors) {
-                        RendererContext.stats.mon_npi_currentSegment.stop();
-                    }
                     return type;
                 default:
                     throw new InternalError("Unrecognized curve type");
             }
 
-            // TODO: handle NaN, Inf and overflow
-
             // normalize endpoint
             float coord, x_adjust, y_adjust;
 
@@ -543,10 +534,6 @@
             }
             curx_adjust = x_adjust;
             cury_adjust = y_adjust;
-
-            if (doMonitors) {
-                RendererContext.stats.mon_npi_currentSegment.stop();
-            }
             return type;
         }
 
@@ -790,7 +777,7 @@
                                               BasicStroke bs,
                                               boolean thin,
                                               boolean normalize,
-                                              int bbox[])
+                                              int[] bbox)
     {
         MarlinTileGenerator ptg = null;
         Renderer r = null;
@@ -808,6 +795,7 @@
                 final PathIterator pi = getNormalizingPathIterator(rdrCtx, norm,
                                             s.getPathIterator(_at));
 
+                // note: Winding rule may be EvenOdd ONLY for fill operations !
                 r = rdrCtx.renderer.init(clip.getLoX(), clip.getLoY(),
                                          clip.getWidth(), clip.getHeight(),
                                          pi.getWindingRule());
@@ -848,7 +836,7 @@
                                                     double dx2, double dy2,
                                                     double lw1, double lw2,
                                                     Region clip,
-                                                    int bbox[])
+                                                    int[] bbox)
     {
         // REMIND: Deal with large coordinates!
         double ldx1, ldy1, ldx2, ldy2;
@@ -949,17 +937,17 @@
 
     // --- RendererContext handling ---
     // use ThreadLocal or ConcurrentLinkedQueue to get one RendererContext
-    private static final boolean useThreadLocal;
+    private static final boolean USE_THREAD_LOCAL;
 
     // reference type stored in either TL or CLQ
     static final int REF_TYPE;
 
     // Per-thread RendererContext
-    private static final ReentrantContextProvider<RendererContext> rdrCtxProvider;
+    private static final ReentrantContextProvider<RendererContext> RDR_CTX_PROVIDER;
 
     // Static initializer to use TL or CLQ mode
     static {
-        useThreadLocal = MarlinProperties.isUseThreadLocal();
+        USE_THREAD_LOCAL = MarlinProperties.isUseThreadLocal();
 
         // Soft reference by default:
         final String refType = AccessController.doPrivileged(
@@ -978,8 +966,8 @@
                 break;
         }
 
-        if (useThreadLocal) {
-            rdrCtxProvider = new ReentrantContextProviderTL<RendererContext>(REF_TYPE)
+        if (USE_THREAD_LOCAL) {
+            RDR_CTX_PROVIDER = new ReentrantContextProviderTL<RendererContext>(REF_TYPE)
                 {
                     @Override
                     protected RendererContext newContext() {
@@ -987,7 +975,7 @@
                     }
                 };
         } else {
-            rdrCtxProvider = new ReentrantContextProviderCLQ<RendererContext>(REF_TYPE)
+            RDR_CTX_PROVIDER = new ReentrantContextProviderCLQ<RendererContext>(REF_TYPE)
                 {
                     @Override
                     protected RendererContext newContext() {
@@ -997,14 +985,14 @@
         }
     }
 
-    private static boolean settingsLogged = !enableLogs;
+    private static boolean SETTINGS_LOGGED = !ENABLE_LOGS;
 
     private static void logSettings(final String reClass) {
         // log information at startup
-        if (settingsLogged) {
+        if (SETTINGS_LOGGED) {
             return;
         }
-        settingsLogged = true;
+        SETTINGS_LOGGED = true;
 
         String refType;
         switch (REF_TYPE) {
@@ -1029,7 +1017,7 @@
         logInfo("sun.java2d.renderer                  = "
                 + reClass);
         logInfo("sun.java2d.renderer.useThreadLocal   = "
-                + useThreadLocal);
+                + USE_THREAD_LOCAL);
         logInfo("sun.java2d.renderer.useRef           = "
                 + refType);
 
@@ -1063,23 +1051,23 @@
 
         // optimisation parameters
         logInfo("sun.java2d.renderer.useSimplifier    = "
-                + MarlinConst.useSimplifier);
+                + MarlinConst.USE_SIMPLIFIER);
 
         // debugging parameters
         logInfo("sun.java2d.renderer.doStats          = "
-                + MarlinConst.doStats);
+                + MarlinConst.DO_STATS);
         logInfo("sun.java2d.renderer.doMonitors       = "
-                + MarlinConst.doMonitors);
+                + MarlinConst.DO_MONITORS);
         logInfo("sun.java2d.renderer.doChecks         = "
-                + MarlinConst.doChecks);
+                + MarlinConst.DO_CHECKS);
 
         // logging parameters
         logInfo("sun.java2d.renderer.useLogger        = "
-                + MarlinConst.useLogger);
+                + MarlinConst.USE_LOGGER);
         logInfo("sun.java2d.renderer.logCreateContext = "
-                + MarlinConst.logCreateContext);
+                + MarlinConst.LOG_CREATE_CONTEXT);
         logInfo("sun.java2d.renderer.logUnsafeMalloc  = "
-                + MarlinConst.logUnsafeMalloc);
+                + MarlinConst.LOG_UNSAFE_MALLOC);
 
         // quality settings
         logInfo("Renderer settings:");
@@ -1098,9 +1086,9 @@
      */
     @SuppressWarnings({"unchecked"})
     static RendererContext getRendererContext() {
-        final RendererContext rdrCtx = rdrCtxProvider.acquire();
-        if (doMonitors) {
-            RendererContext.stats.mon_pre_getAATileGenerator.start();
+        final RendererContext rdrCtx = RDR_CTX_PROVIDER.acquire();
+        if (DO_MONITORS) {
+            rdrCtx.stats.mon_pre_getAATileGenerator.start();
         }
         return rdrCtx;
     }
@@ -1112,9 +1100,9 @@
     static void returnRendererContext(final RendererContext rdrCtx) {
         rdrCtx.dispose();
 
-        if (doMonitors) {
-            RendererContext.stats.mon_pre_getAATileGenerator.stop();
+        if (DO_MONITORS) {
+            rdrCtx.stats.mon_pre_getAATileGenerator.stop();
         }
-        rdrCtxProvider.release(rdrCtx);
+        RDR_CTX_PROVIDER.release(rdrCtx);
     }
 }
diff --git a/src/share/classes/sun/java2d/marlin/MarlinTileGenerator.java b/src/share/classes/sun/java2d/marlin/MarlinTileGenerator.java
--- a/src/share/classes/sun/java2d/marlin/MarlinTileGenerator.java
+++ b/src/share/classes/sun/java2d/marlin/MarlinTileGenerator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007, 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2016, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -37,9 +37,13 @@
     private final MarlinCache cache;
     private int x, y;
 
+    // per-thread renderer context
+    final RendererContext rdrCtx;
+
     MarlinTileGenerator(Renderer r) {
         this.rdr = r;
         this.cache = r.cache;
+        this.rdrCtx = r.rdrCtx;
     }
 
     MarlinTileGenerator init() {
@@ -55,19 +59,19 @@
      */
     @Override
     public void dispose() {
-        if (doMonitors) {
+        if (DO_MONITORS) {
             // called from AAShapePipe.renderTiles() (render tiles end):
-            RendererContext.stats.mon_pipe_renderTiles.stop();
+            rdrCtx.stats.mon_pipe_renderTiles.stop();
         }
         // dispose cache:
         cache.dispose();
         // dispose renderer:
         rdr.dispose();
         // recycle the RendererContext instance
-        MarlinRenderingEngine.returnRendererContext(rdr.rdrCtx);
+        MarlinRenderingEngine.returnRendererContext(rdrCtx);
     }
 
-    void getBbox(int bbox[]) {
+    void getBbox(int[] bbox) {
         bbox[0] = cache.bboxX0;
         bbox[1] = cache.bboxY0;
         bbox[2] = cache.bboxX1;
@@ -80,9 +84,9 @@
      */
     @Override
     public int getTileWidth() {
-        if (doMonitors) {
+        if (DO_MONITORS) {
             // called from AAShapePipe.renderTiles() (render tiles start):
-            RendererContext.stats.mon_pipe_renderTiles.start();
+            rdrCtx.stats.mon_pipe_renderTiles.start();
         }
         return TILE_SIZE;
     }
@@ -126,8 +130,8 @@
         // values anyway.
         final int alpha = (al == 0x00 ? 0x00
                               : (al == MAX_TILE_ALPHA_SUM ? 0xff : 0x80));
-        if (doStats) {
-            RendererContext.stats.hist_tile_generator_alpha.add(alpha);
+        if (DO_STATS) {
+            rdrCtx.stats.hist_tile_generator_alpha.add(alpha);
         }
         return alpha;
     }
@@ -157,7 +161,7 @@
      * once per tile, but not both.
      */
     @Override
-    public void getAlpha(final byte tile[], final int offset,
+    public void getAlpha(final byte[] tile, final int offset,
                                             final int rowstride)
     {
         if (cache.useRLE) {
@@ -172,11 +176,11 @@
      * Either this method, or the nextTile() method should be called
      * once per tile, but not both.
      */
-    private void getAlphaNoRLE(final byte tile[], final int offset,
+    private void getAlphaNoRLE(final byte[] tile, final int offset,
                                final int rowstride)
     {
-        if (doMonitors) {
-            RendererContext.stats.mon_ptg_getAlpha.start();
+        if (DO_MONITORS) {
+            rdrCtx.stats.mon_ptg_getAlpha.start();
         }
 
         // local vars for performance:
@@ -192,12 +196,12 @@
         final int y0 = 0;
         final int y1 = FloatMath.min(this.y + TILE_SIZE, _cache.bboxY1) - this.y;
 
-        if (doLogBounds) {
+        if (DO_LOG_BOUNDS) {
             MarlinUtils.logInfo("getAlpha = [" + x0 + " ... " + x1
                                 + "[ [" + y0 + " ... " + y1 + "[");
         }
 
-        final Unsafe _unsafe = OffHeapArray.unsafe;
+        final Unsafe _unsafe = OffHeapArray.UNSAFE;
         final long SIZE = 1L;
         final long addr_rowAA = _cache.rowAAChunk.address;
         long addr;
@@ -252,7 +256,7 @@
                 cx++;
             }
 
-            if (doTrace) {
+            if (DO_TRACE) {
                 for (int i = idx - (x1 - x0); i < idx; i++) {
                     System.out.print(hex(tile[i], 2));
                 }
@@ -264,8 +268,8 @@
 
         nextTile();
 
-        if (doMonitors) {
-            RendererContext.stats.mon_ptg_getAlpha.stop();
+        if (DO_MONITORS) {
+            rdrCtx.stats.mon_ptg_getAlpha.stop();
         }
     }
 
@@ -274,11 +278,11 @@
      * Either this method, or the nextTile() method should be called
      * once per tile, but not both.
      */
-    private void getAlphaRLE(final byte tile[], final int offset,
+    private void getAlphaRLE(final byte[] tile, final int offset,
                              final int rowstride)
     {
-        if (doMonitors) {
-            RendererContext.stats.mon_ptg_getAlpha.start();
+        if (DO_MONITORS) {
+            rdrCtx.stats.mon_ptg_getAlpha.start();
         }
 
         // Decode run-length encoded alpha mask data
@@ -302,12 +306,12 @@
         final int y0 = 0;
         final int y1 = FloatMath.min(this.y + TILE_SIZE, _cache.bboxY1) - this.y;
 
-        if (doLogBounds) {
+        if (DO_LOG_BOUNDS) {
             MarlinUtils.logInfo("getAlpha = [" + x0 + " ... " + x1
                                 + "[ [" + y0 + " ... " + y1 + "[");
         }
 
-        final Unsafe _unsafe = OffHeapArray.unsafe;
+        final Unsafe _unsafe = OffHeapArray.UNSAFE;
         final long SIZE_BYTE = 1L;
         final long SIZE_INT = 4L;
         final long addr_rowAA = _cache.rowAAChunk.address;
@@ -438,7 +442,7 @@
                 cx++;
             }
 
-            if (doTrace) {
+            if (DO_TRACE) {
                 for (int i = idx - (x1 - x0); i < idx; i++) {
                     System.out.print(hex(tile[i], 2));
                 }
@@ -450,8 +454,8 @@
 
         nextTile();
 
-        if (doMonitors) {
-            RendererContext.stats.mon_ptg_getAlpha.stop();
+        if (DO_MONITORS) {
+            rdrCtx.stats.mon_ptg_getAlpha.stop();
         }
     }
 
diff --git a/src/share/classes/sun/java2d/marlin/MarlinUtils.java b/src/share/classes/sun/java2d/marlin/MarlinUtils.java
--- a/src/share/classes/sun/java2d/marlin/MarlinUtils.java
+++ b/src/share/classes/sun/java2d/marlin/MarlinUtils.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2016, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -28,13 +28,13 @@
 
 public final class MarlinUtils {
     // Marlin logger
-    private static final sun.util.logging.PlatformLogger log;
+    private static final sun.util.logging.PlatformLogger LOG;
 
     static {
-        if (MarlinConst.useLogger) {
-            log = sun.util.logging.PlatformLogger.getLogger("sun.java2d.marlin");
+        if (MarlinConst.USE_LOGGER) {
+            LOG = sun.util.logging.PlatformLogger.getLogger("sun.java2d.marlin");
         } else {
-            log = null;
+            LOG = null;
         }
     }
 
@@ -43,18 +43,18 @@
     }
 
     public static void logInfo(final String msg) {
-        if (MarlinConst.useLogger) {
-            log.info(msg);
-        } else if (MarlinConst.enableLogs) {
+        if (MarlinConst.USE_LOGGER) {
+            LOG.info(msg);
+        } else if (MarlinConst.ENABLE_LOGS) {
             System.out.print("INFO: ");
             System.out.println(msg);
         }
     }
 
     public static void logException(final String msg, final Throwable th) {
-        if (MarlinConst.useLogger) {
-            log.warning(msg, th);
-        } else if (MarlinConst.enableLogs) {
+        if (MarlinConst.USE_LOGGER) {
+            LOG.warning(msg, th);
+        } else if (MarlinConst.ENABLE_LOGS) {
             System.out.print("WARNING: ");
             System.out.println(msg);
             th.printStackTrace(System.err);
diff --git a/src/share/classes/sun/java2d/marlin/OffHeapArray.java b/src/share/classes/sun/java2d/marlin/OffHeapArray.java
--- a/src/share/classes/sun/java2d/marlin/OffHeapArray.java
+++ b/src/share/classes/sun/java2d/marlin/OffHeapArray.java
@@ -25,7 +25,7 @@
 
 package sun.java2d.marlin;
 
-import static sun.java2d.marlin.MarlinConst.logUnsafeMalloc;
+import static sun.java2d.marlin.MarlinConst.LOG_UNSAFE_MALLOC;
 import jdk.internal.misc.Unsafe;
 import jdk.internal.ref.CleanerFactory;
 
@@ -36,12 +36,12 @@
 final class OffHeapArray  {
 
     // unsafe reference
-    static final Unsafe unsafe;
+    static final Unsafe UNSAFE;
     // size of int / float
     static final int SIZE_INT;
 
     static {
-        unsafe   = Unsafe.getUnsafe();
+        UNSAFE   = Unsafe.getUnsafe();
         SIZE_INT = Unsafe.ARRAY_INT_INDEX_SCALE;
     }
 
@@ -52,10 +52,10 @@
 
     OffHeapArray(final Object parent, final long len) {
         // note: may throw OOME:
-        this.address = unsafe.allocateMemory(len);
+        this.address = UNSAFE.allocateMemory(len);
         this.length  = len;
         this.used    = 0;
-        if (logUnsafeMalloc) {
+        if (LOG_UNSAFE_MALLOC) {
             MarlinUtils.logInfo(System.currentTimeMillis()
                                 + ": OffHeapArray.allocateMemory =   "
                                 + len + " to addr = " + this.address);
@@ -72,9 +72,9 @@
      */
     void resize(final long len) {
         // note: may throw OOME:
-        this.address = unsafe.reallocateMemory(address, len);
+        this.address = UNSAFE.reallocateMemory(address, len);
         this.length  = len;
-        if (logUnsafeMalloc) {
+        if (LOG_UNSAFE_MALLOC) {
             MarlinUtils.logInfo(System.currentTimeMillis()
                                 + ": OffHeapArray.reallocateMemory = "
                                 + len + " to addr = " + this.address);
@@ -82,8 +82,8 @@
     }
 
     void free() {
-        unsafe.freeMemory(this.address);
-        if (logUnsafeMalloc) {
+        UNSAFE.freeMemory(this.address);
+        if (LOG_UNSAFE_MALLOC) {
             MarlinUtils.logInfo(System.currentTimeMillis()
                                 + ": OffHeapArray.freeMemory =       "
                                 + this.length
@@ -92,6 +92,6 @@
     }
 
     void fill(final byte val) {
-        unsafe.setMemory(this.address, this.length, val);
+        UNSAFE.setMemory(this.address, this.length, val);
     }
 }
diff --git a/src/share/classes/sun/java2d/marlin/Renderer.java b/src/share/classes/sun/java2d/marlin/Renderer.java
--- a/src/share/classes/sun/java2d/marlin/Renderer.java
+++ b/src/share/classes/sun/java2d/marlin/Renderer.java
@@ -189,8 +189,8 @@
             maxDD /= 4f; // error divided by 2^2 = 4
 
             count <<= 1;
-            if (doStats) {
-                RendererContext.stats.stat_rdr_quadBreak_dec.add(count);
+            if (DO_STATS) {
+                rdrCtx.stats.stat_rdr_quadBreak_dec.add(count);
             }
         }
 
@@ -214,15 +214,15 @@
 
                 addLine(x0, y0, x1, y1);
 
-                if (doStats) { nL++; }
+                if (DO_STATS) { nL++; }
                 x0 = x1;
                 y0 = y1;
             }
         }
         addLine(x0, y0, x2, y2);
 
-        if (doStats) {
-            RendererContext.stats.stat_rdr_quadBreak.add(nL + 1);
+        if (DO_STATS) {
+            rdrCtx.stats.stat_rdr_quadBreak.add(nL + 1);
         }
     }
 
@@ -268,8 +268,8 @@
                 dy = (dy - ddy) / 2f;
 
                 count <<= 1;
-                if (doStats) {
-                    RendererContext.stats.stat_rdr_curveBreak_dec.add(count);
+                if (DO_STATS) {
+                    rdrCtx.stats.stat_rdr_curveBreak_dec.add(count);
                 }
             }
 
@@ -289,8 +289,8 @@
                 dddy *= 8f;
 
                 count >>= 1;
-                if (doStats) {
-                    RendererContext.stats.stat_rdr_curveBreak_inc.add(count);
+                if (DO_STATS) {
+                    rdrCtx.stats.stat_rdr_curveBreak_inc.add(count);
                 }
             }
             if (--count > 0) {
@@ -307,21 +307,21 @@
 
             addLine(x0, y0, x1, y1);
 
-            if (doStats) { nL++; }
+            if (DO_STATS) { nL++; }
             x0 = x1;
             y0 = y1;
         }
-        if (doStats) {
-            RendererContext.stats.stat_rdr_curveBreak.add(nL);
+        if (DO_STATS) {
+            rdrCtx.stats.stat_rdr_curveBreak.add(nL);
         }
     }
 
     private void addLine(float x1, float y1, float x2, float y2) {
-        if (doMonitors) {
-            RendererContext.stats.mon_rdr_addLine.start();
+        if (DO_MONITORS) {
+            rdrCtx.stats.mon_rdr_addLine.start();
         }
-        if (doStats) {
-            RendererContext.stats.stat_rdr_addLine.add(1);
+        if (DO_STATS) {
+            rdrCtx.stats.stat_rdr_addLine.add(1);
         }
         int or = 1; // orientation of the line. 1 if y increases, 0 otherwise.
         if (y2 < y1) {
@@ -349,11 +349,11 @@
         /* skip horizontal lines in pixel space and clip edges
            out of y range [boundsMinY; boundsMaxY] */
         if (firstCrossing >= lastCrossing) {
-            if (doMonitors) {
-                RendererContext.stats.mon_rdr_addLine.stop();
+            if (DO_MONITORS) {
+                rdrCtx.stats.mon_rdr_addLine.stop();
             }
-            if (doStats) {
-                RendererContext.stats.stat_rdr_addLine_skip.add(1);
+            if (DO_STATS) {
+                rdrCtx.stats.stat_rdr_addLine_skip.add(1);
             }
             return;
         }
@@ -405,14 +405,14 @@
             final long edgeNewSize = ArrayCache.getNewLargeSize(_edges.length,
                                         edgePtr + _SIZEOF_EDGE_BYTES);
 
-            if (doStats) {
-                RendererContext.stats.stat_rdr_edges_resizes.add(edgeNewSize);
+            if (DO_STATS) {
+                rdrCtx.stats.stat_rdr_edges_resizes.add(edgeNewSize);
             }
             _edges.resize(edgeNewSize);
         }
 
 
-        final Unsafe _unsafe = OffHeapArray.unsafe;
+        final Unsafe _unsafe = OffHeapArray.UNSAFE;
         final long SIZE_INT = 4L;
         long addr   = _edges.address + edgePtr;
 
@@ -486,8 +486,8 @@
         // update free pointer (ie length in bytes)
         _edges.used += _SIZEOF_EDGE_BYTES;
 
-        if (doMonitors) {
-            RendererContext.stats.mon_rdr_addLine.stop();
+        if (DO_MONITORS) {
+            rdrCtx.stats.mon_rdr_addLine.stop();
         }
     }
 
@@ -552,7 +552,7 @@
         this.boundsMaxY =
             (pix_boundsY + pix_boundsHeight) << SUBPIXEL_LG_POSITIONS_Y;
 
-        if (doLogBounds) {
+        if (DO_LOG_BOUNDS) {
             MarlinUtils.logInfo("boundsXY = [" + boundsMinX + " ... "
                                 + boundsMaxX + "[ [" + boundsMinY + " ... "
                                 + boundsMaxY + "[");
@@ -563,10 +563,10 @@
         final int edgeBucketsLength = (boundsMaxY - boundsMinY) + 1;
 
         if (edgeBucketsLength > INITIAL_BUCKET_ARRAY) {
-            if (doStats) {
-                RendererContext.stats.stat_array_renderer_edgeBuckets
+            if (DO_STATS) {
+                rdrCtx.stats.stat_array_renderer_edgeBuckets
                     .add(edgeBucketsLength);
-                RendererContext.stats.stat_array_renderer_edgeBucketCounts
+                rdrCtx.stats.stat_array_renderer_edgeBucketCounts
                     .add(edgeBucketsLength);
             }
             edgeBuckets = rdrCtx.getIntArray(edgeBucketsLength);
@@ -592,13 +592,13 @@
      * Disposes this renderer and recycle it clean up before reusing this instance
      */
     void dispose() {
-        if (doStats) {
-            RendererContext.stats.stat_rdr_activeEdges.add(activeEdgeMaxUsed);
-            RendererContext.stats.stat_rdr_edges.add(edges.used);
-            RendererContext.stats.stat_rdr_edges_count
+        if (DO_STATS) {
+            rdrCtx.stats.stat_rdr_activeEdges.add(activeEdgeMaxUsed);
+            rdrCtx.stats.stat_rdr_edges.add(edges.used);
+            rdrCtx.stats.stat_rdr_edges_count
                 .add(edges.used / SIZEOF_EDGE_BYTES);
         }
-        if (doCleanDirty) {
+        if (DO_CLEAN_DIRTY) {
             // Force zero-fill dirty arrays:
             Arrays.fill(crossings,     0);
             Arrays.fill(aux_crossings, 0);
@@ -670,12 +670,12 @@
             // note: may throw OOME:
             edges.resize(INITIAL_EDGES_CAPACITY);
         }
-        if (doCleanDirty) {
+        if (DO_CLEAN_DIRTY) {
             // Force zero-fill dirty arrays:
             edges.fill(BYTE_0);
         }
-        if (doMonitors) {
-            RendererContext.stats.mon_rdr_endRendering.stop();
+        if (DO_MONITORS) {
+            rdrCtx.stats.mon_rdr_endRendering.stop();
         }
     }
 
@@ -793,7 +793,7 @@
         final int _ERR_STEP_MAX  = ERR_STEP_MAX;
 
         // unsafe I/O:
-        final Unsafe _unsafe = OffHeapArray.unsafe;
+        final Unsafe _unsafe = OffHeapArray.UNSAFE;
         final long    addr0  = _edges.address;
         long addr;
         final int _SUBPIXEL_LG_POSITIONS_X = SUBPIXEL_LG_POSITIONS_X;
@@ -856,8 +856,8 @@
 
             // bucketCount indicates new edge / edge end:
             if (bucketcount != 0) {
-                if (doStats) {
-                    RendererContext.stats.stat_rdr_activeEdges_updates
+                if (DO_STATS) {
+                    rdrCtx.stats.stat_rdr_activeEdges_updates
                         .add(numCrossings);
                 }
 
@@ -882,19 +882,19 @@
                 ptrLen = bucketcount >> 1; // number of new edge
 
                 if (ptrLen != 0) {
-                    if (doStats) {
-                        RendererContext.stats.stat_rdr_activeEdges_adds
+                    if (DO_STATS) {
+                        rdrCtx.stats.stat_rdr_activeEdges_adds
                             .add(ptrLen);
                         if (ptrLen > 10) {
-                            RendererContext.stats.stat_rdr_activeEdges_adds_high
+                            rdrCtx.stats.stat_rdr_activeEdges_adds_high
                                 .add(ptrLen);
                         }
                     }
                     ptrEnd = numCrossings + ptrLen;
 
                     if (edgePtrsLen < ptrEnd) {
-                        if (doStats) {
-                            RendererContext.stats.stat_array_renderer_edgePtrs
+                        if (DO_STATS) {
+                            rdrCtx.stats.stat_array_renderer_edgePtrs
                                 .add(ptrEnd);
                         }
                         this.edgePtrs = _edgePtrs
@@ -908,8 +908,8 @@
                         }
                         // use ArrayCache.getNewSize() to use the same growing
                         // factor than widenDirtyIntArray():
-                        if (doStats) {
-                            RendererContext.stats.stat_array_renderer_aux_edgePtrs
+                        if (DO_STATS) {
+                            rdrCtx.stats.stat_array_renderer_aux_edgePtrs
                                 .add(ptrEnd);
                         }
                         this.aux_edgePtrs = _aux_edgePtrs
@@ -936,8 +936,8 @@
                         if (_crossings != crossings_initial) {
                             rdrCtx.putDirtyIntArray(_crossings);
                         }
-                        if (doStats) {
-                            RendererContext.stats.stat_array_renderer_crossings
+                        if (DO_STATS) {
+                            rdrCtx.stats.stat_array_renderer_crossings
                                 .add(numCrossings);
                         }
                         this.crossings = _crossings
@@ -947,8 +947,8 @@
                         if (_aux_crossings != aux_crossings_initial) {
                             rdrCtx.putDirtyIntArray(_aux_crossings);
                         }
-                        if (doStats) {
-                            RendererContext.stats.stat_array_renderer_aux_crossings
+                        if (DO_STATS) {
+                            rdrCtx.stats.stat_array_renderer_aux_crossings
                                 .add(numCrossings);
                         }
                         this.aux_crossings = _aux_crossings
@@ -956,7 +956,7 @@
 
                         crossingsLen = _crossings.length;
                     }
-                    if (doStats) {
+                    if (DO_STATS) {
                         // update max used mark
                         if (numCrossings > _arrayMaxUsed) {
                             _arrayMaxUsed = numCrossings;
@@ -972,10 +972,10 @@
                  * for newly added edges + final merge pass.
                  */
                 if ((ptrLen < 10) || (numCrossings < 40)) {
-                    if (doStats) {
-                        RendererContext.stats.hist_rdr_crossings
+                    if (DO_STATS) {
+                        rdrCtx.stats.hist_rdr_crossings
                             .add(numCrossings);
-                        RendererContext.stats.hist_rdr_crossings_adds
+                        rdrCtx.stats.hist_rdr_crossings_adds
                             .add(ptrLen);
                     }
 
@@ -1018,23 +1018,23 @@
                         _unsafe.putInt(addr,               curx - ((err >> 30) & _ALL_BUT_LSB));
                         _unsafe.putInt(addr + _OFF_ERROR, (err & _ERR_STEP_MAX));
 
-                        if (doStats) {
-                            RendererContext.stats.stat_rdr_crossings_updates
+                        if (DO_STATS) {
+                            rdrCtx.stats.stat_rdr_crossings_updates
                                 .add(numCrossings);
                         }
 
                         // insertion sort of crossings:
                         if (cross < lastCross) {
-                            if (doStats) {
-                                RendererContext.stats.stat_rdr_crossings_sorts
+                            if (DO_STATS) {
+                                rdrCtx.stats.stat_rdr_crossings_sorts
                                     .add(i);
                             }
 
                             /* use binary search for newly added edges
                                in crossings if arrays are large enough */
                             if (useBinarySearch && (i >= prevNumCrossings)) {
-                                if (doStats) {
-                                    RendererContext.stats.
+                                if (DO_STATS) {
+                                    rdrCtx.stats.
                                         stat_rdr_crossings_bsearch.add(i);
                                 }
                                 low = 0;
@@ -1077,14 +1077,14 @@
                         }
                     }
                 } else {
-                    if (doStats) {
-                        RendererContext.stats.stat_rdr_crossings_msorts
+                    if (DO_STATS) {
+                        rdrCtx.stats.stat_rdr_crossings_msorts
                             .add(numCrossings);
-                        RendererContext.stats.hist_rdr_crossings_ratio
+                        rdrCtx.stats.hist_rdr_crossings_ratio
                             .add((1000 * ptrLen) / numCrossings);
-                        RendererContext.stats.hist_rdr_crossings_msorts
+                        rdrCtx.stats.hist_rdr_crossings_msorts
                             .add(numCrossings);
-                        RendererContext.stats.hist_rdr_crossings_msorts_adds
+                        rdrCtx.stats.hist_rdr_crossings_msorts_adds
                             .add(ptrLen);
                     }
 
@@ -1124,8 +1124,8 @@
                         _unsafe.putInt(addr,               curx - ((err >> 30) & _ALL_BUT_LSB));
                         _unsafe.putInt(addr + _OFF_ERROR, (err & _ERR_STEP_MAX));
 
-                        if (doStats) {
-                            RendererContext.stats.stat_rdr_crossings_updates
+                        if (DO_STATS) {
+                            rdrCtx.stats.stat_rdr_crossings_updates
                                 .add(numCrossings);
                         }
 
@@ -1135,8 +1135,8 @@
                             _crossings[i]     = cross;
 
                         } else if (cross < lastCross) {
-                            if (doStats) {
-                                RendererContext.stats.stat_rdr_crossings_sorts
+                            if (DO_STATS) {
+                                rdrCtx.stats.stat_rdr_crossings_sorts
                                     .add(i);
                             }
 
@@ -1356,10 +1356,10 @@
                         useBlkFlags = (maxX > _BLK_SIZE) && (maxX >
                             (((numCrossings >> stroking) - 1) << _BLK_SIZE_LG));
 
-                        if (doStats) {
+                        if (DO_STATS) {
                             tmp = FloatMath.max(1,
                                     ((numCrossings >> stroking) - 1));
-                            RendererContext.stats.hist_tile_generator_encoding_dist
+                            rdrCtx.stats.hist_tile_generator_encoding_dist
                                 .add(maxX / tmp);
                         }
                     }
@@ -1392,15 +1392,15 @@
         edgeCount = numCrossings;
         prevUseBlkFlags = useBlkFlags;
 
-        if (doStats) {
+        if (DO_STATS) {
             // update max used mark
             activeEdgeMaxUsed = _arrayMaxUsed;
         }
     }
 
     boolean endRendering() {
-        if (doMonitors) {
-            RendererContext.stats.mon_rdr_endRendering.start();
+        if (DO_MONITORS) {
+            rdrCtx.stats.mon_rdr_endRendering.start();
         }
         if (edgeMinY == Integer.MAX_VALUE) {
             return false; // undefined edges bounds
@@ -1427,7 +1427,7 @@
         buckets_minY = spminY - _boundsMinY;
         buckets_maxY = maxY   - _boundsMinY;
 
-        if (doLogBounds) {
+        if (DO_LOG_BOUNDS) {
             MarlinUtils.logInfo("edgesXY = [" + edgeMinX + " ... " + edgeMaxX
                                 + "][" + edgeMinY + " ... " + edgeMaxY + "]");
             MarlinUtils.logInfo("spXY    = [" + spminX + " ... " + spmaxX
@@ -1479,7 +1479,7 @@
         // exclusive:
         bbox_spmaxY = FloatMath.min(spmaxY + 1, pmaxY << SUBPIXEL_LG_POSITIONS_Y);
 
-        if (doLogBounds) {
+        if (DO_LOG_BOUNDS) {
             MarlinUtils.logInfo("pXY       = [" + pminX + " ... " + pmaxX
                                 + "[ [" + pminY + " ... " + pmaxY + "[");
             MarlinUtils.logInfo("bbox_spXY = [" + bbox_spminX + " ... "
@@ -1493,8 +1493,8 @@
 
         // Useful when processing tile line by tile line
         if (width > INITIAL_AA_ARRAY) {
-            if (doStats) {
-                RendererContext.stats.stat_array_renderer_alphaline
+            if (DO_STATS) {
+                rdrCtx.stats.stat_array_renderer_alphaline
                     .add(width);
             }
             alphaLine = rdrCtx.getIntArray(width);
@@ -1509,8 +1509,8 @@
     private int bbox_spminX, bbox_spmaxX, bbox_spminY, bbox_spmaxY;
 
     void endRendering(final int pminY) {
-        if (doMonitors) {
-            RendererContext.stats.mon_rdr_endRendering_Y.start();
+        if (DO_MONITORS) {
+            rdrCtx.stats.mon_rdr_endRendering_Y.start();
         }
 
         final int spminY       = pminY << SUBPIXEL_LG_POSITIONS_Y;
@@ -1527,8 +1527,8 @@
             // Process only one tile line:
             _endRendering(fixed_spminY, spmaxY);
         }
-        if (doMonitors) {
-            RendererContext.stats.mon_rdr_endRendering_Y.stop();
+        if (DO_MONITORS) {
+            rdrCtx.stats.mon_rdr_endRendering_Y.stop();
         }
     }
 
@@ -1544,13 +1544,13 @@
                    final boolean useBlockFlags)
     {
         if (useBlockFlags) {
-            if (doStats) {
-                RendererContext.stats.hist_tile_generator_encoding.add(1);
+            if (DO_STATS) {
+                rdrCtx.stats.hist_tile_generator_encoding.add(1);
             }
             cache.copyAARowRLE_WithBlockFlags(blkFlags, alphaRow, pix_y, pix_from, pix_to);
         } else {
-            if (doStats) {
-                RendererContext.stats.hist_tile_generator_encoding.add(0);
+            if (DO_STATS) {
+                rdrCtx.stats.hist_tile_generator_encoding.add(0);
             }
             cache.copyAARowNoRLE(alphaRow, pix_y, pix_from, pix_to);
         }
diff --git a/src/share/classes/sun/java2d/marlin/RendererContext.java b/src/share/classes/sun/java2d/marlin/RendererContext.java
--- a/src/share/classes/sun/java2d/marlin/RendererContext.java
+++ b/src/share/classes/sun/java2d/marlin/RendererContext.java
@@ -40,12 +40,12 @@
 final class RendererContext extends ReentrantContext implements MarlinConst {
 
     // RendererContext creation counter
-    private static final AtomicInteger contextCount = new AtomicInteger(1);
+    private static final AtomicInteger CTX_COUNT = new AtomicInteger(1);
     // RendererContext statistics
-    static final RendererStats stats = (doStats || doMonitors)
+    final RendererStats stats = (DO_STATS || DO_MONITORS)
                                        ? RendererStats.getInstance(): null;
 
-    private static final boolean USE_CACHE_HARD_REF = doStats
+    private static final boolean USE_CACHE_HARD_REF = DO_STATS
         || (MarlinRenderingEngine.REF_TYPE == ReentrantContextProvider.REF_WEAK);
 
     /**
@@ -55,10 +55,10 @@
      */
     static RendererContext createContext() {
         final RendererContext newCtx = new RendererContext("ctx"
-                    + Integer.toString(contextCount.getAndIncrement()));
+                    + Integer.toString(CTX_COUNT.getAndIncrement()));
 
-        if (RendererContext.stats != null) {
-            RendererContext.stats.allContexts.add(newCtx);
+        if (DO_STATS || DO_MONITORS) {
+            RendererStats.ALL_CONTEXTS.add(newCtx);
         }
         return newCtx;
     }
@@ -101,7 +101,7 @@
      * @param name context name (debugging)
      */
     RendererContext(final String name) {
-        if (logCreateContext) {
+        if (LOG_CREATE_CONTEXT) {
             MarlinUtils.logInfo("new RendererContext = " + name);
         }
 
@@ -162,7 +162,7 @@
                      : null;
             // create a new ArrayCachesHolder if none is available
             if (holder == null) {
-                if (logCreateContext) {
+                if (LOG_CREATE_CONTEXT) {
                     MarlinUtils.logInfo("new ArrayCachesHolder for "
                                         + "RendererContext = " + name);
                 }
@@ -192,11 +192,11 @@
             return getDirtyByteArrayCache(length).getArray();
         }
 
-        if (doStats) {
+        if (DO_STATS) {
             incOversize();
         }
 
-        if (doLogOverSize) {
+        if (DO_LOG_OVERSIZE) {
             logInfo("getDirtyByteArray[oversize]: length=\t" + length);
         }
 
@@ -216,10 +216,10 @@
                                final int usedSize, final int needSize)
     {
         final int length = in.length;
-        if (doChecks && length >= needSize) {
+        if (DO_CHECKS && length >= needSize) {
             return in;
         }
-        if (doStats) {
+        if (DO_STATS) {
             incResizeDirtyByte();
         }
 
@@ -233,7 +233,7 @@
         // NO clean-up of array data = DIRTY ARRAY
         putDirtyByteArray(in);
 
-        if (doLogWidenArray) {
+        if (DO_LOG_WIDEN_ARRAY) {
             logInfo("widenDirtyByteArray[" + res.length + "]: usedSize=\t"
                     + usedSize + "\tlength=\t" + length + "\tneeded length=\t"
                     + needSize);
@@ -252,11 +252,11 @@
             return getIntArrayCache(length).getArray();
         }
 
-        if (doStats) {
+        if (DO_STATS) {
             incOversize();
         }
 
-        if (doLogOverSize) {
+        if (DO_LOG_OVERSIZE) {
             logInfo("getIntArray[oversize]: length=\t" + length);
         }
 
@@ -268,10 +268,10 @@
                         final int needSize, final int clearTo)
     {
         final int length = in.length;
-        if (doChecks && length >= needSize) {
+        if (DO_CHECKS && length >= needSize) {
             return in;
         }
-        if (doStats) {
+        if (DO_STATS) {
             incResizeInt();
         }
 
@@ -284,7 +284,7 @@
         // maybe return current array:
         putIntArray(in, 0, clearTo); // ensure all array is cleared (grow-reduce algo)
 
-        if (doLogWidenArray) {
+        if (DO_LOG_WIDEN_ARRAY) {
             logInfo("widenIntArray[" + res.length + "]: usedSize=\t"
                     + usedSize + "\tlength=\t" + length + "\tneeded length=\t"
                     + needSize);
@@ -314,11 +314,11 @@
             return getDirtyIntArrayCache(length).getArray();
         }
 
-        if (doStats) {
+        if (DO_STATS) {
             incOversize();
         }
 
-        if (doLogOverSize) {
+        if (DO_LOG_OVERSIZE) {
             logInfo("getDirtyIntArray[oversize]: length=\t" + length);
         }
 
@@ -329,10 +329,10 @@
                              final int usedSize, final int needSize)
     {
         final int length = in.length;
-        if (doChecks && length >= needSize) {
+        if (DO_CHECKS && length >= needSize) {
             return in;
         }
-        if (doStats) {
+        if (DO_STATS) {
             incResizeDirtyInt();
         }
 
@@ -346,7 +346,7 @@
         // NO clean-up of array data = DIRTY ARRAY
         putDirtyIntArray(in);
 
-        if (doLogWidenArray) {
+        if (DO_LOG_WIDEN_ARRAY) {
             logInfo("widenDirtyIntArray[" + res.length + "]: usedSize=\t"
                     + usedSize + "\tlength=\t" + length + "\tneeded length=\t"
                     + needSize);
@@ -374,11 +374,11 @@
             return getDirtyFloatArrayCache(length).getArray();
         }
 
-        if (doStats) {
+        if (DO_STATS) {
             incOversize();
         }
 
-        if (doLogOverSize) {
+        if (DO_LOG_OVERSIZE) {
             logInfo("getDirtyFloatArray[oversize]: length=\t" + length);
         }
 
@@ -389,10 +389,10 @@
                                  final int usedSize, final int needSize)
     {
         final int length = in.length;
-        if (doChecks && length >= needSize) {
+        if (DO_CHECKS && length >= needSize) {
             return in;
         }
-        if (doStats) {
+        if (DO_STATS) {
             incResizeDirtyFloat();
         }
 
@@ -406,7 +406,7 @@
         // NO clean-up of array data = DIRTY ARRAY
         putDirtyFloatArray(in);
 
-        if (doLogWidenArray) {
+        if (DO_LOG_WIDEN_ARRAY) {
             logInfo("widenDirtyFloatArray[" + res.length + "]: usedSize=\t"
                     + usedSize + "\tlength=\t" + length + "\tneeded length=\t"
                     + needSize);
diff --git a/src/share/classes/sun/java2d/marlin/RendererStats.java b/src/share/classes/sun/java2d/marlin/RendererStats.java
--- a/src/share/classes/sun/java2d/marlin/RendererStats.java
+++ b/src/share/classes/sun/java2d/marlin/RendererStats.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2016, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -42,24 +42,24 @@
 public final class RendererStats implements MarlinConst {
 
     // singleton
-    private static volatile RendererStats singleton = null;
+    private static volatile RendererStats SINGLETON = null;
 
     static RendererStats getInstance() {
-        if (singleton == null) {
-            singleton = new RendererStats();
+        if (SINGLETON == null) {
+            SINGLETON = new RendererStats();
         }
-        return singleton;
+        return SINGLETON;
     }
 
     public static void dumpStats() {
-        if (singleton != null) {
-            singleton.dump();
+        if (SINGLETON != null) {
+            SINGLETON.dump();
         }
     }
 
     /* RendererContext collection as hard references
        (only used for debugging purposes) */
-    final ConcurrentLinkedQueue<RendererContext> allContexts
+    static final ConcurrentLinkedQueue<RendererContext> ALL_CONTEXTS
         = new ConcurrentLinkedQueue<RendererContext>();
     // stats
     final StatLong stat_cache_rowAA
@@ -208,8 +208,6 @@
     // monitors
     final Monitor mon_pre_getAATileGenerator
         = new Monitor("MarlinRenderingEngine.getAATileGenerator()");
-    final Monitor mon_npi_currentSegment
-        = new Monitor("NormalizingPathIterator.currentSegment()");
     final Monitor mon_rdr_addLine
         = new Monitor("Renderer.addLine()");
     final Monitor mon_rdr_endRendering
@@ -227,7 +225,6 @@
     // all monitors
     final Monitor[] monitors = new Monitor[]{
         mon_pre_getAATileGenerator,
-        mon_npi_currentSegment,
         mon_rdr_addLine,
         mon_rdr_endRendering,
         mon_rdr_endRendering_Y,
@@ -255,14 +252,14 @@
                 hook.setContextClassLoader(null);
                 Runtime.getRuntime().addShutdownHook(hook);
 
-                if (useDumpThread) {
+                if (USE_DUMP_THREAD) {
                     final Timer statTimer = new Timer("RendererStats");
                     statTimer.scheduleAtFixedRate(new TimerTask() {
                         @Override
                         public void run() {
                             dump();
                         }
-                    }, statDump, statDump);
+                    }, DUMP_INTERVAL, DUMP_INTERVAL);
                 }
                 return null;
             }
@@ -270,15 +267,13 @@
     }
 
     void dump() {
-        if (doStats) {
+        if (DO_STATS) {
             ArrayCache.dumpStats();
         }
-        final RendererContext[] all = allContexts.toArray(
-                                          new RendererContext[allContexts.size()]);
-        for (RendererContext rdrCtx : all) {
+        for (RendererContext rdrCtx : ALL_CONTEXTS) {
             logInfo("RendererContext: " + rdrCtx.name);
 
-            if (doMonitors) {
+            if (DO_MONITORS) {
                 for (Monitor monitor : monitors) {
                     if (monitor.count != 0) {
                         logInfo(monitor.toString());
@@ -292,14 +287,14 @@
                                 + ((100d * monitor.sum) / total) + " %");
                     }
                 }
-                if (doFlushMonitors) {
+                if (DO_FLUSH_MONITORS) {
                     for (Monitor m : monitors) {
                         m.reset();
                     }
                 }
             }
 
-            if (doStats) {
+            if (DO_STATS) {
                 for (StatLong stat : statistics) {
                     if (stat.count != 0) {
                         logInfo(stat.toString());
diff --git a/src/share/classes/sun/java2d/marlin/Stroker.java b/src/share/classes/sun/java2d/marlin/Stroker.java
--- a/src/share/classes/sun/java2d/marlin/Stroker.java
+++ b/src/share/classes/sun/java2d/marlin/Stroker.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007, 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2016, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -180,7 +180,7 @@
     void dispose() {
         reverse.dispose();
 
-        if (doCleanDirty) {
+        if (DO_CLEAN_DIRTY) {
             // Force zero-fill dirty arrays:
             Arrays.fill(offset0, 0f);
             Arrays.fill(offset1, 0f);
@@ -226,7 +226,7 @@
                                boolean rev,
                                float threshold)
     {
-        if ((omx == 0 && omy == 0) || (mx == 0 && my == 0)) {
+        if ((omx == 0f && omy == 0f) || (mx == 0f && my == 0f)) {
             return;
         }
 
@@ -338,12 +338,14 @@
     }
 
     private void drawRoundCap(float cx, float cy, float mx, float my) {
-        emitCurveTo(cx+mx-C*my, cy+my+C*mx,
-                    cx-my+C*mx, cy+mx+C*my,
-                    cx-my,      cy+mx);
-        emitCurveTo(cx-my-C*mx, cy+mx-C*my,
-                    cx-mx-C*my, cy-my+C*mx,
-                    cx-mx,      cy-my);
+        final float Cmx = C * mx;
+        final float Cmy = C * my;
+        emitCurveTo(cx + mx - Cmy, cy + my + Cmx,
+                    cx - my + Cmx, cy + mx + Cmy,
+                    cx - my,       cy + mx);
+        emitCurveTo(cx - my - Cmx, cy + mx - Cmy,
+                    cx - mx - Cmy, cy - my + Cmx,
+                    cx - mx,       cy - my);
     }
 
     // Put the intersection point of the lines (x0, y0) -> (x1, y1)
@@ -412,8 +414,8 @@
         }
         this.sx0 = this.cx0 = x0;
         this.sy0 = this.cy0 = y0;
-        this.cdx = this.sdx = 1;
-        this.cdy = this.sdy = 0;
+        this.cdx = this.sdx = 1f;
+        this.cdy = this.sdy = 0f;
         this.prev = MOVE_TO;
     }
 
@@ -452,10 +454,10 @@
                 return;
             }
             emitMoveTo(cx0, cy0 - lineWidth2);
-            this.cmx = this.smx = 0;
+            this.cmx = this.smx = 0f;
             this.cmy = this.smy = -lineWidth2;
-            this.cdx = this.sdx = 1;
-            this.cdy = this.sdy = 0;
+            this.cdx = this.sdx = 1f;
+            this.cdy = this.sdy = 0f;
             finish();
             return;
         }
@@ -1232,7 +1234,7 @@
             end = 0;
             numCurves = 0;
 
-            if (doStats) {
+            if (DO_STATS) {
                 curveTypesUseMark = 0;
                 curvesUseMark = 0;
             }
@@ -1246,10 +1248,10 @@
             end = 0;
             numCurves = 0;
 
-            if (doStats) {
-                RendererContext.stats.stat_rdr_poly_stack_types
+            if (DO_STATS) {
+                rdrCtx.stats.stat_rdr_poly_stack_types
                     .add(curveTypesUseMark);
-                RendererContext.stats.stat_rdr_poly_stack_curves
+                rdrCtx.stats.stat_rdr_poly_stack_curves
                     .add(curvesUseMark);
                 // reset marks
                 curveTypesUseMark = 0;
@@ -1272,15 +1274,15 @@
         private void ensureSpace(final int n) {
             // use substraction to avoid integer overflow:
             if (curves.length - end < n) {
-                if (doStats) {
-                    RendererContext.stats.stat_array_stroker_polystack_curves
+                if (DO_STATS) {
+                    rdrCtx.stats.stat_array_stroker_polystack_curves
                         .add(end + n);
                 }
                 curves = rdrCtx.widenDirtyFloatArray(curves, end, end + n);
             }
             if (curveTypes.length <= numCurves) {
-                if (doStats) {
-                    RendererContext.stats.stat_array_stroker_polystack_curveTypes
+                if (DO_STATS) {
+                    rdrCtx.stats.stat_array_stroker_polystack_curveTypes
                         .add(numCurves + 1);
                 }
                 curveTypes = rdrCtx.widenDirtyByteArray(curveTypes,
@@ -1323,7 +1325,7 @@
         }
 
         void popAll(PathConsumer2D io) {
-            if (doStats) {
+            if (DO_STATS) {
                 // update used marks:
                 if (numCurves > curveTypesUseMark) {
                     curveTypesUseMark = numCurves;
diff --git a/src/share/classes/sun/java2d/marlin/Version.java b/src/share/classes/sun/java2d/marlin/Version.java
--- a/src/share/classes/sun/java2d/marlin/Version.java
+++ b/src/share/classes/sun/java2d/marlin/Version.java
@@ -27,10 +27,10 @@
 
 public final class Version {
 
-    private static final String version = "marlin-0.7.3.3-Unsafe-OpenJDK";
+    private static final String VERSION = "marlin-0.7.3.4-Unsafe-OpenJDK";
 
     public static String getVersion() {
-        return version;
+        return VERSION;
     }
 
     private Version() {
diff --git a/src/share/classes/sun/java2d/marlin/stats/Histogram.java b/src/share/classes/sun/java2d/marlin/stats/Histogram.java
--- a/src/share/classes/sun/java2d/marlin/stats/Histogram.java
+++ b/src/share/classes/sun/java2d/marlin/stats/Histogram.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2016, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,8 +25,6 @@
 
 package sun.java2d.marlin.stats;
 
-import java.util.Arrays;
-
 /**
  * Generic histogram based on long statistics
  */
diff --git a/src/share/classes/sun/java2d/pipe/AAShapePipe.java b/src/share/classes/sun/java2d/pipe/AAShapePipe.java
--- a/src/share/classes/sun/java2d/pipe/AAShapePipe.java
+++ b/src/share/classes/sun/java2d/pipe/AAShapePipe.java
@@ -44,10 +44,10 @@
 public final class AAShapePipe
     implements ShapeDrawPipe, ParallelogramPipe
 {
-    static final RenderingEngine renderengine = RenderingEngine.getInstance();
+    static final RenderingEngine RDR_ENGINE = RenderingEngine.getInstance();
 
     // Per-thread TileState (~1K very small so do not use any Weak Reference)
-    private static final ReentrantContextProvider<TileState> tileStateProvider =
+    private static final ReentrantContextProvider<TileState> TILE_STATE_PROVIDER =
             new ReentrantContextProviderTL<TileState>(
                     ReentrantContextProvider.REF_HARD)
             {
@@ -90,19 +90,19 @@
                                   double dx1, double dy1,
                                   double dx2, double dy2)
     {
-        final TileState ts = tileStateProvider.acquire();
+        final TileState ts = TILE_STATE_PROVIDER.acquire();
         try {
             final int[] abox = ts.abox;
 
             final AATileGenerator aatg =
-                renderengine.getAATileGenerator(x, y, dx1, dy1, dx2, dy2, 0, 0,
+                RDR_ENGINE.getAATileGenerator(x, y, dx1, dy1, dx2, dy2, 0, 0,
                                                 sg.getCompClip(), abox);
             if (aatg != null) {
                 renderTiles(sg, ts.computeBBox(ux1, uy1, ux2, uy2),
                             aatg, abox, ts);
             }
         } finally {
-            tileStateProvider.release(ts);
+            TILE_STATE_PROVIDER.release(ts);
         }
     }
 
@@ -115,12 +115,12 @@
                                   double dx2, double dy2,
                                   double lw1, double lw2)
     {
-        final TileState ts = tileStateProvider.acquire();
+        final TileState ts = TILE_STATE_PROVIDER.acquire();
         try {
             final int[] abox = ts.abox;
 
             final AATileGenerator aatg =
-                renderengine.getAATileGenerator(x, y, dx1, dy1, dx2, dy2, lw1,
+                RDR_ENGINE.getAATileGenerator(x, y, dx1, dy1, dx2, dy2, lw1,
                                                 lw2, sg.getCompClip(), abox);
             if (aatg != null) {
                 // Note that bbox is of the original shape, not the wide path.
@@ -129,7 +129,7 @@
                             aatg, abox, ts);
             }
         } finally {
-            tileStateProvider.release(ts);
+            TILE_STATE_PROVIDER.release(ts);
         }
     }
 
@@ -138,18 +138,18 @@
                           sg.strokeHint != SunHints.INTVAL_STROKE_PURE);
         final boolean thin = (sg.strokeState <= SunGraphics2D.STROKE_THINDASHED);
 
-        final TileState ts = tileStateProvider.acquire();
+        final TileState ts = TILE_STATE_PROVIDER.acquire();
         try {
             final int[] abox = ts.abox;
 
             final AATileGenerator aatg =
-                renderengine.getAATileGenerator(s, sg.transform, sg.getCompClip(),
+                RDR_ENGINE.getAATileGenerator(s, sg.transform, sg.getCompClip(),
                                                 bs, thin, adjust, abox);
             if (aatg != null) {
                 renderTiles(sg, s, aatg, abox, ts);
             }
         } finally {
-            tileStateProvider.release(ts);
+            TILE_STATE_PROVIDER.release(ts);
         }
     }
 
